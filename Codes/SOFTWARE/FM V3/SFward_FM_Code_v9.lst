CCS PCH C Compiler, Version 5.056, 29513               11-Oct-22 09:56

               Filename:   E:\SF-WARD FM BIRDS4&5\BIRDS5 SFWARD FINAL UPLOADED\BIRDS5 FM V3\SFward_FM_Code_v9.lst

               ROM used:   30382 bytes (23%)
                           Largest free fragment is 65520
               RAM used:   3159 (88%) at main() level
                           3233 (90%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   6656
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FA3.5
0005E:  GOTO   0068
00062:  BTFSC  FA4.5
00064:  GOTO   049A
00068:  BTFSS  F61.5
0006A:  GOTO   0074
0006E:  BTFSC  FA6.5
00070:  GOTO   06D6
00074:  MOVFF  0E,00
00078:  MOVFF  0F,01
0007C:  MOVFF  10,02
00080:  MOVFF  11,03
00084:  MOVFF  0C,FE9
00088:  MOVFF  07,FEA
0008C:  BSF    07.7
0008E:  MOVFF  08,FE1
00092:  MOVFF  09,FE2
00096:  MOVFF  0A,FD9
0009A:  MOVFF  0B,FDA
0009E:  MOVFF  12,FF3
000A2:  MOVFF  13,FF4
000A6:  MOVFF  14,FFA
000AA:  MOVFF  15,FF5
000AE:  MOVFF  16,FF6
000B2:  MOVFF  17,FF7
000B6:  MOVFF  18,FF8
000BA:  MOVFF  19,FFB
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... #include <SFward_FM_Code_v3.h> 
.................... #include <18F67J94.h> 
.................... //////////// Standard Header file for the PIC18F67J94 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F67J94 
000CA:  CLRF   FF7
000CC:  ADDLW  DE
000CE:  MOVWF  FF6
000D0:  MOVLW  00
000D2:  ADDWFC FF7,F
000D4:  MOVLW  00
000D6:  MOVWF  FF8
000D8:  TBLRD*+
000DA:  MOVF   FF5,W
000DC:  RETURN 0
000DE:  DATA 4A,47
000E0:  DATA 36,59
000E2:  DATA 4B,4D
000E4:  DATA 00,00
000E6:  DATA 45,72
000E8:  DATA 61,73
000EA:  DATA 69,6E
000EC:  DATA 67,20
000EE:  DATA 53,65
000F0:  DATA 63,74
000F2:  DATA 6F,72
000F4:  DATA 36,34
000F6:  DATA 6B,62
000F8:  DATA 20,61
000FA:  DATA 64,72
000FC:  DATA 73,20
000FE:  DATA 25,6C
00100:  DATA 58,0D
00102:  DATA 0A,00
00104:  DATA 45,72
00106:  DATA 61,73
00108:  DATA 69,6E
0010A:  DATA 67,20
0010C:  DATA 53,65
0010E:  DATA 63,74
00110:  DATA 6F,72
00112:  DATA 36,34
00114:  DATA 6B,62
00116:  DATA 20,61
00118:  DATA 64,72
0011A:  DATA 73,20
0011C:  DATA 25,6C
0011E:  DATA 58,0D
00120:  DATA 0A,00
00122:  DATA 45,72
00124:  DATA 61,73
00126:  DATA 69,6E
00128:  DATA 67,20
0012A:  DATA 73,75
0012C:  DATA 62,73
0012E:  DATA 65,63
00130:  DATA 74,6F
00132:  DATA 72,34
00134:  DATA 6B,62
00136:  DATA 20,61
00138:  DATA 64,72
0013A:  DATA 73,20
0013C:  DATA 25,6C
0013E:  DATA 58,0D
00140:  DATA 0A,00
00142:  DATA 45,72
00144:  DATA 61,73
00146:  DATA 69,6E
00148:  DATA 67,20
0014A:  DATA 73,75
0014C:  DATA 62,73
0014E:  DATA 65,63
00150:  DATA 74,6F
00152:  DATA 72,34
00154:  DATA 6B,62
00156:  DATA 20,61
00158:  DATA 64,72
0015A:  DATA 73,20
0015C:  DATA 25,6C
0015E:  DATA 58,0D
00160:  DATA 0A,00
00162:  DATA 53,65
00164:  DATA 63,74
00166:  DATA 6F,72
00168:  DATA 20,25
0016A:  DATA 6C,75
0016C:  DATA 20,69
0016E:  DATA 73,20
00170:  DATA 65,72
00172:  DATA 61,73
00174:  DATA 65,64
00176:  DATA 0D,0A
00178:  DATA 00,00
0017A:  DATA 57,72
0017C:  DATA 69,74
0017E:  DATA 69,6E
00180:  DATA 67,5F
00182:  DATA 61,64
00184:  DATA 64,72
00186:  DATA 65,73
00188:  DATA 73,3D
0018A:  DATA 25,6C
0018C:  DATA 58,20
0018E:  DATA 73,68
00190:  DATA 6F,75
00192:  DATA 6C,64
00194:  DATA 20,65
00196:  DATA 6E,64
00198:  DATA 20,69
0019A:  DATA 6E,20
0019C:  DATA 25,6C
0019E:  DATA 58,20
001A0:  DATA 0D,0A
001A2:  DATA 00,00
001A4:  DATA 57,72
001A6:  DATA 69,74
001A8:  DATA 69,6E
001AA:  DATA 67,2E
001AC:  DATA 2E,2E
001AE:  DATA 0D,0A
001B0:  DATA 20,00
001B2:  DATA 57,72
001B4:  DATA 69,74
001B6:  DATA 69,6E
001B8:  DATA 67,5F
001BA:  DATA 61,64
001BC:  DATA 64,72
001BE:  DATA 65,73
001C0:  DATA 73,3D
001C2:  DATA 25,6C
001C4:  DATA 58,20
001C6:  DATA 73,68
001C8:  DATA 6F,75
001CA:  DATA 6C,64
001CC:  DATA 20,65
001CE:  DATA 6E,64
001D0:  DATA 20,69
001D2:  DATA 6E,20
001D4:  DATA 25,6C
001D6:  DATA 58,20
001D8:  DATA 0D,0A
001DA:  DATA 00,00
001DC:  DATA 72,65
001DE:  DATA 73,74
001E0:  DATA 3D,20
001E2:  DATA 25,6C
001E4:  DATA 75,0D
001E6:  DATA 0A,00
001E8:  DATA 0D,0A
001EA:  DATA 20,62
001EC:  DATA 79,74
001EE:  DATA 65,4E
001F0:  DATA 6F,3D
001F2:  DATA 25,58
001F4:  DATA 20,00
001F6:  DATA 57,72
001F8:  DATA 6F,74
001FA:  DATA 65,20
001FC:  DATA 74,68
001FE:  DATA 65,20
00200:  DATA 72,65
00202:  DATA 73,74
00204:  DATA 20,77
00206:  DATA 68,69
00208:  DATA 63,68
0020A:  DATA 20,69
0020C:  DATA 73,20
0020E:  DATA 3D,25
00210:  DATA 6C,75
00212:  DATA 0D,0A
00214:  DATA 00,00
00216:  DATA 57,72
00218:  DATA 69,74
0021A:  DATA 69,6E
0021C:  DATA 67,20
0021E:  DATA 61,64
00220:  DATA 64,72
00222:  DATA 65,73
00224:  DATA 73,20
00226:  DATA 77,61
00228:  DATA 73,3A
0022A:  DATA 20,25
0022C:  DATA 6C,58
0022E:  DATA 20,0D
00230:  DATA 0A,00
00232:  DATA 77,72
00234:  DATA 69,74
00236:  DATA 69,6E
00238:  DATA 67,5F
0023A:  DATA 61,64
0023C:  DATA 64,72
0023E:  DATA 65,73
00240:  DATA 73,20
00242:  DATA 62,65
00244:  DATA 63,61
00246:  DATA 6D,65
00248:  DATA 3D,20
0024A:  DATA 25,6C
0024C:  DATA 58,0D
0024E:  DATA 0A,00
00250:  DATA 6E,75
00252:  DATA 6D,62
00254:  DATA 65,72
00256:  DATA 20,6F
00258:  DATA 66,20
0025A:  DATA 70,61
0025C:  DATA 67,65
0025E:  DATA 73,3A
00260:  DATA 20,25
00262:  DATA 75,0D
00264:  DATA 0A,00
00266:  DATA 70,61
00268:  DATA 67,65
0026A:  DATA 4E,6F
0026C:  DATA 43,6F
0026E:  DATA 75,6E
00270:  DATA 74,65
00272:  DATA 72,3D
00274:  DATA 20,25
00276:  DATA 6C,58
00278:  DATA 20,00
0027A:  DATA 62,69
0027C:  DATA 67,20
0027E:  DATA 6C,6F
00280:  DATA 6F,70
00282:  DATA 2E,2E
00284:  DATA 2E,70
00286:  DATA 61,67
00288:  DATA 65,4E
0028A:  DATA 6F,43
0028C:  DATA 6F,75
0028E:  DATA 6E,74
00290:  DATA 65,72
00292:  DATA 3D,25
00294:  DATA 6C,75
00296:  DATA 20,0D
00298:  DATA 0A,20
0029A:  DATA 00,00
0029C:  DATA 0D,0A
0029E:  DATA 70,61
002A0:  DATA 67,65
002A2:  DATA 4E,6F
002A4:  DATA 43,6F
002A6:  DATA 75,6E
002A8:  DATA 74,65
002AA:  DATA 72,3D
002AC:  DATA 25,6C
002AE:  DATA 58,20
002B0:  DATA 70,61
002B2:  DATA 67,65
002B4:  DATA 4E,6F
002B6:  DATA 43,6F
002B8:  DATA 75,6E
002BA:  DATA 74,65
002BC:  DATA 72,2A
002BE:  DATA 32,35
002C0:  DATA 36,2B
002C2:  DATA 62,79
002C4:  DATA 74,65
002C6:  DATA 4E,6F
002C8:  DATA 3D,25
002CA:  DATA 6C,58
002CC:  DATA 20,62
002CE:  DATA 79,74
002D0:  DATA 65,4E
002D2:  DATA 6F,3D
002D4:  DATA 25,6C
002D6:  DATA 58,20
002D8:  DATA 63,6F
002DA:  DATA 75,6E
002DC:  DATA 74,65
002DE:  DATA 72,3D
002E0:  DATA 25,6C
002E2:  DATA 58,00
002E4:  DATA 57,72
002E6:  DATA 69,74
002E8:  DATA 69,6E
002EA:  DATA 67,20
002EC:  DATA 61,64
002EE:  DATA 64,72
002F0:  DATA 65,73
002F2:  DATA 73,20
002F4:  DATA 77,61
002F6:  DATA 73,3A
002F8:  DATA 20,25
002FA:  DATA 6C,58
002FC:  DATA 20,0D
002FE:  DATA 0A,00
00300:  DATA 77,72
00302:  DATA 69,74
00304:  DATA 69,6E
00306:  DATA 67,5F
00308:  DATA 61,64
0030A:  DATA 64,72
0030C:  DATA 65,73
0030E:  DATA 73,20
00310:  DATA 62,65
00312:  DATA 63,61
00314:  DATA 6D,65
00316:  DATA 3D,20
00318:  DATA 25,6C
0031A:  DATA 58,0D
0031C:  DATA 0A,00
0031E:  DATA 52,58
00320:  DATA 5F,63
00322:  DATA 61,6C
00324:  DATA 6C,73
00326:  DATA 69,67
00328:  DATA 6E,5F
0032A:  DATA 64,65
0032C:  DATA 73,74
0032E:  DATA 3A,20
00330:  DATA 25,73
00332:  DATA 20,0D
00334:  DATA 0A,00
00336:  DATA 52,58
00338:  DATA 5F,53
0033A:  DATA 53,49
0033C:  DATA 44,5F
0033E:  DATA 64,65
00340:  DATA 73,74
00342:  DATA 3A,20
00344:  DATA 25,63
00346:  DATA 00,00
00348:  DATA 52,58
0034A:  DATA 5F,63
0034C:  DATA 61,6C
0034E:  DATA 6C,73
00350:  DATA 69,67
00352:  DATA 6E,5F
00354:  DATA 73,6F
00356:  DATA 75,72
00358:  DATA 63,65
0035A:  DATA 3A,20
0035C:  DATA 25,73
0035E:  DATA 20,0D
00360:  DATA 0A,00
00362:  DATA 52,58
00364:  DATA 5F,53
00366:  DATA 53,49
00368:  DATA 44,5F
0036A:  DATA 73,6F
0036C:  DATA 75,72
0036E:  DATA 63,65
00370:  DATA 3A,20
00372:  DATA 25,63
00374:  DATA 20,0D
00376:  DATA 0A,00
00378:  DATA 52,58
0037A:  DATA 5F,63
0037C:  DATA 6F,6E
0037E:  DATA 74,72
00380:  DATA 6F,6C
00382:  DATA 3A,20
00384:  DATA 25,78
00386:  DATA 20,0D
00388:  DATA 0A,00
0038A:  DATA 52,58
0038C:  DATA 5F,50
0038E:  DATA 49,44
00390:  DATA 3A,20
00392:  DATA 25,78
00394:  DATA 20,0D
00396:  DATA 0A,00
00398:  DATA 52,58
0039A:  DATA 5F,70
0039C:  DATA 61,63
0039E:  DATA 6B,65
003A0:  DATA 74,5F
003A2:  DATA 6C,65
003A4:  DATA 6E,3A
003A6:  DATA 20,25
003A8:  DATA 6C,69
003AA:  DATA 20,0D
003AC:  DATA 0A,00
003AE:  DATA 52,58
003B0:  DATA 5F,69
003B2:  DATA 6E,66
003B4:  DATA 6F,5F
003B6:  DATA 66,69
003B8:  DATA 65,6C
003BA:  DATA 64,20
003BC:  DATA 6C,65
003BE:  DATA 6E,67
003C0:  DATA 74,68
003C2:  DATA 3A,20
003C4:  DATA 25,6C
003C6:  DATA 69,20
003C8:  DATA 0D,0A
003CA:  DATA 00,00
003CC:  DATA 56,61
003CE:  DATA 6C,69
003D0:  DATA 64,20
003D2:  DATA 53,26
003D4:  DATA 46,20
003D6:  DATA 70,61
003D8:  DATA 63,6B
003DA:  DATA 65,74
003DC:  DATA 21,20
003DE:  DATA 0D,0A
003E0:  DATA 00,00
003E2:  DATA 43,6F
003E4:  DATA 6D,6D
003E6:  DATA 61,6E
003E8:  DATA 64,20
003EA:  DATA 75,70
003EC:  DATA 6C,69
003EE:  DATA 6E,6B
003F0:  DATA 20,70
003F2:  DATA 61,63
003F4:  DATA 6B,65
003F6:  DATA 74,20
003F8:  DATA 66,72
003FA:  DATA 6F,6D
003FC:  DATA 20,42
003FE:  DATA 49,52
00400:  DATA 44,53
00402:  DATA 20,47
00404:  DATA 53,21
00406:  DATA 20,0D
00408:  DATA 0A,00
0040A:  DATA 49,6E
0040C:  DATA 76,61
0040E:  DATA 6C,69
00410:  DATA 64,20
00412:  DATA 53,26
00414:  DATA 46,20
00416:  DATA 70,61
00418:  DATA 63,6B
0041A:  DATA 65,74
0041C:  DATA 21,20
0041E:  DATA 0D,0A
00420:  DATA 00,00
00422:  DATA 41,50
00424:  DATA 52,53
00426:  DATA 5F,50
00428:  DATA 61,63
0042A:  DATA 6B,65
0042C:  DATA 74,3A
0042E:  DATA 0D,0A
00430:  DATA 00,00
*
00590:  TBLRD*+
00592:  MOVF   FF5,F
00594:  BZ    05B6
00596:  MOVFF  FF6,C9A
0059A:  MOVFF  FF7,C9B
0059E:  MOVFF  FF8,C9C
005A2:  MOVFF  FF5,C9E
005A6:  RCALL  054A
005A8:  MOVFF  C9A,FF6
005AC:  MOVFF  C9B,FF7
005B0:  MOVFF  C9C,FF8
005B4:  BRA    0590
005B6:  RETURN 0
005B8:  TBLRD*+
005BA:  MOVFF  FF6,C9B
005BE:  MOVFF  FF7,C9C
005C2:  MOVFF  FF8,C9D
005C6:  MOVFF  FF5,C9E
005CA:  RCALL  054A
005CC:  MOVFF  C9B,FF6
005D0:  MOVFF  C9C,FF7
005D4:  MOVFF  C9D,FF8
005D8:  MOVLB  C
005DA:  DECFSZ x9A,F
005DC:  BRA    05E0
005DE:  BRA    05E4
005E0:  MOVLB  0
005E2:  BRA    05B8
005E4:  MOVLB  0
005E6:  RETURN 0
005E8:  MOVLB  C
005EA:  BTFSC  x9B.7
005EC:  BRA    0610
005EE:  MOVLW  0F
005F0:  MOVWF  00
005F2:  SWAPF  x9A,W
005F4:  ANDWF  00,F
005F6:  MOVLW  0A
005F8:  SUBWF  00,W
005FA:  BC    0602
005FC:  MOVLW  30
005FE:  ADDWF  00,F
00600:  BRA    0606
00602:  MOVF   x9B,W
00604:  ADDWF  00,F
00606:  MOVFF  00,C9E
0060A:  MOVLB  0
0060C:  RCALL  054A
0060E:  MOVLB  C
00610:  MOVLW  0F
00612:  ANDWF  x9A,F
00614:  MOVLW  0A
00616:  SUBWF  x9A,W
00618:  BC    061E
0061A:  MOVLW  30
0061C:  BRA    0622
0061E:  BCF    x9B.7
00620:  MOVF   x9B,W
00622:  ADDWF  x9A,F
00624:  MOVFF  C9A,C9E
00628:  MOVLB  0
0062A:  RCALL  054A
0062C:  RETURN 0
0062E:  MOVLB  C
00630:  MOVF   x9D,W
00632:  CLRF   01
00634:  SUBWF  x9C,W
00636:  BC    063E
00638:  MOVFF  C9C,00
0063C:  BRA    0656
0063E:  CLRF   00
00640:  MOVLW  08
00642:  MOVWF  x9E
00644:  RLCF   x9C,F
00646:  RLCF   00,F
00648:  MOVF   x9D,W
0064A:  SUBWF  00,W
0064C:  BTFSC  FD8.0
0064E:  MOVWF  00
00650:  RLCF   01,F
00652:  DECFSZ x9E,F
00654:  BRA    0644
00656:  MOVLB  0
00658:  RETURN 0
0065A:  MOVF   01,W
0065C:  MOVFF  C9A,C9C
00660:  MOVLW  64
00662:  MOVLB  C
00664:  MOVWF  x9D
00666:  MOVLB  0
00668:  RCALL  062E
0066A:  MOVFF  00,C9A
0066E:  MOVF   01,W
00670:  MOVLW  30
00672:  BNZ   0684
00674:  MOVLB  C
00676:  BTFSS  x9B.1
00678:  BRA    0698
0067A:  BTFSC  x9B.3
0067C:  BRA    0698
0067E:  BTFSC  x9B.4
00680:  MOVLW  20
00682:  BRA    068C
00684:  MOVLB  C
00686:  BCF    x9B.3
00688:  BCF    x9B.4
0068A:  BSF    x9B.0
0068C:  ADDWF  01,F
0068E:  MOVFF  01,C9E
00692:  MOVLB  0
00694:  RCALL  054A
00696:  MOVLB  C
00698:  MOVFF  C9A,C9C
0069C:  MOVLW  0A
0069E:  MOVWF  x9D
006A0:  MOVLB  0
006A2:  RCALL  062E
006A4:  MOVFF  00,C9A
006A8:  MOVF   01,W
006AA:  MOVLW  30
006AC:  BNZ   06BE
006AE:  MOVLB  C
006B0:  BTFSC  x9B.3
006B2:  BRA    06C8
006B4:  BTFSS  x9B.0
006B6:  BRA    06C8
006B8:  BTFSC  x9B.4
006BA:  MOVLW  20
006BC:  MOVLB  0
006BE:  ADDWF  01,F
006C0:  MOVFF  01,C9E
006C4:  RCALL  054A
006C6:  MOVLB  C
006C8:  MOVLW  30
006CA:  ADDWF  x9A,F
006CC:  MOVFF  C9A,C9E
006D0:  MOVLB  0
006D2:  RCALL  054A
006D4:  RETURN 0
*
007AE:  DATA 0D,0A
007B0:  DATA 20,52
007B2:  DATA 65,63
007B4:  DATA 65,69
007B6:  DATA 76,65
007B8:  DATA 64,20
007BA:  DATA 61,6E
007BC:  DATA 20,45
007BE:  DATA 30,20
007C0:  DATA 0D,0A
007C2:  DATA 00,00
007C4:  DATA 66,72
007C6:  DATA 6F,6D
007C8:  DATA 20,4D
007CA:  DATA 42,20
007CC:  DATA 77,65
007CE:  DATA 20,72
007D0:  DATA 65,63
007D2:  DATA 65,69
007D4:  DATA 76,65
007D6:  DATA 64,20
007D8:  DATA 25,58
007DA:  DATA 2C,20
007DC:  DATA 6E,75
007DE:  DATA 6D,62
007E0:  DATA 65,72
007E2:  DATA 20,6F
007E4:  DATA 66,20
007E6:  DATA 63,6F
007E8:  DATA 6D,6D
007EA:  DATA 61,6E
007EC:  DATA 64,20
007EE:  DATA 62,79
007F0:  DATA 74,65
007F2:  DATA 73,20
007F4:  DATA 72,63
007F6:  DATA 76,64
007F8:  DATA 3D,25
007FA:  DATA 75,20
007FC:  DATA 0D,0A
007FE:  DATA 00,00
00800:  DATA 66,75
00802:  DATA 6C,6C
00804:  DATA 20,63
00806:  DATA 6F,6D
00808:  DATA 6D,61
0080A:  DATA 6E,64
0080C:  DATA 20,69
0080E:  DATA 73,20
00810:  DATA 72,65
00812:  DATA 63,65
00814:  DATA 69,76
00816:  DATA 65,64
00818:  DATA 20,0D
0081A:  DATA 0A,0D
0081C:  DATA 0A,00
0081E:  DATA 57,72
00820:  DATA 69,74
00822:  DATA 69,6E
00824:  DATA 67,5F
00826:  DATA 73,61
00828:  DATA 74,65
0082A:  DATA 6C,6C
0082C:  DATA 69,74
0082E:  DATA 65,5F
00830:  DATA 69,6E
00832:  DATA 66,6F
00834:  DATA 0D,0A
00836:  DATA 00,00
00838:  DATA 0D,0A
0083A:  DATA 46,69
0083C:  DATA 6E,69
0083E:  DATA 73,68
00840:  DATA 65,64
00842:  DATA 20,77
00844:  DATA 72,69
00846:  DATA 74,69
00848:  DATA 6E,67
0084A:  DATA 20,25
0084C:  DATA 6C,75
0084E:  DATA 20,70
00850:  DATA 61,63
00852:  DATA 6B,65
00854:  DATA 74,73
00856:  DATA 20,6F
00858:  DATA 66,20
0085A:  DATA 64,75
0085C:  DATA 6D,6D
0085E:  DATA 79,20
00860:  DATA 42,79
00862:  DATA 74,65
00864:  DATA 73,20
00866:  DATA 69,6E
00868:  DATA 20,53
0086A:  DATA 46,5F
0086C:  DATA 46,4D
0086E:  DATA 0D,0A
00870:  DATA 0D,0A
00872:  DATA 00,00
00874:  DATA 0D,0A
00876:  DATA 46,4D
00878:  DATA 20,44
0087A:  DATA 61,74
0087C:  DATA 61,20
0087E:  DATA 66,72
00880:  DATA 6F,6D
00882:  DATA 20,61
00884:  DATA 64,64
00886:  DATA 72,73
00888:  DATA 73,20
0088A:  DATA 25,58
0088C:  DATA 25,58
0088E:  DATA 25,58
00890:  DATA 25,58
00892:  DATA 3A,0D
00894:  DATA 0A,00
00896:  DATA 20,54
00898:  DATA 68,69
0089A:  DATA 73,20
0089C:  DATA 61,63
0089E:  DATA 6B,20
008A0:  DATA 69,73
008A2:  DATA 20,73
008A4:  DATA 65,6E
008A6:  DATA 74,3A
008A8:  DATA 20,25
008AA:  DATA 58,20
008AC:  DATA 0D,0A
008AE:  DATA 00,00
008B0:  DATA 0D,0A
008B2:  DATA 0D,0A
008B4:  DATA 00,00
008B6:  DATA 0D,0A
008B8:  DATA 46,69
008BA:  DATA 6E,69
008BC:  DATA 73,68
008BE:  DATA 65,64
008C0:  DATA 20,73
008C2:  DATA 65,6E
008C4:  DATA 64,69
008C6:  DATA 6E,67
008C8:  DATA 20,25
008CA:  DATA 6C,75
008CC:  DATA 20,70
008CE:  DATA 61,63
008D0:  DATA 6B,65
008D2:  DATA 74,73
008D4:  DATA 0D,0A
008D6:  DATA 0D,0A
008D8:  DATA 00,00
008DA:  DATA 53,46
008DC:  DATA 77,61
008DE:  DATA 72,64
008E0:  DATA 20,70
008E2:  DATA 61,63
008E4:  DATA 6B,65
008E6:  DATA 74,20
008E8:  DATA 61,72
008EA:  DATA 72,61
008EC:  DATA 79,20
008EE:  DATA 69,6E
008F0:  DATA 20,52
008F2:  DATA 41,4D
008F4:  DATA 0D,0A
008F6:  DATA 00,00
008F8:  DATA 6E,6F
008FA:  DATA 5F,6F
008FC:  DATA 66,5F
008FE:  DATA 53,46
00900:  DATA 77,61
00902:  DATA 72,64
00904:  DATA 5F,63
00906:  DATA 61,6C
00908:  DATA 6C,73
0090A:  DATA 69,67
0090C:  DATA 6E,73
0090E:  DATA 3D,25
00910:  DATA 75,0D
00912:  DATA 0A,00
00914:  DATA 57,72
00916:  DATA 69,74
00918:  DATA 69,6E
0091A:  DATA 67,20
0091C:  DATA 6C,6F
0091E:  DATA 67,5F
00920:  DATA 61,72
00922:  DATA 72,61
00924:  DATA 79,5F
00926:  DATA 53,46
00928:  DATA 77,61
0092A:  DATA 72,64
0092C:  DATA 5F,61
0092E:  DATA 64,72
00930:  DATA 73,5F
00932:  DATA 70,6F
00934:  DATA 69,6E
00936:  DATA 74,65
00938:  DATA 72,20
0093A:  DATA 74,6F
0093C:  DATA 20,46
0093E:  DATA 4D,0D
00940:  DATA 0A,00
00942:  DATA 0D,0A
00944:  DATA 44,75
00946:  DATA 70,6C
00948:  DATA 69,63
0094A:  DATA 61,74
0094C:  DATA 65,64
0094E:  DATA 2C,2C
00950:  DATA 2C,20
00952:  DATA 0D,0A
00954:  DATA 00,00
00956:  DATA 6E,6F
00958:  DATA 5F,6F
0095A:  DATA 66,5F
0095C:  DATA 53,46
0095E:  DATA 77,61
00960:  DATA 72,64
00962:  DATA 5F,6C
00964:  DATA 6F,67
00966:  DATA 5F,65
00968:  DATA 6E,74
0096A:  DATA 65,72
0096C:  DATA 69,65
0096E:  DATA 73,3A
00970:  DATA 20,25
00972:  DATA 75,0D
00974:  DATA 0A,0D
00976:  DATA 0A,00
00978:  DATA 0D,0A
0097A:  DATA 41,64
0097C:  DATA 64,69
0097E:  DATA 6E,67
00980:  DATA 20,4E
00982:  DATA 45,57
00984:  DATA 20,65
00986:  DATA 6E,74
00988:  DATA 65,72
0098A:  DATA 79,20
0098C:  DATA 69,6E
0098E:  DATA 20,53
00990:  DATA 46,77
00992:  DATA 61,72
00994:  DATA 64,20
00996:  DATA 70,61
00998:  DATA 63,6B
0099A:  DATA 65,74
0099C:  DATA 20,61
0099E:  DATA 72,72
009A0:  DATA 61,79
009A2:  DATA 20,69
009A4:  DATA 6E,20
009A6:  DATA 74,68
009A8:  DATA 65,20
009AA:  DATA 52,41
009AC:  DATA 4D,0D
009AE:  DATA 0A,00
009B0:  DATA 41,20
009B2:  DATA 70,61
009B4:  DATA 63,6B
009B6:  DATA 65,74
009B8:  DATA 20,69
009BA:  DATA 73,20
009BC:  DATA 72,65
009BE:  DATA 63,65
009C0:  DATA 69,76
009C2:  DATA 65,64
009C4:  DATA 20,66
009C6:  DATA 72,6F
009C8:  DATA 6D,20
009CA:  DATA 6E,65
009CC:  DATA 77,20
009CE:  DATA 47,53
009D0:  DATA 20,0D
009D2:  DATA 0A,00
009D4:  DATA 53,46
009D6:  DATA 20,44
009D8:  DATA 41,54
009DA:  DATA 41,3A
009DC:  DATA 20,00
009DE:  DATA 44,6F
009E0:  DATA 6E,65
009E2:  DATA 20,77
009E4:  DATA 72,69
009E6:  DATA 74,69
009E8:  DATA 6E,67
009EA:  DATA 20,53
009EC:  DATA 46,5F
009EE:  DATA 44,61
009F0:  DATA 74,61
009F2:  DATA 20,66
009F4:  DATA 72,6F
009F6:  DATA 6D,20
009F8:  DATA 61,64
009FA:  DATA 64,72
009FC:  DATA 65,73
009FE:  DATA 73,20
00A00:  DATA 25,58
00A02:  DATA 25,58
00A04:  DATA 25,58
00A06:  DATA 25,58
00A08:  DATA 20,0D
00A0A:  DATA 0A,20
00A0C:  DATA 00,00
00A0E:  DATA 55,6E
00A10:  DATA 74,69
00A12:  DATA 6C,6C
00A14:  DATA 20,61
00A16:  DATA 64,64
00A18:  DATA 72,65
00A1A:  DATA 73,73
00A1C:  DATA 20,25
00A1E:  DATA 6C,58
00A20:  DATA 20,0D
00A22:  DATA 0A,0D
00A24:  DATA 0A,20
00A26:  DATA 00,00
00A28:  DATA 46,49
00A2A:  DATA 4E,49
00A2C:  DATA 53,48
00A2E:  DATA 45,44
00A30:  DATA 20,57
00A32:  DATA 52,49
00A34:  DATA 54,49
00A36:  DATA 4E,47
00A38:  DATA 0D,0A
00A3A:  DATA 20,00
00A3C:  DATA 0D,0A
00A3E:  DATA 53,61
00A40:  DATA 76,69
00A42:  DATA 6E,67
00A44:  DATA 20,41
00A46:  DATA 50,52
00A48:  DATA 53,20
00A4A:  DATA 64,61
00A4C:  DATA 74,61
00A4E:  DATA 0D,0A
00A50:  DATA 00,00
00A52:  DATA 0D,0A
00A54:  DATA 4D,65
00A56:  DATA 6D,6F
00A58:  DATA 72,79
00A5A:  DATA 20,69
00A5C:  DATA 73,20
00A5E:  DATA 66,75
00A60:  DATA 6C,6C
00A62:  DATA 2C,20
00A64:  DATA 45,72
00A66:  DATA 61,73
00A68:  DATA 69,6E
00A6A:  DATA 67,20
00A6C:  DATA 6E,6F
00A6E:  DATA 77,20
00A70:  DATA 26,20
00A72:  DATA 77,72
00A74:  DATA 69,74
00A76:  DATA 69,6E
00A78:  DATA 67,20
00A7A:  DATA 41,66
00A7C:  DATA 72,65
00A7E:  DATA 73,68
00A80:  DATA 0D,0A
00A82:  DATA 00,00
00A84:  DATA 0D,0A
00A86:  DATA 41,70
00A88:  DATA 70,65
00A8A:  DATA 6E,64
00A8C:  DATA 69,6E
00A8E:  DATA 67,20
00A90:  DATA 4D,65
00A92:  DATA 6D,6F
00A94:  DATA 72,79
00A96:  DATA 0D,0A
00A98:  DATA 00,00
00A9A:  DATA 73,61
00A9C:  DATA 76,69
00A9E:  DATA 6E,67
00AA0:  DATA 20,61
00AA2:  DATA 64,64
00AA4:  DATA 72,65
00AA6:  DATA 73,73
00AA8:  DATA 20,61
00AAA:  DATA 6E,64
00AAC:  DATA 20,6D
00AAE:  DATA 65,6D
00AB0:  DATA 6F,72
00AB2:  DATA 79,20
00AB4:  DATA 66,6F
00AB6:  DATA 72,20
00AB8:  DATA 53,46
00ABA:  DATA 77,61
00ABC:  DATA 72,64
00ABE:  DATA 20,64
00AC0:  DATA 61,74
00AC2:  DATA 61,20
00AC4:  DATA 61,72
00AC6:  DATA 65,20
00AC8:  DATA 72,65
00ACA:  DATA 73,65
00ACC:  DATA 74,20
00ACE:  DATA 0D,0A
00AD0:  DATA 00,00
00AD2:  DATA 4D,61
00AD4:  DATA 6A,6F
00AD6:  DATA 72,20
00AD8:  DATA 72,65
00ADA:  DATA 73,65
00ADC:  DATA 74,20
00ADE:  DATA 69,73
00AE0:  DATA 20,0D
00AE2:  DATA 0A,00
00AE4:  DATA 4D,61
00AE6:  DATA 6A,6F
00AE8:  DATA 72,20
00AEA:  DATA 72,65
00AEC:  DATA 73,65
00AEE:  DATA 74,20
00AF0:  DATA 69,73
00AF2:  DATA 20,66
00AF4:  DATA 69,6E
00AF6:  DATA 69,73
00AF8:  DATA 68,65
00AFA:  DATA 64,20
00AFC:  DATA 0D,0A
00AFE:  DATA 00,00
00B00:  DATA 0D,0A
00B02:  DATA 0D,0A
00B04:  DATA 00,00
00B06:  DATA 20,42
00B08:  DATA 69,72
00B0A:  DATA 64,73
00B0C:  DATA 35,20
00B0E:  DATA 53,46
00B10:  DATA 77,61
00B12:  DATA 72,64
00B14:  DATA 20,50
00B16:  DATA 72,6F
00B18:  DATA 67,72
00B1A:  DATA 61,6D
00B1C:  DATA 20,53
00B1E:  DATA 74,61
00B20:  DATA 72,74
00B22:  DATA 65,64
00B24:  DATA 20,76
00B26:  DATA 32,0D
00B28:  DATA 0A,00
00B2A:  DATA 41,50
00B2C:  DATA 52,53
00B2E:  DATA 5F,44
00B30:  DATA 50,20
00B32:  DATA 45,6E
00B34:  DATA 61,62
00B36:  DATA 6C,65
00B38:  DATA 64,0D
00B3A:  DATA 0A,00
00B3C:  DATA 57,72
00B3E:  DATA 69,74
00B40:  DATA 69,6E
00B42:  DATA 67,20
00B44:  DATA 74,6F
00B46:  DATA 20,53
00B48:  DATA 46,77
00B4A:  DATA 61,72
00B4C:  DATA 64,46
00B4E:  DATA 4D,20
00B50:  DATA 77,69
00B52:  DATA 6C,6C
00B54:  DATA 20,73
00B56:  DATA 74,61
00B58:  DATA 72,74
00B5A:  DATA 20,66
00B5C:  DATA 72,6F
00B5E:  DATA 6D,20
00B60:  DATA 61,64
00B62:  DATA 64,72
00B64:  DATA 65,73
00B66:  DATA 73,20
00B68:  DATA 25,58
00B6A:  DATA 25,58
00B6C:  DATA 25,58
00B6E:  DATA 25,58
00B70:  DATA 0D,0A
00B72:  DATA 00,00
00B74:  DATA 61,64
00B76:  DATA 64,72
00B78:  DATA 65,73
00B7A:  DATA 73,20
00B7C:  DATA 70,6F
00B7E:  DATA 69,6E
00B80:  DATA 74,65
00B82:  DATA 72,20
00B84:  DATA 25,58
00B86:  DATA 25,58
00B88:  DATA 25,58
00B8A:  DATA 25,58
00B8C:  DATA 0D,0A
00B8E:  DATA 00,00
00B90:  DATA 43,61
00B92:  DATA 6E,6E
00B94:  DATA 6F,74
00B96:  DATA 20,61
00B98:  DATA 63,63
00B9A:  DATA 65,73
00B9C:  DATA 73,20
00B9E:  DATA 74,68
00BA0:  DATA 65,20
00BA2:  DATA 46,6C
00BA4:  DATA 61,73
00BA6:  DATA 68,20
00BA8:  DATA 4D,65
00BAA:  DATA 6D,6F
00BAC:  DATA 72,79
00BAE:  DATA 2C,20
00BB0:  DATA 53,52
00BB2:  DATA 3D,25
00BB4:  DATA 58,0D
00BB6:  DATA 0A,00
00BB8:  DATA 0D,0A
00BBA:  DATA 2A,2A
00BBC:  DATA 2A,2A
00BBE:  DATA 2A,2A
00BC0:  DATA 2A,2A
00BC2:  DATA 2A,2A
00BC4:  DATA 2A,2A
00BC6:  DATA 2A,2A
00BC8:  DATA 2A,2A
00BCA:  DATA 2A,2A
00BCC:  DATA 2A,2A
00BCE:  DATA 2A,2A
00BD0:  DATA 2A,2A
00BD2:  DATA 2A,2A
00BD4:  DATA 2A,2A
00BD6:  DATA 2A,2A
00BD8:  DATA 2A,2A
00BDA:  DATA 2A,2A
00BDC:  DATA 2A,2A
00BDE:  DATA 2A,2A
00BE0:  DATA 2A,2A
00BE2:  DATA 2A,2A
00BE4:  DATA 2A,2A
00BE6:  DATA 2A,2A
00BE8:  DATA 2A,0D
00BEA:  DATA 0A,00
00BEC:  DATA 4E,6F
00BEE:  DATA 6E,20
00BF0:  DATA 53,46
00BF2:  DATA 77,61
00BF4:  DATA 72,64
00BF6:  DATA 20,6D
00BF8:  DATA 73,67
00BFA:  DATA 20,77
00BFC:  DATA 61,73
00BFE:  DATA 20,72
00C00:  DATA 65,63
00C02:  DATA 65,69
00C04:  DATA 76,65
00C06:  DATA 64,2C
00C08:  DATA 20,69
00C0A:  DATA 74,20
00C0C:  DATA 77,61
00C0E:  DATA 73,20
00C10:  DATA 6E,6F
00C12:  DATA 74,20
00C14:  DATA 73,61
00C16:  DATA 76,65
00C18:  DATA 64,20
00C1A:  DATA 74,6F
00C1C:  DATA 20,46
00C1E:  DATA 4D,0D
00C20:  DATA 0A,00
00C22:  DATA 20,54
00C24:  DATA 68,69
00C26:  DATA 73,20
00C28:  DATA 63,6F
00C2A:  DATA 6D,6D
00C2C:  DATA 61,6E
00C2E:  DATA 64,20
00C30:  DATA 69,73
00C32:  DATA 20,72
00C34:  DATA 65,63
00C36:  DATA 65,69
00C38:  DATA 76,65
00C3A:  DATA 64,20
00C3C:  DATA 66,72
00C3E:  DATA 6F,6D
00C40:  DATA 20,4D
00C42:  DATA 42,20
00C44:  DATA 00,00
00C46:  DATA 61,64
00C48:  DATA 64,72
00C4A:  DATA 65,73
00C4C:  DATA 73,49
00C4E:  DATA 6E,54
00C50:  DATA 68,65
00C52:  DATA 43,6F
00C54:  DATA 6D,6D
00C56:  DATA 61,6E
00C58:  DATA 64,20
00C5A:  DATA 20,3D
00C5C:  DATA 20,25
00C5E:  DATA 6C,58
00C60:  DATA 20,0D
00C62:  DATA 0A,00
00C64:  DATA 70,61
00C66:  DATA 63,6B
00C68:  DATA 65,74
00C6A:  DATA 73,4E
00C6C:  DATA 6F,49
00C6E:  DATA 6E,54
00C70:  DATA 68,65
00C72:  DATA 43,6F
00C74:  DATA 6D,6D
00C76:  DATA 61,6E
00C78:  DATA 64,3D
00C7A:  DATA 20,25
00C7C:  DATA 6C,58
00C7E:  DATA 20,0D
00C80:  DATA 0A,00
00C82:  DATA 20,45
00C84:  DATA 30,20
00C86:  DATA 63,6F
00C88:  DATA 6D,6D
00C8A:  DATA 61,6E
00C8C:  DATA 64,2C
00C8E:  DATA 20,73
00C90:  DATA 65,6E
00C92:  DATA 64,20
00C94:  DATA 25,75
00C96:  DATA 20,70
00C98:  DATA 61,63
00C9A:  DATA 6B,65
00C9C:  DATA 74,73
00C9E:  DATA 20,66
00CA0:  DATA 72,6F
00CA2:  DATA 6D,20
00CA4:  DATA 25,58
00CA6:  DATA 25,58
00CA8:  DATA 25,58
00CAA:  DATA 25,58
00CAC:  DATA 20,61
00CAE:  DATA 64,64
00CB0:  DATA 72,65
00CB2:  DATA 73,73
00CB4:  DATA 2E,0D
00CB6:  DATA 0A,00
00CB8:  DATA 41,50
00CBA:  DATA 52,53
00CBC:  DATA 5F,69
00CBE:  DATA 6E,66
00CC0:  DATA 6F,5F
00CC2:  DATA 62,65
00CC4:  DATA 66,6F
00CC6:  DATA 72,65
00CC8:  DATA 20,74
00CCA:  DATA 68,65
00CCC:  DATA 20,73
00CCE:  DATA 65,6E
00CD0:  DATA 64,69
00CD2:  DATA 6E,67
00CD4:  DATA 3A,0D
00CD6:  DATA 0A,00
00CD8:  DATA 45,58
00CDA:  DATA 50,45
00CDC:  DATA 52,45
00CDE:  DATA 4D,45
00CE0:  DATA 4E,54
00CE2:  DATA 20,2E
00CE4:  DATA 2E,2E
00CE6:  DATA 0D,0A
00CE8:  DATA 00,00
00CEA:  DATA 25,73
00CEC:  DATA 20,0D
00CEE:  DATA 0A,00
00CF0:  DATA 25,73
00CF2:  DATA 20,0D
00CF4:  DATA 0A,00
00CF6:  DATA 53,45
00CF8:  DATA 4E,44
00CFA:  DATA 49,4E
00CFC:  DATA 47,20
00CFE:  DATA 2E,2E
00D00:  DATA 2E,0D
00D02:  DATA 0A,00
00D04:  DATA 44,4F
00D06:  DATA 4E,45
00D08:  DATA 20,53
00D0A:  DATA 45,4E
00D0C:  DATA 44,49
00D0E:  DATA 4E,47
00D10:  DATA 20,0D
00D12:  DATA 0A,00
00D14:  DATA 53,45
00D16:  DATA 4E,44
00D18:  DATA 49,4E
00D1A:  DATA 47,20
00D1C:  DATA 2E,2E
00D1E:  DATA 2E,0D
00D20:  DATA 0A,00
00D22:  DATA 44,4F
00D24:  DATA 4E,45
00D26:  DATA 20,53
00D28:  DATA 45,4E
00D2A:  DATA 44,49
00D2C:  DATA 4E,47
00D2E:  DATA 20,0D
00D30:  DATA 0A,00
00D32:  DATA 41,78
00D34:  DATA 2E,32
00D36:  DATA 35,20
00D38:  DATA 66,72
00D3A:  DATA 61,6D
00D3C:  DATA 65,20
00D3E:  DATA 61,73
00D40:  DATA 20,68
00D42:  DATA 65,78
00D44:  DATA 3A,0D
00D46:  DATA 0A,20
00D48:  DATA 00,00
00D4A:  DATA 0D,0A
00D4C:  DATA 20,00
00D4E:  DATA 41,78
00D50:  DATA 2E,32
00D52:  DATA 35,20
00D54:  DATA 66,72
00D56:  DATA 61,6D
00D58:  DATA 65,20
00D5A:  DATA 61,73
00D5C:  DATA 20,41
00D5E:  DATA 73,63
00D60:  DATA 69,3A
00D62:  DATA 0D,0A
00D64:  DATA 20,00
00D66:  DATA 0D,0A
00D68:  DATA 20,00
00D6A:  DATA 0D,0A
00D6C:  DATA 70,72
00D6E:  DATA 69,6E
00D70:  DATA 74,69
00D72:  DATA 6E,67
00D74:  DATA 20,74
00D76:  DATA 68,65
00D78:  DATA 20,61
00D7A:  DATA 64,72
00D7C:  DATA 65,73
00D7E:  DATA 73,20
00D80:  DATA 69,6E
00D82:  DATA 20,62
00D84:  DATA 79,74
00D86:  DATA 65,20
00D88:  DATA 66,6F
00D8A:  DATA 72,6D
00D8C:  DATA 0D,0A
00D8E:  DATA 00,00
00D90:  DATA 52,65
00D92:  DATA 63,65
00D94:  DATA 69,76
00D96:  DATA 65,64
00D98:  DATA 20,54
00D9A:  DATA 4C,45
00D9C:  DATA 20,64
00D9E:  DATA 61,74
00DA0:  DATA 61,3A
00DA2:  DATA 20,00
00DA4:  DATA 0D,0A
00DA6:  DATA 20,52
00DA8:  DATA 65,63
00DAA:  DATA 65,70
00DAC:  DATA 74,69
00DAE:  DATA 6F,6E
00DB0:  DATA 20,6F
00DB2:  DATA 66,20
00DB4:  DATA 54,4C
00DB6:  DATA 45,20
00DB8:  DATA 69,73
00DBA:  DATA 20,66
00DBC:  DATA 69,6E
00DBE:  DATA 69,73
00DC0:  DATA 68,65
00DC2:  DATA 64,0D
00DC4:  DATA 0A,00
*
0176E:  BTFSC  FD8.1
01770:  BRA    177A
01772:  MOVLW  0C
01774:  MOVWF  FEA
01776:  MOVLW  67
01778:  MOVWF  FE9
0177A:  CLRF   00
0177C:  CLRF   01
0177E:  CLRF   02
01780:  CLRF   03
01782:  MOVLB  C
01784:  CLRF   x67
01786:  CLRF   x68
01788:  CLRF   x69
0178A:  CLRF   x6A
0178C:  MOVF   x66,W
0178E:  IORWF  x65,W
01790:  IORWF  x64,W
01792:  IORWF  x63,W
01794:  BZ    17EE
01796:  MOVLW  20
01798:  MOVWF  x6B
0179A:  BCF    FD8.0
0179C:  RLCF   x5F,F
0179E:  RLCF   x60,F
017A0:  RLCF   x61,F
017A2:  RLCF   x62,F
017A4:  RLCF   x67,F
017A6:  RLCF   x68,F
017A8:  RLCF   x69,F
017AA:  RLCF   x6A,F
017AC:  MOVF   x66,W
017AE:  SUBWF  x6A,W
017B0:  BNZ   17C2
017B2:  MOVF   x65,W
017B4:  SUBWF  x69,W
017B6:  BNZ   17C2
017B8:  MOVF   x64,W
017BA:  SUBWF  x68,W
017BC:  BNZ   17C2
017BE:  MOVF   x63,W
017C0:  SUBWF  x67,W
017C2:  BNC   17E2
017C4:  MOVF   x63,W
017C6:  SUBWF  x67,F
017C8:  MOVF   x64,W
017CA:  BTFSS  FD8.0
017CC:  INCFSZ x64,W
017CE:  SUBWF  x68,F
017D0:  MOVF   x65,W
017D2:  BTFSS  FD8.0
017D4:  INCFSZ x65,W
017D6:  SUBWF  x69,F
017D8:  MOVF   x66,W
017DA:  BTFSS  FD8.0
017DC:  INCFSZ x66,W
017DE:  SUBWF  x6A,F
017E0:  BSF    FD8.0
017E2:  RLCF   00,F
017E4:  RLCF   01,F
017E6:  RLCF   02,F
017E8:  RLCF   03,F
017EA:  DECFSZ x6B,F
017EC:  BRA    179A
017EE:  MOVFF  C67,FEF
017F2:  MOVFF  C68,FEC
017F6:  MOVFF  C69,FEC
017FA:  MOVFF  C6A,FEC
017FE:  MOVLB  0
01800:  RETURN 0
*
02228:  MOVLW  8E
0222A:  MOVWF  00
0222C:  MOVFF  C8B,01
02230:  MOVFF  C8A,02
02234:  CLRF   03
02236:  MOVF   01,F
02238:  BNZ   224C
0223A:  MOVFF  02,01
0223E:  CLRF   02
02240:  MOVLW  08
02242:  SUBWF  00,F
02244:  MOVF   01,F
02246:  BNZ   224C
02248:  CLRF   00
0224A:  BRA    225C
0224C:  BCF    FD8.0
0224E:  BTFSC  01.7
02250:  BRA    225A
02252:  RLCF   02,F
02254:  RLCF   01,F
02256:  DECF   00,F
02258:  BRA    224C
0225A:  BCF    01.7
0225C:  RETURN 0
0225E:  MOVFF  C87,C8E
02262:  MOVLB  C
02264:  MOVF   x8B,W
02266:  XORWF  x8E,F
02268:  BTFSS  x8E.7
0226A:  BRA    2276
0226C:  BCF    FD8.2
0226E:  BCF    FD8.0
02270:  BTFSC  x87.7
02272:  BSF    FD8.0
02274:  BRA    22D4
02276:  MOVFF  C87,C8E
0227A:  MOVFF  C8A,C8F
0227E:  MOVF   x86,W
02280:  SUBWF  x8F,F
02282:  BZ    2290
02284:  BTFSS  x8E.7
02286:  BRA    22D4
02288:  MOVF   FD8,W
0228A:  XORLW  01
0228C:  MOVWF  FD8
0228E:  BRA    22D4
02290:  MOVFF  C8B,C8F
02294:  MOVF   x87,W
02296:  SUBWF  x8F,F
02298:  BZ    22A6
0229A:  BTFSS  x8E.7
0229C:  BRA    22D4
0229E:  MOVF   FD8,W
022A0:  XORLW  01
022A2:  MOVWF  FD8
022A4:  BRA    22D4
022A6:  MOVFF  C8C,C8F
022AA:  MOVF   x88,W
022AC:  SUBWF  x8F,F
022AE:  BZ    22BC
022B0:  BTFSS  x8E.7
022B2:  BRA    22D4
022B4:  MOVF   FD8,W
022B6:  XORLW  01
022B8:  MOVWF  FD8
022BA:  BRA    22D4
022BC:  MOVFF  C8D,C8F
022C0:  MOVF   x89,W
022C2:  SUBWF  x8F,F
022C4:  BZ    22D2
022C6:  BTFSS  x8E.7
022C8:  BRA    22D4
022CA:  MOVF   FD8,W
022CC:  XORLW  01
022CE:  MOVWF  FD8
022D0:  BRA    22D4
022D2:  BCF    FD8.0
022D4:  MOVLB  0
022D6:  RETURN 0
022D8:  MOVLB  C
022DA:  MOVF   x7F,W
022DC:  BTFSC  FD8.2
022DE:  BRA    242A
022E0:  MOVWF  x8B
022E2:  MOVF   x83,W
022E4:  BTFSC  FD8.2
022E6:  BRA    242A
022E8:  SUBWF  x8B,F
022EA:  BNC   22F6
022EC:  MOVLW  7F
022EE:  ADDWF  x8B,F
022F0:  BTFSC  FD8.0
022F2:  BRA    242A
022F4:  BRA    2302
022F6:  MOVLW  81
022F8:  SUBWF  x8B,F
022FA:  BTFSS  FD8.0
022FC:  BRA    242A
022FE:  BTFSC  FD8.2
02300:  BRA    242A
02302:  MOVFF  C8B,00
02306:  CLRF   01
02308:  CLRF   02
0230A:  CLRF   03
0230C:  CLRF   x8A
0230E:  MOVFF  C80,C89
02312:  BSF    x89.7
02314:  MOVFF  C81,C88
02318:  MOVFF  C82,C87
0231C:  MOVLW  19
0231E:  MOVWF  x8B
02320:  MOVF   x86,W
02322:  SUBWF  x87,F
02324:  BC    2340
02326:  MOVLW  01
02328:  SUBWF  x88,F
0232A:  BC    2340
0232C:  SUBWF  x89,F
0232E:  BC    2340
02330:  SUBWF  x8A,F
02332:  BC    2340
02334:  INCF   x8A,F
02336:  INCF   x89,F
02338:  INCF   x88,F
0233A:  MOVF   x86,W
0233C:  ADDWF  x87,F
0233E:  BRA    2390
02340:  MOVF   x85,W
02342:  SUBWF  x88,F
02344:  BC    236A
02346:  MOVLW  01
02348:  SUBWF  x89,F
0234A:  BC    236A
0234C:  SUBWF  x8A,F
0234E:  BC    236A
02350:  INCF   x8A,F
02352:  INCF   x89,F
02354:  MOVF   x85,W
02356:  ADDWF  x88,F
02358:  MOVF   x86,W
0235A:  ADDWF  x87,F
0235C:  BNC   2390
0235E:  INCF   x88,F
02360:  BNZ   2390
02362:  INCF   x89,F
02364:  BNZ   2390
02366:  INCF   x8A,F
02368:  BRA    2390
0236A:  MOVF   x84,W
0236C:  IORLW  80
0236E:  SUBWF  x89,F
02370:  BC    238E
02372:  MOVLW  01
02374:  SUBWF  x8A,F
02376:  BC    238E
02378:  INCF   x8A,F
0237A:  MOVF   x84,W
0237C:  IORLW  80
0237E:  ADDWF  x89,F
02380:  MOVF   x85,W
02382:  ADDWF  x88,F
02384:  BNC   2358
02386:  INCF   x89,F
02388:  BNZ   2358
0238A:  INCF   x8A,F
0238C:  BRA    2358
0238E:  BSF    03.0
02390:  DECFSZ x8B,F
02392:  BRA    2396
02394:  BRA    23AC
02396:  BCF    FD8.0
02398:  RLCF   x87,F
0239A:  RLCF   x88,F
0239C:  RLCF   x89,F
0239E:  RLCF   x8A,F
023A0:  BCF    FD8.0
023A2:  RLCF   03,F
023A4:  RLCF   02,F
023A6:  RLCF   01,F
023A8:  RLCF   x8C,F
023AA:  BRA    2320
023AC:  BTFSS  x8C.0
023AE:  BRA    23BC
023B0:  BCF    FD8.0
023B2:  RRCF   01,F
023B4:  RRCF   02,F
023B6:  RRCF   03,F
023B8:  RRCF   x8C,F
023BA:  BRA    23C0
023BC:  DECF   00,F
023BE:  BZ    242A
023C0:  BTFSC  x8C.7
023C2:  BRA    2400
023C4:  BCF    FD8.0
023C6:  RLCF   x87,F
023C8:  RLCF   x88,F
023CA:  RLCF   x89,F
023CC:  RLCF   x8A,F
023CE:  MOVF   x86,W
023D0:  SUBWF  x87,F
023D2:  BC    23E2
023D4:  MOVLW  01
023D6:  SUBWF  x88,F
023D8:  BC    23E2
023DA:  SUBWF  x89,F
023DC:  BC    23E2
023DE:  SUBWF  x8A,F
023E0:  BNC   2416
023E2:  MOVF   x85,W
023E4:  SUBWF  x88,F
023E6:  BC    23F2
023E8:  MOVLW  01
023EA:  SUBWF  x89,F
023EC:  BC    23F2
023EE:  SUBWF  x8A,F
023F0:  BNC   2416
023F2:  MOVF   x84,W
023F4:  IORLW  80
023F6:  SUBWF  x89,F
023F8:  BC    2400
023FA:  MOVLW  01
023FC:  SUBWF  x8A,F
023FE:  BNC   2416
02400:  INCF   03,F
02402:  BNZ   2416
02404:  INCF   02,F
02406:  BNZ   2416
02408:  INCF   01,F
0240A:  BNZ   2416
0240C:  INCF   00,F
0240E:  BZ    242A
02410:  RRCF   01,F
02412:  RRCF   02,F
02414:  RRCF   03,F
02416:  MOVFF  C80,C8B
0241A:  MOVF   x84,W
0241C:  XORWF  x8B,F
0241E:  BTFSS  x8B.7
02420:  BRA    2426
02422:  BSF    01.7
02424:  BRA    2432
02426:  BCF    01.7
02428:  BRA    2432
0242A:  CLRF   00
0242C:  CLRF   01
0242E:  CLRF   02
02430:  CLRF   03
02432:  MOVLB  0
02434:  RETURN 0
02436:  MOVLW  8E
02438:  MOVWF  00
0243A:  MOVLB  C
0243C:  MOVF   x86,W
0243E:  SUBWF  00,F
02440:  MOVFF  C87,02
02444:  MOVFF  C88,01
02448:  BSF    02.7
0244A:  MOVF   00,F
0244C:  BZ    2460
0244E:  BCF    FD8.0
02450:  MOVF   02,F
02452:  BNZ   2458
02454:  MOVF   01,F
02456:  BZ    2460
02458:  RRCF   02,F
0245A:  RRCF   01,F
0245C:  DECFSZ 00,F
0245E:  BRA    244E
02460:  BTFSS  x87.7
02462:  BRA    246E
02464:  COMF   01,F
02466:  COMF   02,F
02468:  INCF   01,F
0246A:  BTFSC  FD8.2
0246C:  INCF   02,F
0246E:  MOVLB  0
02470:  RETURN 0
02472:  MOVLB  C
02474:  MOVF   x86,W
02476:  BTFSC  FD8.2
02478:  BRA    255C
0247A:  MOVWF  00
0247C:  MOVF   x8A,W
0247E:  BTFSC  FD8.2
02480:  BRA    255C
02482:  ADDWF  00,F
02484:  BNC   248E
02486:  MOVLW  81
02488:  ADDWF  00,F
0248A:  BC    255C
0248C:  BRA    2496
0248E:  MOVLW  7F
02490:  SUBWF  00,F
02492:  BNC   255C
02494:  BZ    255C
02496:  MOVFF  C87,C8E
0249A:  MOVF   x8B,W
0249C:  XORWF  x8E,F
0249E:  BSF    x87.7
024A0:  BSF    x8B.7
024A2:  MOVF   x89,W
024A4:  MULWF  x8D
024A6:  MOVFF  FF4,C90
024AA:  MOVF   x88,W
024AC:  MULWF  x8C
024AE:  MOVFF  FF4,03
024B2:  MOVFF  FF3,C8F
024B6:  MULWF  x8D
024B8:  MOVF   FF3,W
024BA:  ADDWF  x90,F
024BC:  MOVF   FF4,W
024BE:  ADDWFC x8F,F
024C0:  MOVLW  00
024C2:  ADDWFC 03,F
024C4:  MOVF   x89,W
024C6:  MULWF  x8C
024C8:  MOVF   FF3,W
024CA:  ADDWF  x90,F
024CC:  MOVF   FF4,W
024CE:  ADDWFC x8F,F
024D0:  MOVLW  00
024D2:  CLRF   02
024D4:  ADDWFC 03,F
024D6:  ADDWFC 02,F
024D8:  MOVF   x87,W
024DA:  MULWF  x8D
024DC:  MOVF   FF3,W
024DE:  ADDWF  x8F,F
024E0:  MOVF   FF4,W
024E2:  ADDWFC 03,F
024E4:  MOVLW  00
024E6:  ADDWFC 02,F
024E8:  MOVF   x87,W
024EA:  MULWF  x8C
024EC:  MOVF   FF3,W
024EE:  ADDWF  03,F
024F0:  MOVF   FF4,W
024F2:  ADDWFC 02,F
024F4:  MOVLW  00
024F6:  CLRF   01
024F8:  ADDWFC 01,F
024FA:  MOVF   x89,W
024FC:  MULWF  x8B
024FE:  MOVF   FF3,W
02500:  ADDWF  x8F,F
02502:  MOVF   FF4,W
02504:  ADDWFC 03,F
02506:  MOVLW  00
02508:  ADDWFC 02,F
0250A:  ADDWFC 01,F
0250C:  MOVF   x88,W
0250E:  MULWF  x8B
02510:  MOVF   FF3,W
02512:  ADDWF  03,F
02514:  MOVF   FF4,W
02516:  ADDWFC 02,F
02518:  MOVLW  00
0251A:  ADDWFC 01,F
0251C:  MOVF   x87,W
0251E:  MULWF  x8B
02520:  MOVF   FF3,W
02522:  ADDWF  02,F
02524:  MOVF   FF4,W
02526:  ADDWFC 01,F
02528:  INCF   00,F
0252A:  BTFSC  01.7
0252C:  BRA    2538
0252E:  RLCF   x8F,F
02530:  RLCF   03,F
02532:  RLCF   02,F
02534:  RLCF   01,F
02536:  DECF   00,F
02538:  MOVLW  00
0253A:  BTFSS  x8F.7
0253C:  BRA    2552
0253E:  INCF   03,F
02540:  ADDWFC 02,F
02542:  ADDWFC 01,F
02544:  MOVF   01,W
02546:  BNZ   2552
02548:  MOVF   02,W
0254A:  BNZ   2552
0254C:  MOVF   03,W
0254E:  BNZ   2552
02550:  INCF   00,F
02552:  BTFSC  x8E.7
02554:  BSF    01.7
02556:  BTFSS  x8E.7
02558:  BCF    01.7
0255A:  BRA    2564
0255C:  CLRF   00
0255E:  CLRF   01
02560:  CLRF   02
02562:  CLRF   03
02564:  MOVLB  0
02566:  RETURN 0
02568:  MOVLW  80
0256A:  BTFSS  FD8.1
0256C:  BRA    2572
0256E:  MOVLB  C
02570:  XORWF  x8F,F
02572:  MOVLB  C
02574:  CLRF   x94
02576:  CLRF   x95
02578:  MOVFF  C8B,C93
0257C:  MOVF   x8F,W
0257E:  XORWF  x93,F
02580:  MOVF   x8A,W
02582:  BTFSC  FD8.2
02584:  BRA    2744
02586:  MOVWF  x92
02588:  MOVWF  00
0258A:  MOVF   x8E,W
0258C:  BTFSC  FD8.2
0258E:  BRA    2756
02590:  SUBWF  x92,F
02592:  BTFSC  FD8.2
02594:  BRA    269C
02596:  BNC   2614
02598:  MOVFF  C8F,C98
0259C:  BSF    x98.7
0259E:  MOVFF  C90,C97
025A2:  MOVFF  C91,C96
025A6:  CLRF   x95
025A8:  BCF    FD8.0
025AA:  RRCF   x98,F
025AC:  RRCF   x97,F
025AE:  RRCF   x96,F
025B0:  RRCF   x95,F
025B2:  DECFSZ x92,F
025B4:  BRA    25A6
025B6:  BTFSS  x93.7
025B8:  BRA    25C0
025BA:  BSF    x94.0
025BC:  BRA    277E
025BE:  BCF    x94.0
025C0:  BCF    x92.0
025C2:  BSF    x94.4
025C4:  MOVLW  0C
025C6:  MOVWF  FEA
025C8:  MOVLW  8D
025CA:  MOVWF  FE9
025CC:  BRA    27A4
025CE:  BCF    x94.4
025D0:  BTFSC  x93.7
025D2:  BRA    25E8
025D4:  BTFSS  x92.0
025D6:  BRA    25FE
025D8:  RRCF   x98,F
025DA:  RRCF   x97,F
025DC:  RRCF   x96,F
025DE:  RRCF   x95,F
025E0:  INCF   00,F
025E2:  BTFSC  FD8.2
025E4:  BRA    2774
025E6:  BRA    25FE
025E8:  BTFSC  x98.7
025EA:  BRA    2604
025EC:  BCF    FD8.0
025EE:  RLCF   x95,F
025F0:  RLCF   x96,F
025F2:  RLCF   x97,F
025F4:  RLCF   x98,F
025F6:  DECF   00,F
025F8:  BTFSC  FD8.2
025FA:  BRA    2774
025FC:  BRA    25E8
025FE:  BSF    x94.6
02600:  BRA    26DC
02602:  BCF    x94.6
02604:  MOVFF  C8B,C93
02608:  BTFSS  x8B.7
0260A:  BRA    2610
0260C:  BSF    x98.7
0260E:  BRA    2766
02610:  BCF    x98.7
02612:  BRA    2766
02614:  MOVFF  C8E,C92
02618:  MOVFF  C8E,00
0261C:  MOVF   x8A,W
0261E:  SUBWF  x92,F
02620:  MOVFF  C8B,C98
02624:  BSF    x98.7
02626:  MOVFF  C8C,C97
0262A:  MOVFF  C8D,C96
0262E:  CLRF   x95
02630:  BCF    FD8.0
02632:  RRCF   x98,F
02634:  RRCF   x97,F
02636:  RRCF   x96,F
02638:  RRCF   x95,F
0263A:  DECFSZ x92,F
0263C:  BRA    262E
0263E:  BTFSS  x93.7
02640:  BRA    2648
02642:  BSF    x94.1
02644:  BRA    277E
02646:  BCF    x94.1
02648:  BCF    x92.0
0264A:  BSF    x94.5
0264C:  MOVLW  0C
0264E:  MOVWF  FEA
02650:  MOVLW  91
02652:  MOVWF  FE9
02654:  BRA    27A4
02656:  BCF    x94.5
02658:  BTFSC  x93.7
0265A:  BRA    2670
0265C:  BTFSS  x92.0
0265E:  BRA    2686
02660:  RRCF   x98,F
02662:  RRCF   x97,F
02664:  RRCF   x96,F
02666:  RRCF   x95,F
02668:  INCF   00,F
0266A:  BTFSC  FD8.2
0266C:  BRA    2774
0266E:  BRA    2686
02670:  BTFSC  x98.7
02672:  BRA    268C
02674:  BCF    FD8.0
02676:  RLCF   x95,F
02678:  RLCF   x96,F
0267A:  RLCF   x97,F
0267C:  RLCF   x98,F
0267E:  DECF   00,F
02680:  BTFSC  FD8.2
02682:  BRA    2774
02684:  BRA    2670
02686:  BSF    x94.7
02688:  BRA    26DC
0268A:  BCF    x94.7
0268C:  MOVFF  C8F,C93
02690:  BTFSS  x8F.7
02692:  BRA    2698
02694:  BSF    x98.7
02696:  BRA    2766
02698:  BCF    x98.7
0269A:  BRA    2766
0269C:  MOVFF  C8F,C98
026A0:  BSF    x98.7
026A2:  MOVFF  C90,C97
026A6:  MOVFF  C91,C96
026AA:  BTFSS  x93.7
026AC:  BRA    26B6
026AE:  BCF    x98.7
026B0:  BSF    x94.2
026B2:  BRA    277E
026B4:  BCF    x94.2
026B6:  CLRF   x95
026B8:  BCF    x92.0
026BA:  MOVLW  0C
026BC:  MOVWF  FEA
026BE:  MOVLW  8D
026C0:  MOVWF  FE9
026C2:  BRA    27A4
026C4:  BTFSC  x93.7
026C6:  BRA    2700
026C8:  MOVFF  C8B,C93
026CC:  BTFSS  x92.0
026CE:  BRA    26DC
026D0:  RRCF   x98,F
026D2:  RRCF   x97,F
026D4:  RRCF   x96,F
026D6:  RRCF   x95,F
026D8:  INCF   00,F
026DA:  BZ    2774
026DC:  BTFSS  x95.7
026DE:  BRA    26F6
026E0:  INCF   x96,F
026E2:  BNZ   26F6
026E4:  INCF   x97,F
026E6:  BNZ   26F6
026E8:  INCF   x98,F
026EA:  BNZ   26F6
026EC:  RRCF   x98,F
026EE:  RRCF   x97,F
026F0:  RRCF   x96,F
026F2:  INCF   00,F
026F4:  BZ    2774
026F6:  BTFSC  x94.6
026F8:  BRA    2602
026FA:  BTFSC  x94.7
026FC:  BRA    268A
026FE:  BRA    2738
02700:  MOVLW  80
02702:  XORWF  x98,F
02704:  BTFSS  x98.7
02706:  BRA    2710
02708:  BRA    277E
0270A:  MOVFF  C8F,C93
0270E:  BRA    2724
02710:  MOVFF  C8B,C93
02714:  MOVF   x98,F
02716:  BNZ   2724
02718:  MOVF   x97,F
0271A:  BNZ   2724
0271C:  MOVF   x96,F
0271E:  BNZ   2724
02720:  CLRF   00
02722:  BRA    2766
02724:  BTFSC  x98.7
02726:  BRA    2738
02728:  BCF    FD8.0
0272A:  RLCF   x95,F
0272C:  RLCF   x96,F
0272E:  RLCF   x97,F
02730:  RLCF   x98,F
02732:  DECFSZ 00,F
02734:  BRA    2724
02736:  BRA    2774
02738:  BTFSS  x93.7
0273A:  BRA    2740
0273C:  BSF    x98.7
0273E:  BRA    2766
02740:  BCF    x98.7
02742:  BRA    2766
02744:  MOVFF  C8E,00
02748:  MOVFF  C8F,C98
0274C:  MOVFF  C90,C97
02750:  MOVFF  C91,C96
02754:  BRA    2766
02756:  MOVFF  C8A,00
0275A:  MOVFF  C8B,C98
0275E:  MOVFF  C8C,C97
02762:  MOVFF  C8D,C96
02766:  MOVFF  C98,01
0276A:  MOVFF  C97,02
0276E:  MOVFF  C96,03
02772:  BRA    27DC
02774:  CLRF   00
02776:  CLRF   01
02778:  CLRF   02
0277A:  CLRF   03
0277C:  BRA    27DC
0277E:  CLRF   x95
02780:  COMF   x96,F
02782:  COMF   x97,F
02784:  COMF   x98,F
02786:  COMF   x95,F
02788:  INCF   x95,F
0278A:  BNZ   2796
0278C:  INCF   x96,F
0278E:  BNZ   2796
02790:  INCF   x97,F
02792:  BNZ   2796
02794:  INCF   x98,F
02796:  BTFSC  x94.0
02798:  BRA    25BE
0279A:  BTFSC  x94.1
0279C:  BRA    2646
0279E:  BTFSC  x94.2
027A0:  BRA    26B4
027A2:  BRA    270A
027A4:  MOVF   FEF,W
027A6:  ADDWF  x96,F
027A8:  BNC   27B4
027AA:  INCF   x97,F
027AC:  BNZ   27B4
027AE:  INCF   x98,F
027B0:  BTFSC  FD8.2
027B2:  BSF    x92.0
027B4:  MOVF   FED,F
027B6:  MOVF   FEF,W
027B8:  ADDWF  x97,F
027BA:  BNC   27C2
027BC:  INCF   x98,F
027BE:  BTFSC  FD8.2
027C0:  BSF    x92.0
027C2:  MOVF   FED,F
027C4:  MOVF   FEF,W
027C6:  BTFSC  FEF.7
027C8:  BRA    27CC
027CA:  XORLW  80
027CC:  ADDWF  x98,F
027CE:  BTFSC  FD8.0
027D0:  BSF    x92.0
027D2:  BTFSC  x94.4
027D4:  BRA    25CE
027D6:  BTFSC  x94.5
027D8:  BRA    2656
027DA:  BRA    26C4
027DC:  MOVLB  0
027DE:  RETURN 0
*
02CCC:  MOVLW  8E
02CCE:  MOVWF  00
02CD0:  MOVFF  C7D,01
02CD4:  MOVFF  C7C,02
02CD8:  CLRF   03
02CDA:  BTFSS  01.7
02CDC:  BRA    2CE8
02CDE:  COMF   01,F
02CE0:  COMF   02,F
02CE2:  INCF   02,F
02CE4:  BNZ   2CE8
02CE6:  INCF   01,F
02CE8:  MOVF   01,F
02CEA:  BNZ   2CFE
02CEC:  MOVFF  02,01
02CF0:  CLRF   02
02CF2:  MOVLW  08
02CF4:  SUBWF  00,F
02CF6:  MOVF   01,F
02CF8:  BNZ   2CFE
02CFA:  CLRF   00
02CFC:  BRA    2D1A
02CFE:  BCF    FD8.0
02D00:  BTFSC  01.7
02D02:  BRA    2D0C
02D04:  RLCF   02,F
02D06:  RLCF   01,F
02D08:  DECF   00,F
02D0A:  BRA    2CFE
02D0C:  MOVLB  C
02D0E:  BTFSS  x7D.7
02D10:  BRA    2D16
02D12:  MOVLB  0
02D14:  BRA    2D1A
02D16:  BCF    01.7
02D18:  MOVLB  0
02D1A:  RETURN 0
*
037C4:  MOVLB  C
037C6:  MOVF   x6B,W
037C8:  MULWF  x6D
037CA:  MOVFF  FF3,01
037CE:  MOVFF  FF4,00
037D2:  MULWF  x6E
037D4:  MOVF   FF3,W
037D6:  ADDWF  00,F
037D8:  MOVF   x6C,W
037DA:  MULWF  x6D
037DC:  MOVF   FF3,W
037DE:  ADDWFC 00,W
037E0:  MOVWF  02
037E2:  MOVLB  0
037E4:  RETURN 0
*
04EE4:  MOVFF  FEA,C62
04EE8:  MOVFF  FE9,C61
04EEC:  MOVLB  C
04EEE:  SWAPF  x5B,W
04EF0:  IORLW  F0
04EF2:  MOVWF  x5D
04EF4:  ADDWF  x5D,F
04EF6:  ADDLW  E2
04EF8:  MOVWF  x5E
04EFA:  ADDLW  32
04EFC:  MOVWF  x60
04EFE:  MOVF   x5B,W
04F00:  ANDLW  0F
04F02:  ADDWF  x5E,F
04F04:  ADDWF  x5E,F
04F06:  ADDWF  x60,F
04F08:  ADDLW  E9
04F0A:  MOVWF  x5F
04F0C:  ADDWF  x5F,F
04F0E:  ADDWF  x5F,F
04F10:  SWAPF  x5A,W
04F12:  ANDLW  0F
04F14:  ADDWF  x5F,F
04F16:  ADDWF  x60,F
04F18:  RLCF   x5F,F
04F1A:  RLCF   x60,F
04F1C:  COMF   x60,F
04F1E:  RLCF   x60,F
04F20:  MOVF   x5A,W
04F22:  ANDLW  0F
04F24:  ADDWF  x60,F
04F26:  RLCF   x5D,F
04F28:  MOVLW  07
04F2A:  MOVWF  x5C
04F2C:  MOVLW  0A
04F2E:  DECF   x5F,F
04F30:  ADDWF  x60,F
04F32:  BNC   4F2E
04F34:  DECF   x5E,F
04F36:  ADDWF  x5F,F
04F38:  BNC   4F34
04F3A:  DECF   x5D,F
04F3C:  ADDWF  x5E,F
04F3E:  BNC   4F3A
04F40:  DECF   x5C,F
04F42:  ADDWF  x5D,F
04F44:  BNC   4F40
04F46:  MOVLW  0C
04F48:  MOVWF  FEA
04F4A:  MOVLW  5C
04F4C:  MOVWF  FE9
04F4E:  MOVLW  07
04F50:  ANDWF  x61,W
04F52:  BCF    x61.6
04F54:  ADDWF  FE9,F
04F56:  MOVLW  00
04F58:  ADDWFC FEA,F
04F5A:  MOVF   FE9,W
04F5C:  SUBLW  60
04F5E:  BNZ   4F68
04F60:  MOVF   FEA,W
04F62:  SUBLW  0C
04F64:  BNZ   4F68
04F66:  BSF    x61.6
04F68:  MOVF   FEF,W
04F6A:  MOVWF  00
04F6C:  BNZ   4F7E
04F6E:  BTFSC  x61.6
04F70:  BRA    4F7E
04F72:  BTFSC  x61.4
04F74:  BRA    4FAE
04F76:  BTFSC  x61.3
04F78:  BRA    4F7E
04F7A:  MOVLW  20
04F7C:  BRA    4F84
04F7E:  BSF    x61.3
04F80:  BCF    x61.4
04F82:  MOVLW  30
04F84:  ADDWF  00,F
04F86:  MOVFF  FEA,C5B
04F8A:  MOVFF  FE9,C5A
04F8E:  CLRF   1B
04F90:  BTFSC  FF2.7
04F92:  BSF    1B.7
04F94:  BCF    FF2.7
04F96:  MOVFF  00,C9E
04F9A:  MOVLB  0
04F9C:  CALL   054A
04FA0:  BTFSC  1B.7
04FA2:  BSF    FF2.7
04FA4:  MOVFF  C5B,FEA
04FA8:  MOVFF  C5A,FE9
04FAC:  MOVLB  C
04FAE:  MOVF   FEE,W
04FB0:  BTFSS  x61.6
04FB2:  BRA    4F5A
04FB4:  MOVLB  0
04FB6:  GOTO   5156 (RETURN)
*
0517E:  MOVLB  C
05180:  CLRF   x5B
05182:  CLRF   x5C
05184:  MOVLW  01
05186:  MOVWF  x5D
05188:  CLRF   FDA
0518A:  CLRF   FD9
0518C:  MOVLW  0C
0518E:  MOVWF  x60
05190:  MOVLW  53
05192:  MOVWF  x5F
05194:  MOVLW  0C
05196:  MOVWF  FEA
05198:  MOVLW  57
0519A:  MOVWF  FE9
0519C:  MOVFF  C60,FE2
051A0:  MOVFF  C5F,FE1
051A4:  MOVFF  C5D,C5E
051A8:  BCF    FD8.0
051AA:  MOVF   FE5,W
051AC:  MULWF  FEE
051AE:  MOVF   FF3,W
051B0:  ADDWFC x5B,F
051B2:  MOVF   FF4,W
051B4:  ADDWFC x5C,F
051B6:  DECFSZ x5E,F
051B8:  BRA    51A8
051BA:  MOVFF  C5B,FDE
051BE:  MOVFF  C5C,C5B
051C2:  CLRF   x5C
051C4:  BTFSC  FD8.0
051C6:  INCF   x5C,F
051C8:  INCF   x5F,F
051CA:  BTFSC  FD8.2
051CC:  INCF   x60,F
051CE:  INCF   x5D,F
051D0:  MOVF   x5D,W
051D2:  SUBLW  05
051D4:  BNZ   5194
051D6:  MOVLB  0
051D8:  GOTO   56EA (RETURN)
*
055E8:  MOVF   FE9,W
055EA:  MOVLB  C
055EC:  MOVWF  x57
055EE:  MOVLW  3B
055F0:  MOVWF  x5E
055F2:  MOVLW  9A
055F4:  MOVWF  x5D
055F6:  MOVLW  CA
055F8:  MOVWF  x5C
055FA:  CLRF   x5B
055FC:  MOVLW  0A
055FE:  MOVWF  x59
05600:  BSF    FD8.1
05602:  MOVLW  0C
05604:  MOVWF  FEA
05606:  MOVLW  53
05608:  MOVWF  FE9
0560A:  MOVFF  C56,C62
0560E:  MOVFF  C55,C61
05612:  MOVFF  C54,C60
05616:  MOVFF  C53,C5F
0561A:  MOVFF  C5E,C66
0561E:  MOVFF  C5D,C65
05622:  MOVFF  C5C,C64
05626:  MOVFF  C5B,C63
0562A:  MOVLB  0
0562C:  CALL   176E
05630:  MOVF   01,W
05632:  MOVF   00,F
05634:  BNZ   565C
05636:  MOVLB  C
05638:  MOVF   x59,W
0563A:  XORLW  01
0563C:  BTFSS  FD8.2
0563E:  BRA    5644
05640:  MOVLB  0
05642:  BRA    565C
05644:  MOVF   x57,W
05646:  BZ    5660
05648:  ANDLW  0F
0564A:  SUBWF  x59,W
0564C:  BZ    5650
0564E:  BC    567C
05650:  BTFSC  x57.7
05652:  BRA    567C
05654:  BTFSC  x57.6
05656:  BRA    5660
05658:  MOVLW  20
0565A:  BRA    5662
0565C:  MOVLB  C
0565E:  CLRF   x57
05660:  MOVLW  30
05662:  ADDWF  00,F
05664:  CLRF   1B
05666:  BTFSC  FF2.7
05668:  BSF    1B.7
0566A:  BCF    FF2.7
0566C:  MOVFF  00,C9E
05670:  MOVLB  0
05672:  CALL   054A
05676:  BTFSC  1B.7
05678:  BSF    FF2.7
0567A:  MOVLB  C
0567C:  BCF    FD8.1
0567E:  MOVFF  C5E,C62
05682:  MOVFF  C5D,C61
05686:  MOVFF  C5C,C60
0568A:  MOVFF  C5B,C5F
0568E:  CLRF   x66
05690:  CLRF   x65
05692:  CLRF   x64
05694:  MOVLW  0A
05696:  MOVWF  x63
05698:  MOVLB  0
0569A:  CALL   176E
0569E:  MOVFF  03,C5E
056A2:  MOVFF  02,C5D
056A6:  MOVFF  01,C5C
056AA:  MOVFF  00,C5B
056AE:  MOVLB  C
056B0:  DECFSZ x59,F
056B2:  BRA    5600
056B4:  MOVLB  0
056B6:  GOTO   5752 (RETURN)
*
05974:  MOVFF  20,FEA
05978:  MOVFF  1F,FE9
0597C:  MOVLB  C
0597E:  MOVFF  C67,FEF
05982:  INCF   FE9,F
05984:  BTFSC  FD8.2
05986:  INCF   FEA,F
05988:  CLRF   FEF
0598A:  INCF   1F,F
0598C:  BTFSC  FD8.2
0598E:  INCF   20,F
05990:  MOVLB  0
05992:  RETURN 0
05994:  MOVLB  C
05996:  BTFSC  x51.7
05998:  BRA    59BC
0599A:  MOVLW  0F
0599C:  MOVWF  00
0599E:  SWAPF  x50,W
059A0:  ANDWF  00,F
059A2:  MOVLW  0A
059A4:  SUBWF  00,W
059A6:  BC    59AE
059A8:  MOVLW  30
059AA:  ADDWF  00,F
059AC:  BRA    59B2
059AE:  MOVF   x51,W
059B0:  ADDWF  00,F
059B2:  MOVFF  00,C67
059B6:  MOVLB  0
059B8:  RCALL  5974
059BA:  MOVLB  C
059BC:  MOVLW  0F
059BE:  ANDWF  x50,F
059C0:  MOVLW  0A
059C2:  SUBWF  x50,W
059C4:  BC    59CA
059C6:  MOVLW  30
059C8:  BRA    59CE
059CA:  BCF    x51.7
059CC:  MOVF   x51,W
059CE:  ADDWF  x50,F
059D0:  MOVFF  C50,C67
059D4:  MOVLB  0
059D6:  RCALL  5974
059D8:  RETURN 0
*
05A4E:  MOVF   FEF,F
05A50:  BZ    5A7E
05A52:  MOVFF  FEA,C59
05A56:  MOVFF  FE9,C58
05A5A:  CLRF   1B
05A5C:  BTFSC  FF2.7
05A5E:  BSF    1B.7
05A60:  BCF    FF2.7
05A62:  MOVFF  FEF,C9E
05A66:  CALL   054A
05A6A:  BTFSC  1B.7
05A6C:  BSF    FF2.7
05A6E:  MOVFF  C59,FEA
05A72:  MOVFF  C58,FE9
05A76:  INCF   FE9,F
05A78:  BTFSC  FD8.2
05A7A:  INCF   FEA,F
05A7C:  BRA    5A4E
05A7E:  RETURN 0
*
05A8C:  MOVF   01,W
05A8E:  CLRF   1B
05A90:  BTFSC  FF2.7
05A92:  BSF    1B.7
05A94:  BCF    FF2.7
05A96:  MOVFF  C65,C9C
05A9A:  MOVLW  64
05A9C:  MOVLB  C
05A9E:  MOVWF  x9D
05AA0:  MOVLB  0
05AA2:  CALL   062E
05AA6:  BTFSC  1B.7
05AA8:  BSF    FF2.7
05AAA:  MOVFF  00,C65
05AAE:  MOVF   01,W
05AB0:  MOVLW  30
05AB2:  BNZ   5AC4
05AB4:  MOVLB  C
05AB6:  BTFSS  x66.1
05AB8:  BRA    5AD8
05ABA:  BTFSC  x66.3
05ABC:  BRA    5AD8
05ABE:  BTFSC  x66.4
05AC0:  MOVLW  20
05AC2:  BRA    5ACC
05AC4:  MOVLB  C
05AC6:  BCF    x66.3
05AC8:  BCF    x66.4
05ACA:  BSF    x66.0
05ACC:  ADDWF  01,F
05ACE:  MOVFF  01,C67
05AD2:  MOVLB  0
05AD4:  RCALL  5974
05AD6:  MOVLB  C
05AD8:  CLRF   1B
05ADA:  BTFSC  FF2.7
05ADC:  BSF    1B.7
05ADE:  BCF    FF2.7
05AE0:  MOVFF  C65,C9C
05AE4:  MOVLW  0A
05AE6:  MOVWF  x9D
05AE8:  MOVLB  0
05AEA:  CALL   062E
05AEE:  BTFSC  1B.7
05AF0:  BSF    FF2.7
05AF2:  MOVFF  00,C65
05AF6:  MOVF   01,W
05AF8:  MOVLW  30
05AFA:  BNZ   5B0C
05AFC:  MOVLB  C
05AFE:  BTFSC  x66.3
05B00:  BRA    5B16
05B02:  BTFSS  x66.0
05B04:  BRA    5B16
05B06:  BTFSC  x66.4
05B08:  MOVLW  20
05B0A:  MOVLB  0
05B0C:  ADDWF  01,F
05B0E:  MOVFF  01,C67
05B12:  RCALL  5974
05B14:  MOVLB  C
05B16:  MOVLW  30
05B18:  ADDWF  x65,F
05B1A:  MOVFF  C65,C67
05B1E:  MOVLB  0
05B20:  RCALL  5974
05B22:  GOTO   5CDA (RETURN)
*
05F36:  MOVFF  FEA,C62
05F3A:  MOVFF  FE9,C61
05F3E:  MOVLB  C
05F40:  BTFSS  x5B.7
05F42:  BRA    5F54
05F44:  BSF    x61.7
05F46:  BTFSS  x61.4
05F48:  INCF   x61,F
05F4A:  COMF   x5A,F
05F4C:  COMF   x5B,F
05F4E:  INCF   x5A,F
05F50:  BTFSC  FD8.2
05F52:  INCF   x5B,F
05F54:  SWAPF  x5B,W
05F56:  IORLW  F0
05F58:  MOVWF  x5D
05F5A:  ADDWF  x5D,F
05F5C:  ADDLW  E2
05F5E:  MOVWF  x5E
05F60:  ADDLW  32
05F62:  MOVWF  x60
05F64:  MOVF   x5B,W
05F66:  ANDLW  0F
05F68:  ADDWF  x5E,F
05F6A:  ADDWF  x5E,F
05F6C:  ADDWF  x60,F
05F6E:  ADDLW  E9
05F70:  MOVWF  x5F
05F72:  ADDWF  x5F,F
05F74:  ADDWF  x5F,F
05F76:  SWAPF  x5A,W
05F78:  ANDLW  0F
05F7A:  ADDWF  x5F,F
05F7C:  ADDWF  x60,F
05F7E:  RLCF   x5F,F
05F80:  RLCF   x60,F
05F82:  COMF   x60,F
05F84:  RLCF   x60,F
05F86:  MOVF   x5A,W
05F88:  ANDLW  0F
05F8A:  ADDWF  x60,F
05F8C:  RLCF   x5D,F
05F8E:  MOVLW  07
05F90:  MOVWF  x5C
05F92:  MOVLW  0A
05F94:  DECF   x5F,F
05F96:  ADDWF  x60,F
05F98:  BNC   5F94
05F9A:  DECF   x5E,F
05F9C:  ADDWF  x5F,F
05F9E:  BNC   5F9A
05FA0:  DECF   x5D,F
05FA2:  ADDWF  x5E,F
05FA4:  BNC   5FA0
05FA6:  DECF   x5C,F
05FA8:  ADDWF  x5D,F
05FAA:  BNC   5FA6
05FAC:  MOVLW  0C
05FAE:  MOVWF  FEA
05FB0:  MOVLW  5C
05FB2:  MOVWF  FE9
05FB4:  MOVLW  07
05FB6:  ANDWF  x61,W
05FB8:  BCF    x61.6
05FBA:  MOVF   FED,F
05FBC:  ANDWF  x61,W
05FBE:  BNZ   5FCE
05FC0:  BTFSC  x61.4
05FC2:  MOVF   FEE,F
05FC4:  BTFSC  x61.4
05FC6:  BRA    5FCE
05FC8:  MOVLW  20
05FCA:  MOVWF  00
05FCC:  BRA    6010
05FCE:  ADDWF  FE9,F
05FD0:  MOVLW  00
05FD2:  ADDWFC FEA,F
05FD4:  MOVF   FE9,W
05FD6:  SUBLW  60
05FD8:  BNZ   5FE2
05FDA:  MOVF   FEA,W
05FDC:  SUBLW  0C
05FDE:  BNZ   5FE2
05FE0:  BSF    x61.6
05FE2:  MOVF   FEF,W
05FE4:  MOVWF  00
05FE6:  BNZ   5FF8
05FE8:  BTFSC  x61.6
05FEA:  BRA    5FF8
05FEC:  BTFSC  x61.4
05FEE:  BRA    6038
05FF0:  BTFSC  x61.3
05FF2:  BRA    5FF8
05FF4:  MOVLW  20
05FF6:  BRA    600E
05FF8:  BTFSS  x61.7
05FFA:  BRA    6008
05FFC:  MOVLW  2D
05FFE:  MOVWF  00
06000:  MOVF   FED,W
06002:  BCF    x61.6
06004:  BCF    x61.7
06006:  BRA    6010
06008:  BSF    x61.3
0600A:  BCF    x61.4
0600C:  MOVLW  30
0600E:  ADDWF  00,F
06010:  MOVFF  FEA,C5B
06014:  MOVFF  FE9,C5A
06018:  CLRF   1B
0601A:  BTFSC  FF2.7
0601C:  BSF    1B.7
0601E:  BCF    FF2.7
06020:  MOVFF  00,C9E
06024:  MOVLB  0
06026:  CALL   054A
0602A:  BTFSC  1B.7
0602C:  BSF    FF2.7
0602E:  MOVFF  C5B,FEA
06032:  MOVFF  C5A,FE9
06036:  MOVLB  C
06038:  MOVF   FEE,W
0603A:  BTFSS  x61.6
0603C:  BRA    5FD4
0603E:  MOVLB  0
06040:  RETURN 0
....................  
.................... #list 
....................  
.................... //#device ICD=TRUE 
.................... //#use delay(crystal=20000000,restart_wdt) 
....................  
....................  
.................... #fuses PR, MS, STVREN, SOSC_DIG, NOPLL, NODEBUG, BROWNOUT_SW, NOWDT, NOPROTECT  
.................... #fuses NOIOL1WAY, NOXINST, CLOCKOUT, WINDIS  
....................  
.................... #device ADC=16 
.................... #use delay(crystal=8Mhz, clock=32Mhz) 
*
00432:  MOVLW  02
00434:  MOVLB  C
00436:  SUBWF  xA0,F
00438:  BNC   0452
0043A:  MOVLW  0C
0043C:  MOVWF  FEA
0043E:  MOVLW  A0
00440:  MOVWF  FE9
00442:  MOVF   FEF,W
00444:  BZ    0452
00446:  BRA    044E
00448:  BRA    044A
0044A:  BRA    044C
0044C:  NOP   
0044E:  DECFSZ FEF,F
00450:  BRA    0448
00452:  MOVLB  0
00454:  RETURN 0
*
00EE2:  MOVLW  0C
00EE4:  MOVWF  FEA
00EE6:  MOVLW  86
00EE8:  MOVWF  FE9
00EEA:  MOVF   FEF,W
00EEC:  BZ    0F08
00EEE:  MOVLW  0A
00EF0:  MOVWF  01
00EF2:  CLRF   00
00EF4:  DECFSZ 00,F
00EF6:  BRA    0EF4
00EF8:  DECFSZ 01,F
00EFA:  BRA    0EF2
00EFC:  MOVLW  5F
00EFE:  MOVWF  00
00F00:  DECFSZ 00,F
00F02:  BRA    0F00
00F04:  DECFSZ FEF,F
00F06:  BRA    0EEE
00F08:  RETURN 0
....................  
.................... #define SPIPORT SFward_FM 
.................... #define SPIPORT_2 SFward_FM 
.................... #define SPIPORT_3 SFward_FM 
....................  
.................... #define CS_PIN PIN_A2 
.................... #define CS_PIN_2 PIN_A2 
.................... #define CS_PIN_3 PIN_A2 
....................  
.................... #define READ_ID               0x9F 
.................... #define READ_STATUS_REG       0x05  
.................... #define READ3_DATA_BYTES      0x03  //0x03 for 3byte 0x13 for 3byte 
.................... #define READ4_DATA_BYTES      0x13  //0x03 for 3byte 0x13 for 3byte 
.................... #define ENABLE_WRITE          0x06 
.................... #define DISABLE_WRITE         0x04 
.................... #define WRITE3_PAGE           0x02  //0x02 for 3byte 0x12 for 4byte 
.................... #define WRITE4_PAGE           0x12  //0x02 for 3byte 0x12 for 4byte 
.................... #define ERASE3_SECTOR         0xD8  //0xD8 for 3byte 0xDC for 4byte 
.................... #define ERASE4_SECTOR         0xDC  //0xD8 for 3byte 0xDC for 4byte 
.................... #define ENABLE_BYTE4          0xB7 
.................... #define ERASE3_4KB_SUBSECTOR  0x20 
.................... #define ERASE4_4KB_SUBSECTOR  0x21 
.................... #define DIE_ERASE             0xC4 
....................  
.................... #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=1000000, MODE=0, BITS=8, STREAM=SFward_FM) 
*
00DC6:  MOVLB  C
00DC8:  MOVF   x88,W
00DCA:  SUBLW  08
00DCC:  BZ    0DD6
00DCE:  MOVWF  x89
00DD0:  RLCF   x87,F
00DD2:  DECFSZ x89,F
00DD4:  BRA    0DD0
00DD6:  BSF    F92.1
00DD8:  BCF    F92.0
00DDA:  BCF    F92.3
00DDC:  BCF    F89.3
00DDE:  MOVFF  C88,C89
00DE2:  BTFSS  x87.7
00DE4:  BCF    F89.0
00DE6:  BTFSC  x87.7
00DE8:  BSF    F89.0
00DEA:  RLCF   x87,F
00DEC:  BSF    F89.3
00DEE:  RLCF   01,F
00DF0:  BTFSS  F80.1
00DF2:  BCF    01.0
00DF4:  BTFSC  F80.1
00DF6:  BSF    01.0
00DF8:  BCF    F89.3
00DFA:  DECFSZ x89,F
00DFC:  BRA    0DE2
00DFE:  MOVLB  0
00E00:  RETURN 0
.................... //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=1000000, MODE=0, BITS=8, STREAM=SFward_FM) 
.................... //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=1000000, MODE=0, BITS=8, STREAM=SFward_FM) 
....................  
.................... #define debugPort debug 
....................  
.................... #PIN_SELECT U2TX=PIN_C7 
.................... #PIN_SELECT U2RX=PIN_C6  
.................... //#use rs232(UART2,baud=19200,parity=N,bits=8,stream=serial2APRS,SAMPLE_EARLY,ERRORS) 
.................... #use rs232(UART2,baud=19200,parity=N,bits=8,stream=serial2APRS,ERRORS,TIMEOUT=700) 
*
00456:  MOVLW  11
00458:  MOVLB  C
0045A:  MOVWF  x9F
0045C:  MOVLW  80
0045E:  MOVWF  x9E
00460:  MOVLW  9C
00462:  MOVWF  xA0
00464:  MOVLB  0
00466:  RCALL  0432
00468:  MOVLB  C
0046A:  DECFSZ x9E,F
0046C:  BRA    0478
0046E:  DECFSZ x9F,F
00470:  BRA    0478
00472:  CLRF   1C
00474:  CLRF   01
00476:  BRA    0494
00478:  BTFSS  FA4.5
0047A:  BRA    0460
0047C:  MOVLB  F
0047E:  MOVF   x33,W
00480:  MOVWF  1C
00482:  MOVF   x1E,W
00484:  MOVWF  01
00486:  BTFSC  1C.1
00488:  BRA    048E
0048A:  MOVLB  C
0048C:  BRA    0494
0048E:  BCF    x33.4
00490:  BSF    x33.4
00492:  MOVLB  C
00494:  MOVLB  0
00496:  GOTO   04B6 (RETURN)
*
05A80:  BTFSS  FA4.4
05A82:  BRA    5A80
05A84:  MOVLB  F
05A86:  MOVWF  x1D
05A88:  MOVLB  0
05A8A:  RETURN 0
....................  
.................... #PIN_SELECT U3TX=PIN_E1 //connected with C0 in MB2 
.................... #PIN_SELECT U3RX=PIN_E0 //connected with C1 in MB2 
.................... #use rs232(UART3,baud=9600,parity=N,bits=8,stream=serial2MB,ERRORS,TIMEOUT=300) // removed ,RECEIVE_BUFFER=10 
*
00500:  MOVLW  03
00502:  MOVLB  C
00504:  MOVWF  x9B
00506:  MOVLW  C0
00508:  MOVWF  x9A
0050A:  MOVLW  02
0050C:  MOVWF  x9C
0050E:  MOVLW  9C
00510:  MOVWF  xA0
00512:  MOVLB  0
00514:  RCALL  0432
00516:  MOVLB  C
00518:  DECFSZ x9C,F
0051A:  BRA    050E
0051C:  DECFSZ x9A,F
0051E:  BRA    052A
00520:  DECFSZ x9B,F
00522:  BRA    052A
00524:  CLRF   1C
00526:  CLRF   01
00528:  BRA    0546
0052A:  BTFSS  FA6.5
0052C:  BRA    050A
0052E:  MOVLB  F
00530:  MOVF   x2F,W
00532:  MOVWF  1C
00534:  MOVF   x2A,W
00536:  MOVWF  01
00538:  BTFSC  1C.1
0053A:  BRA    0540
0053C:  MOVLB  C
0053E:  BRA    0546
00540:  BCF    x2F.4
00542:  BSF    x2F.4
00544:  MOVLB  C
00546:  MOVLB  0
00548:  RETURN 0
*
00F56:  BTFSS  FA6.4
00F58:  BRA    0F56
00F5A:  MOVLB  F
00F5C:  MOVWF  x29
00F5E:  MOVLB  0
00F60:  RETURN 0
....................  
.................... #use rs232(baud=19200,parity=N,xmit=pin_E6,bits=8,stream=debug,ERRORS) 
*
0054A:  BCF    F96.6
0054C:  BCF    F8D.6
0054E:  MOVLW  08
00550:  MOVWF  01
00552:  BRA    0554
00554:  NOP   
00556:  BSF    01.7
00558:  BRA    057A
0055A:  BCF    01.7
0055C:  MOVLB  C
0055E:  RRCF   x9E,F
00560:  MOVLB  0
00562:  BTFSC  FD8.0
00564:  BSF    F8D.6
00566:  BTFSS  FD8.0
00568:  BCF    F8D.6
0056A:  BSF    01.6
0056C:  BRA    057A
0056E:  BCF    01.6
00570:  DECFSZ 01,F
00572:  BRA    055C
00574:  BRA    0576
00576:  NOP   
00578:  BSF    F8D.6
0057A:  MOVLW  84
0057C:  MOVWF  FE9
0057E:  DECFSZ FE9,F
00580:  BRA    057E
00582:  BRA    0584
00584:  NOP   
00586:  BTFSC  01.7
00588:  BRA    055A
0058A:  BTFSC  01.6
0058C:  BRA    056E
0058E:  RETURN 0
.................... //#use rs232(baud=19200,parity=N,xmit=pin_C7,rcv=pin_C6,bits=8,stream=serial2APRS) 
....................  
.................... int8 writing_delay=20; 
.................... int1 showDebug =0; 
....................  
.................... int32 adrs2subsector4kb(int32 adrs) 
*
042F0:  MOVLB  C
042F2:  CLRF   x62
042F4:  RRCF   x5E,W
042F6:  MOVWF  x61
042F8:  RRCF   x5D,W
042FA:  MOVWF  x60
042FC:  RRCF   x5C,W
042FE:  MOVWF  x5F
04300:  RRCF   x61,F
04302:  RRCF   x60,F
04304:  RRCF   x5F,F
04306:  RRCF   x61,F
04308:  RRCF   x60,F
0430A:  RRCF   x5F,F
0430C:  RRCF   x61,F
0430E:  RRCF   x60,F
04310:  RRCF   x5F,F
04312:  MOVLW  0F
04314:  ANDWF  x61,F
.................... { 
....................    int32 subsector4kbNo=adrs/0x1000; 
....................    return subsector4kbNo; 
04316:  MOVFF  C5F,00
0431A:  MOVFF  C60,01
0431E:  MOVFF  C61,02
04322:  MOVFF  C62,03
04326:  MOVLB  0
04328:  RETURN 0
.................... } 
....................  
.................... int1 isBusy(void) 
.................... { 
....................    int8 SR; 
....................    output_low(CS_PIN_3); 
*
00E02:  BCF    F92.2
00E04:  BCF    F89.2
....................    spi_xfer(SPIPORT,READ_STATUS_REG);  
00E06:  MOVLW  05
00E08:  MOVLB  C
00E0A:  MOVWF  x87
00E0C:  MOVLW  08
00E0E:  MOVWF  x88
00E10:  MOVLB  0
00E12:  RCALL  0DC6
....................    SR=spi_xfer(SPIPORT,READ_STATUS_REG); 
00E14:  MOVLW  05
00E16:  MOVLB  C
00E18:  MOVWF  x87
00E1A:  MOVLW  08
00E1C:  MOVWF  x88
00E1E:  MOVLB  0
00E20:  RCALL  0DC6
00E22:  MOVF   01,W
00E24:  MOVFF  01,C86
....................    output_high(CS_PIN_3); 
00E28:  BCF    F92.2
00E2A:  BSF    F89.2
....................    //fprintf(debugPort,"SR=%X\r\n",SR); 
....................    return bit_test(SR, 0); //return the busy flag 
00E2C:  MOVLW  00
00E2E:  MOVLB  C
00E30:  BTFSC  x86.0
00E32:  MOVLW  01
00E34:  MOVWF  01
00E36:  MOVLB  0
00E38:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... int8 ReadSR(){ 
*
00F0A:  MOVLB  C
00F0C:  SETF   x4F
....................  //delay_ms(2); 
....................  int8 SR=0xFF; 
....................  output_low(CS_PIN_2); 
00F0E:  BCF    F92.2
00F10:  BCF    F89.2
....................  delay_ms(10); 
00F12:  MOVLW  0A
00F14:  MOVWF  x86
00F16:  MOVLB  0
00F18:  RCALL  0EE2
....................  spi_xfer(SPIPORT,READ_STATUS_REG);  
00F1A:  MOVLW  05
00F1C:  MOVLB  C
00F1E:  MOVWF  x87
00F20:  MOVLW  08
00F22:  MOVWF  x88
00F24:  MOVLB  0
00F26:  RCALL  0DC6
....................  SR=spi_xfer(SPIPORT,READ_STATUS_REG);  
00F28:  MOVLW  05
00F2A:  MOVLB  C
00F2C:  MOVWF  x87
00F2E:  MOVLW  08
00F30:  MOVWF  x88
00F32:  MOVLB  0
00F34:  RCALL  0DC6
00F36:  MOVF   01,W
00F38:  MOVFF  01,C4F
....................  delay_ms(10); 
00F3C:  MOVLW  0A
00F3E:  MOVLB  C
00F40:  MOVWF  x86
00F42:  MOVLB  0
00F44:  RCALL  0EE2
....................  output_high(CS_PIN_2); 
00F46:  BCF    F92.2
00F48:  BSF    F89.2
....................  return SR; 
00F4A:  MOVLB  C
00F4C:  MOVFF  C4F,01
00F50:  MOVLB  0
00F52:  GOTO   1DAA (RETURN)
.................... } 
....................  
.................... void ENABLE_4BYTES_ADDRESS() 
.................... { 
....................  while(isBusy()); 
*
00E3A:  RCALL  0E02
00E3C:  MOVF   01,F
00E3E:  BNZ   0E3A
....................  output_low(CS_PIN_3); 
00E40:  BCF    F92.2
00E42:  BCF    F89.2
....................  spi_xfer(SPIPORT_3,ENABLE_BYTE4);                
00E44:  MOVLW  B7
00E46:  MOVLB  C
00E48:  MOVWF  x87
00E4A:  MOVLW  08
00E4C:  MOVWF  x88
00E4E:  MOVLB  0
00E50:  RCALL  0DC6
....................  output_high(CS_PIN_3); 
00E52:  BCF    F92.2
00E54:  BSF    F89.2
....................  while(isBusy()); 
00E56:  RCALL  0E02
00E58:  MOVF   01,F
00E5A:  BNZ   0E56
....................  return; 
00E5C:  GOTO   1B4C (RETURN)
.................... } 
....................  
.................... void WRITE_ENABLE3(){ 
....................  while(isBusy()); 
....................  output_low(CS_PIN_2); 
....................  spi_xfer(SPIPORT_2,ENABLE_WRITE);                //Send 0x06 
....................  output_high(CS_PIN_2);   
....................  while(isBusy()); 
....................  return; 
....................   
.................... } 
.................... void WRITE_ENABLE4(){ 
....................  while(isBusy()); 
*
00FD0:  RCALL  0E02
00FD2:  MOVF   01,F
00FD4:  BNZ   0FD0
....................  output_low(CS_PIN_3); 
00FD6:  BCF    F92.2
00FD8:  BCF    F89.2
....................  spi_xfer(SPIPORT_3,ENABLE_WRITE);                //Send 0x06 
00FDA:  MOVLW  06
00FDC:  MOVLB  C
00FDE:  MOVWF  x87
00FE0:  MOVLW  08
00FE2:  MOVWF  x88
00FE4:  MOVLB  0
00FE6:  RCALL  0DC6
....................  output_high(CS_PIN_3);   
00FE8:  BCF    F92.2
00FEA:  BSF    F89.2
....................  while(isBusy()); 
00FEC:  RCALL  0E02
00FEE:  MOVF   01,F
00FF0:  BNZ   0FEC
....................  return; 
00FF2:  RETURN 0
.................... } 
.................... void WRITE_DISABLE4(){ 
....................  while(isBusy()); 
*
01134:  RCALL  0E02
01136:  MOVF   01,F
01138:  BNZ   1134
....................  output_low(CS_PIN_3); 
0113A:  BCF    F92.2
0113C:  BCF    F89.2
....................  spi_xfer(SPIPORT_3,DISABLE_WRITE);                //Send 0x06 
0113E:  MOVLW  04
01140:  MOVLB  C
01142:  MOVWF  x87
01144:  MOVLW  08
01146:  MOVWF  x88
01148:  MOVLB  0
0114A:  RCALL  0DC6
....................  output_high(CS_PIN_3);   
0114C:  BCF    F92.2
0114E:  BSF    F89.2
....................  while(isBusy()); 
01150:  RCALL  0E02
01152:  MOVF   01,F
01154:  BNZ   1150
....................  return; 
01156:  RETURN 0
.................... } 
....................  
.................... void sector_erase3(unsigned int32 sector_address) 
.................... { 
....................    fprintf(debugPort,"Erasing Sector64kb adrs %lX\r\n",sector_address); 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE3(); 
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE3_SECTOR);                                             //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    //spi_xfer(SPIPORT_2,adsress[0]);    
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
....................    while(isBusy()); 
....................    return; 
.................... } 
.................... void sector_erase4(unsigned int32 sector_address) 
.................... { 
....................    fprintf(debugPort,"Erasing Sector64kb adrs %lX\r\n",sector_address); 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE4(); 
....................    output_low(CS_PIN_3);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE4_SECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
....................    spi_xfer(SPIPORT_3,adsress[1]);     
....................    spi_xfer(SPIPORT_3,adsress[2]);     
....................    spi_xfer(SPIPORT_3,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_3);           //take CS PIN higher back 
....................    //delay_ms(1000);   
....................    while(isBusy()); 
....................    return; 
.................... } 
....................  
....................  
.................... void SUBSECTOR_4KB_ERASE3(unsigned int32 sector_address)                      //Funcion que borra un sector de 4KB de la COM Flash 
.................... { 
....................    fprintf(debugPort,"Erasing subsector4kb adrs %lX\r\n",sector_address); 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE3();                                                           //Funcion que habilita escritura en COM Flash 
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE3_4KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    //spi_xfer(SPIPORT_2,adsress[0]);    
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
....................    while(isBusy());  
....................     
....................    return; 
.................... } 
.................... void SUBSECTOR_4KB_ERASE4(unsigned int32 sector_address)                      //Funcion que borra un sector de 4KB de la Mission Flash 
.................... { 
....................    fprintf(debugPort,"Erasing subsector4kb adrs %lX\r\n",sector_address); 
*
00FF4:  MOVLW  42
00FF6:  MOVWF  FF6
00FF8:  MOVLW  01
00FFA:  MOVWF  FF7
00FFC:  MOVLW  00
00FFE:  MOVWF  FF8
01000:  CLRF   1B
01002:  BTFSC  FF2.7
01004:  BSF    1B.7
01006:  BCF    FF2.7
01008:  MOVLW  1A
0100A:  MOVLB  C
0100C:  MOVWF  x9A
0100E:  MOVLB  0
01010:  CALL   05B8
01014:  BTFSC  1B.7
01016:  BSF    FF2.7
01018:  CLRF   1B
0101A:  BTFSC  FF2.7
0101C:  BSF    1B.7
0101E:  BCF    FF2.7
01020:  MOVFF  C6C,C9A
01024:  MOVLW  37
01026:  MOVLB  C
01028:  MOVWF  x9B
0102A:  MOVLB  0
0102C:  CALL   05E8
01030:  BTFSC  1B.7
01032:  BSF    FF2.7
01034:  CLRF   1B
01036:  BTFSC  FF2.7
01038:  BSF    1B.7
0103A:  BCF    FF2.7
0103C:  MOVFF  C6B,C9A
01040:  MOVLW  37
01042:  MOVLB  C
01044:  MOVWF  x9B
01046:  MOVLB  0
01048:  CALL   05E8
0104C:  BTFSC  1B.7
0104E:  BSF    FF2.7
01050:  CLRF   1B
01052:  BTFSC  FF2.7
01054:  BSF    1B.7
01056:  BCF    FF2.7
01058:  MOVFF  C6A,C9A
0105C:  MOVLW  37
0105E:  MOVLB  C
01060:  MOVWF  x9B
01062:  MOVLB  0
01064:  CALL   05E8
01068:  BTFSC  1B.7
0106A:  BSF    FF2.7
0106C:  CLRF   1B
0106E:  BTFSC  FF2.7
01070:  BSF    1B.7
01072:  BCF    FF2.7
01074:  MOVFF  C69,C9A
01078:  MOVLW  37
0107A:  MOVLB  C
0107C:  MOVWF  x9B
0107E:  MOVLB  0
01080:  CALL   05E8
01084:  BTFSC  1B.7
01086:  BSF    FF2.7
01088:  CLRF   1B
0108A:  BTFSC  FF2.7
0108C:  BSF    1B.7
0108E:  BCF    FF2.7
01090:  MOVLW  0D
01092:  MOVLB  C
01094:  MOVWF  x9E
01096:  MOVLB  0
01098:  CALL   054A
0109C:  BTFSC  1B.7
0109E:  BSF    FF2.7
010A0:  CLRF   1B
010A2:  BTFSC  FF2.7
010A4:  BSF    1B.7
010A6:  BCF    FF2.7
010A8:  MOVLW  0A
010AA:  MOVLB  C
010AC:  MOVWF  x9E
010AE:  MOVLB  0
010B0:  CALL   054A
010B4:  BTFSC  1B.7
010B6:  BSF    FF2.7
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
010B8:  MOVLB  C
010BA:  MOVFF  C6C,C6D
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
010BE:  MOVFF  C6B,C6E
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
010C2:  MOVFF  C6A,C6F
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
010C6:  MOVFF  C69,C70
....................     
....................     
....................    WRITE_ENABLE4();                                                           //Funcion que habilita escritura en Mission Flash 
010CA:  MOVLB  0
010CC:  RCALL  0FD0
....................    output_low(CS_PIN_3);                                                         //lower the CS PIN 
010CE:  BCF    F92.2
010D0:  BCF    F89.2
....................    delay_us(2); 
010D2:  MOVLW  05
010D4:  MOVWF  00
010D6:  DECFSZ 00,F
010D8:  BRA    10D6
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE4_4KB_SUBSECTOR);                                      //SECTOR ERASE COMAND   (0xDC) 
010DA:  MOVLW  21
010DC:  MOVLB  C
010DE:  MOVWF  x87
010E0:  MOVLW  08
010E2:  MOVWF  x88
010E4:  MOVLB  0
010E6:  RCALL  0DC6
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
010E8:  MOVFF  C6D,C87
010EC:  MOVLW  08
010EE:  MOVLB  C
010F0:  MOVWF  x88
010F2:  MOVLB  0
010F4:  RCALL  0DC6
....................    spi_xfer(SPIPORT_3,adsress[1]);     
010F6:  MOVFF  C6E,C87
010FA:  MOVLW  08
010FC:  MOVLB  C
010FE:  MOVWF  x88
01100:  MOVLB  0
01102:  RCALL  0DC6
....................    spi_xfer(SPIPORT_3,adsress[2]);     
01104:  MOVFF  C6F,C87
01108:  MOVLW  08
0110A:  MOVLB  C
0110C:  MOVWF  x88
0110E:  MOVLB  0
01110:  RCALL  0DC6
....................    spi_xfer(SPIPORT_3,adsress[3]); 
01112:  MOVFF  C70,C87
01116:  MOVLW  08
01118:  MOVLB  C
0111A:  MOVWF  x88
0111C:  MOVLB  0
0111E:  RCALL  0DC6
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
01120:  MOVLW  05
01122:  MOVWF  00
01124:  DECFSZ 00,F
01126:  BRA    1124
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
01128:  BCF    F92.2
0112A:  BSF    F89.2
....................    while(isBusy());  
0112C:  RCALL  0E02
0112E:  MOVF   01,F
01130:  BNZ   112C
....................     
....................    return; 
01132:  RETURN 0
.................... } 
....................  
.................... void erase_sectors(int16 startingSector, int16 endingSector) 
.................... { 
....................    int32 sector;  
....................    for (sector=startingSector;sector<=endingSector;sector++) 
....................    { 
....................       sector_erase4((int32) sector*16*0x1000); 
....................       fprintf(debugPort,"Sector %lu is erased\r\n", sector); 
....................    } 
.................... } 
.................... void die_erase_command(void) 
.................... { 
....................    //fprintf(debugPort,"die_erase_command started\r\n"); 
....................    unsigned int8 adsress[4]={0,0,0,0}; 
....................    WRITE_ENABLE4(); 
....................    output_low(CS_PIN_3);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,DIE_ERASE);  
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
....................    spi_xfer(SPIPORT_3,adsress[1]);     
....................    spi_xfer(SPIPORT_3,adsress[2]);     
....................    spi_xfer(SPIPORT_3,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................      
....................    delay_us(2); 
....................    //delay_ms(50000); 
....................    output_high(CS_PIN_3);           //take CS PIN higher back 
....................     
....................    while(isBusy()); 
....................     
....................    //fprintf(debugPort,"die_erase_command finished\r\n"); 
....................    return; 
.................... } 
....................  
....................  
.................... void WRITE_DATA_BYTE3(unsigned int32 page_address, int8 data)                 //Funcion que escribe un Byte en la COM Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
....................     
....................    WRITE_ENABLE3(); 
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
....................    spi_xfer(SPIPORT_2,WRITE3_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
....................    
....................    //spi_xfer(SPIPORT_2,adsress[0]);     
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................     
....................    spi_xfer(SPIPORT_2,data);  
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
....................    while(isBusy()); 
....................    return; 
.................... } 
.................... void WRITE_DATA_BYTE4(unsigned int32 page_address, int8 data)                 //Funcion que escribe un Byte en la Mission Flash 
.................... { 
....................    while(isBusy()); 
*
016DC:  CALL   0E02
016E0:  MOVF   01,F
016E2:  BNZ   16DC
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
016E4:  MOVLB  C
016E6:  MOVFF  C71,C73
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
016EA:  MOVFF  C70,C74
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
016EE:  MOVFF  C6F,C75
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
016F2:  MOVFF  C6E,C76
....................     
....................    WRITE_ENABLE4(); 
016F6:  MOVLB  0
016F8:  RCALL  0FD0
....................    output_low(CS_PIN_3);                                                         //lower the CS PIN 
016FA:  BCF    F92.2
016FC:  BCF    F89.2
....................    //delay_us(2); 
....................     
....................    spi_xfer(SPIPORT_3,WRITE4_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
016FE:  MOVLW  12
01700:  MOVLB  C
01702:  MOVWF  x87
01704:  MOVLW  08
01706:  MOVWF  x88
01708:  MOVLB  0
0170A:  CALL   0DC6
....................    
....................    spi_xfer(SPIPORT_3,adsress[0]);     
0170E:  MOVFF  C73,C87
01712:  MOVLW  08
01714:  MOVLB  C
01716:  MOVWF  x88
01718:  MOVLB  0
0171A:  CALL   0DC6
....................    spi_xfer(SPIPORT_3,adsress[1]);     
0171E:  MOVFF  C74,C87
01722:  MOVLW  08
01724:  MOVLB  C
01726:  MOVWF  x88
01728:  MOVLB  0
0172A:  CALL   0DC6
....................    spi_xfer(SPIPORT_3,adsress[2]);     
0172E:  MOVFF  C75,C87
01732:  MOVLW  08
01734:  MOVLB  C
01736:  MOVWF  x88
01738:  MOVLB  0
0173A:  CALL   0DC6
....................    spi_xfer(SPIPORT_3,adsress[3]); 
0173E:  MOVFF  C76,C87
01742:  MOVLW  08
01744:  MOVLB  C
01746:  MOVWF  x88
01748:  MOVLB  0
0174A:  CALL   0DC6
....................     
....................    spi_xfer(SPIPORT_3,data);  
0174E:  MOVFF  C72,C87
01752:  MOVLW  08
01754:  MOVLB  C
01756:  MOVWF  x88
01758:  MOVLB  0
0175A:  CALL   0DC6
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
0175E:  BCF    F92.2
01760:  BSF    F89.2
....................    //delay_ms(writing_delay);   
....................    WRITE_DISABLE4(); 
01762:  RCALL  1134
....................    while(isBusy()); 
01764:  CALL   0E02
01768:  MOVF   01,F
0176A:  BNZ   1764
....................    return; 
0176C:  RETURN 0
.................... } 
....................  
....................  
.................... int8 READ_DATA_BYTE3(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................  unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
....................     
....................  output_low(CS_PIN_2);                                                           //lower the CS PIN 
....................   
....................  ////////////////////////////////////////////////////////////////// 
....................  int8 data; 
....................  spi_xfer(SPIPORT_2,READ3_DATA_BYTES);                                            //READ DATA COMAND   (0x13) 
....................   
....................  //spi_xfer(SPIPORT_2,adsress[0]); 
....................  spi_xfer(SPIPORT_2,adsress[1]); 
....................  spi_xfer(SPIPORT_2,adsress[2]); 
....................  spi_xfer(SPIPORT_2,adsress[3]); 
....................  data = spi_xfer(SPIPORT_2); 
....................  ////////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);//take CS PIN higher back 
....................  while(isBusy()); 
....................  return data; 
....................   
.................... } 
.................... int8 READ_DATA_BYTE4(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................  unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
*
00E60:  MOVLB  C
00E62:  MOVFF  C6D,C6E
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
00E66:  MOVFF  C6C,C6F
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
00E6A:  MOVFF  C6B,C70
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
00E6E:  MOVFF  C6A,C71
....................     
....................  output_low(CS_PIN_3);                                                           //lower the CS PIN 
00E72:  BCF    F92.2
00E74:  BCF    F89.2
....................   
....................  ////////////////////////////////////////////////////////////////// 
....................  int8 data; 
....................  spi_xfer(SPIPORT_3,READ4_DATA_BYTES);                                            //READ DATA COMAND   (0x13) 
00E76:  MOVLW  13
00E78:  MOVWF  x87
00E7A:  MOVLW  08
00E7C:  MOVWF  x88
00E7E:  MOVLB  0
00E80:  RCALL  0DC6
....................   
....................  spi_xfer(SPIPORT_3,adsress[0]); 
00E82:  MOVFF  C6E,C87
00E86:  MOVLW  08
00E88:  MOVLB  C
00E8A:  MOVWF  x88
00E8C:  MOVLB  0
00E8E:  RCALL  0DC6
....................  spi_xfer(SPIPORT_3,adsress[1]); 
00E90:  MOVFF  C6F,C87
00E94:  MOVLW  08
00E96:  MOVLB  C
00E98:  MOVWF  x88
00E9A:  MOVLB  0
00E9C:  RCALL  0DC6
....................  spi_xfer(SPIPORT_3,adsress[2]); 
00E9E:  MOVFF  C70,C87
00EA2:  MOVLW  08
00EA4:  MOVLB  C
00EA6:  MOVWF  x88
00EA8:  MOVLB  0
00EAA:  RCALL  0DC6
....................  spi_xfer(SPIPORT_3,adsress[3]); 
00EAC:  MOVFF  C71,C87
00EB0:  MOVLW  08
00EB2:  MOVLB  C
00EB4:  MOVWF  x88
00EB6:  MOVLB  0
00EB8:  RCALL  0DC6
....................  data = spi_xfer(SPIPORT_3); 
00EBA:  MOVLW  01
00EBC:  MOVLB  C
00EBE:  MOVWF  x87
00EC0:  MOVLW  08
00EC2:  MOVWF  x88
00EC4:  MOVLB  0
00EC6:  RCALL  0DC6
00EC8:  MOVF   01,W
00ECA:  MOVFF  01,C72
....................  ////////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);                                                          //take CS PIN higher back 
00ECE:  BCF    F92.2
00ED0:  BSF    F89.2
....................  while(isBusy()); 
00ED2:  RCALL  0E02
00ED4:  MOVF   01,F
00ED6:  BNZ   0ED2
....................  return data; 
00ED8:  MOVLB  C
00EDA:  MOVFF  C72,01
00EDE:  MOVLB  0
00EE0:  RETURN 0
....................   
.................... } 
....................  
....................  
....................  
.................... INT32 WRITE_DATA_N_BYTE4(INT32 writing_address,int32 size, int8 *data) //read and send the specified data 
.................... { 
....................    fprintf(debugPort,"Writing_address=%lX should end in %lX \r\n",writing_address,writing_address+size-1); 
*
01158:  MOVLB  C
0115A:  MOVF   x6D,W
0115C:  ADDWF  x69,W
0115E:  MOVWF  x86
01160:  MOVF   x6E,W
01162:  ADDWFC x6A,W
01164:  MOVWF  x87
01166:  MOVF   x6F,W
01168:  ADDWFC x6B,W
0116A:  MOVWF  x88
0116C:  MOVF   x70,W
0116E:  ADDWFC x6C,W
01170:  MOVWF  x89
01172:  MOVLW  01
01174:  SUBWF  x86,F
01176:  MOVLW  00
01178:  SUBWFB x87,F
0117A:  SUBWFB x88,F
0117C:  SUBWFB x89,F
0117E:  MOVLW  7A
01180:  MOVWF  FF6
01182:  MOVLW  01
01184:  MOVWF  FF7
01186:  MOVLW  00
01188:  MOVWF  FF8
0118A:  CLRF   1B
0118C:  BTFSC  FF2.7
0118E:  BSF    1B.7
01190:  BCF    FF2.7
01192:  MOVLW  10
01194:  MOVWF  x9A
01196:  MOVLB  0
01198:  CALL   05B8
0119C:  BTFSC  1B.7
0119E:  BSF    FF2.7
011A0:  CLRF   1B
011A2:  BTFSC  FF2.7
011A4:  BSF    1B.7
011A6:  BCF    FF2.7
011A8:  MOVFF  C6C,C9A
011AC:  MOVLW  37
011AE:  MOVLB  C
011B0:  MOVWF  x9B
011B2:  MOVLB  0
011B4:  CALL   05E8
011B8:  BTFSC  1B.7
011BA:  BSF    FF2.7
011BC:  CLRF   1B
011BE:  BTFSC  FF2.7
011C0:  BSF    1B.7
011C2:  BCF    FF2.7
011C4:  MOVFF  C6B,C9A
011C8:  MOVLW  37
011CA:  MOVLB  C
011CC:  MOVWF  x9B
011CE:  MOVLB  0
011D0:  CALL   05E8
011D4:  BTFSC  1B.7
011D6:  BSF    FF2.7
011D8:  CLRF   1B
011DA:  BTFSC  FF2.7
011DC:  BSF    1B.7
011DE:  BCF    FF2.7
011E0:  MOVFF  C6A,C9A
011E4:  MOVLW  37
011E6:  MOVLB  C
011E8:  MOVWF  x9B
011EA:  MOVLB  0
011EC:  CALL   05E8
011F0:  BTFSC  1B.7
011F2:  BSF    FF2.7
011F4:  CLRF   1B
011F6:  BTFSC  FF2.7
011F8:  BSF    1B.7
011FA:  BCF    FF2.7
011FC:  MOVFF  C69,C9A
01200:  MOVLW  37
01202:  MOVLB  C
01204:  MOVWF  x9B
01206:  MOVLB  0
01208:  CALL   05E8
0120C:  BTFSC  1B.7
0120E:  BSF    FF2.7
01210:  MOVLW  8D
01212:  MOVWF  FF6
01214:  MOVLW  01
01216:  MOVWF  FF7
01218:  MOVLW  00
0121A:  MOVWF  FF8
0121C:  CLRF   1B
0121E:  BTFSC  FF2.7
01220:  BSF    1B.7
01222:  BCF    FF2.7
01224:  MOVLW  0F
01226:  MOVLB  C
01228:  MOVWF  x9A
0122A:  MOVLB  0
0122C:  CALL   05B8
01230:  BTFSC  1B.7
01232:  BSF    FF2.7
01234:  CLRF   1B
01236:  BTFSC  FF2.7
01238:  BSF    1B.7
0123A:  BCF    FF2.7
0123C:  MOVFF  C89,C9A
01240:  MOVLW  37
01242:  MOVLB  C
01244:  MOVWF  x9B
01246:  MOVLB  0
01248:  CALL   05E8
0124C:  BTFSC  1B.7
0124E:  BSF    FF2.7
01250:  CLRF   1B
01252:  BTFSC  FF2.7
01254:  BSF    1B.7
01256:  BCF    FF2.7
01258:  MOVFF  C88,C9A
0125C:  MOVLW  37
0125E:  MOVLB  C
01260:  MOVWF  x9B
01262:  MOVLB  0
01264:  CALL   05E8
01268:  BTFSC  1B.7
0126A:  BSF    FF2.7
0126C:  CLRF   1B
0126E:  BTFSC  FF2.7
01270:  BSF    1B.7
01272:  BCF    FF2.7
01274:  MOVFF  C87,C9A
01278:  MOVLW  37
0127A:  MOVLB  C
0127C:  MOVWF  x9B
0127E:  MOVLB  0
01280:  CALL   05E8
01284:  BTFSC  1B.7
01286:  BSF    FF2.7
01288:  CLRF   1B
0128A:  BTFSC  FF2.7
0128C:  BSF    1B.7
0128E:  BCF    FF2.7
01290:  MOVFF  C86,C9A
01294:  MOVLW  37
01296:  MOVLB  C
01298:  MOVWF  x9B
0129A:  MOVLB  0
0129C:  CALL   05E8
012A0:  BTFSC  1B.7
012A2:  BSF    FF2.7
012A4:  MOVLW  9F
012A6:  MOVWF  FF6
012A8:  MOVLW  01
012AA:  MOVWF  FF7
012AC:  MOVLW  00
012AE:  MOVWF  FF8
012B0:  CLRF   1B
012B2:  BTFSC  FF2.7
012B4:  BSF    1B.7
012B6:  BCF    FF2.7
012B8:  MOVLW  03
012BA:  MOVLB  C
012BC:  MOVWF  x9A
012BE:  MOVLB  0
012C0:  CALL   05B8
012C4:  BTFSC  1B.7
012C6:  BSF    FF2.7
....................    int32 byteNo=0; 
....................    int32 pageNo=0; 
....................    int32 pageNoCounter=0; 
....................    int8 counter; 
....................    int16 rest = 256-(writing_address % 256); 
....................    //fprintf(debugPort,"rest= %lu\r\n",rest); 
....................  
....................    int8 addsress_array[4]; 
012C8:  MOVLB  C
012CA:  CLRF   x76
012CC:  CLRF   x75
012CE:  CLRF   x74
012D0:  CLRF   x73
012D2:  CLRF   x7A
012D4:  CLRF   x79
012D6:  CLRF   x78
012D8:  CLRF   x77
012DA:  CLRF   x7E
012DC:  CLRF   x7D
012DE:  CLRF   x7C
012E0:  CLRF   x7B
012E2:  CLRF   01
012E4:  MOVLW  00
012E6:  BSF    FD8.0
012E8:  SUBFWB x69,W
012EA:  MOVWF  x80
012EC:  MOVLW  01
012EE:  SUBFWB 01,W
012F0:  MOVWF  x81
....................     
....................    addsress_array[0]  = (int8)((writing_address>>24) & 0xFF);       
012F2:  MOVFF  C6C,C82
....................    addsress_array[1]  = (int8)((writing_address>>16) & 0xFF);       
012F6:  MOVFF  C6B,C83
....................    addsress_array[2]  = (int8)((writing_address>>8) & 0xFF);        
012FA:  MOVFF  C6A,C84
....................    addsress_array[3]  = (int8)((writing_address) & 0xFF);           
012FE:  MOVFF  C69,C85
....................     
....................    if ((writing_address % 256)!=0) 
01302:  MOVFF  C69,C86
01306:  CLRF   x87
01308:  CLRF   x88
0130A:  CLRF   x89
0130C:  MOVF   x86,F
0130E:  BNZ   131E
01310:  MOVF   x87,F
01312:  BNZ   131E
01314:  MOVF   x88,F
01316:  BNZ   131E
01318:  MOVF   x89,F
0131A:  BTFSC  FD8.2
0131C:  BRA    14B0
....................    { 
....................    WRITE_ENABLE4(); 
0131E:  MOVLB  0
01320:  RCALL  0FD0
....................    output_low(CS_PIN_3);                                                         //lower the CS PIN 
01322:  BCF    F92.2
01324:  BCF    F89.2
....................    spi_xfer(SPIPORT_3,WRITE4_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
01326:  MOVLW  12
01328:  MOVLB  C
0132A:  MOVWF  x87
0132C:  MOVLW  08
0132E:  MOVWF  x88
01330:  MOVLB  0
01332:  RCALL  0DC6
....................    
....................    spi_xfer(SPIPORT_3,addsress_array[0]);     
01334:  MOVFF  C82,C87
01338:  MOVLW  08
0133A:  MOVLB  C
0133C:  MOVWF  x88
0133E:  MOVLB  0
01340:  RCALL  0DC6
....................    spi_xfer(SPIPORT_3,addsress_array[1]);     
01342:  MOVFF  C83,C87
01346:  MOVLW  08
01348:  MOVLB  C
0134A:  MOVWF  x88
0134C:  MOVLB  0
0134E:  RCALL  0DC6
....................    spi_xfer(SPIPORT_3,addsress_array[2]);     
01350:  MOVFF  C84,C87
01354:  MOVLW  08
01356:  MOVLB  C
01358:  MOVWF  x88
0135A:  MOVLB  0
0135C:  RCALL  0DC6
....................    spi_xfer(SPIPORT_3,addsress_array[3]);    
0135E:  MOVFF  C85,C87
01362:  MOVLW  08
01364:  MOVLB  C
01366:  MOVWF  x88
01368:  MOVLB  0
0136A:  RCALL  0DC6
....................    while ((byteNo<rest)&&(byteNo<size))  
0136C:  MOVLB  C
0136E:  MOVF   x76,F
01370:  BTFSS  FD8.2
01372:  BRA    1464
01374:  MOVF   x75,F
01376:  BTFSS  FD8.2
01378:  BRA    1464
0137A:  MOVF   x74,W
0137C:  SUBWF  x81,W
0137E:  BTFSS  FD8.0
01380:  BRA    1464
01382:  BNZ   138C
01384:  MOVF   x80,W
01386:  SUBWF  x73,W
01388:  BTFSC  FD8.0
0138A:  BRA    1464
0138C:  MOVF   x76,W
0138E:  SUBWF  x70,W
01390:  BTFSS  FD8.0
01392:  BRA    1464
01394:  BNZ   13AC
01396:  MOVF   x75,W
01398:  SUBWF  x6F,W
0139A:  BNC   1464
0139C:  BNZ   13AC
0139E:  MOVF   x74,W
013A0:  SUBWF  x6E,W
013A2:  BNC   1464
013A4:  BNZ   13AC
013A6:  MOVF   x6D,W
013A8:  SUBWF  x73,W
013AA:  BC    1464
....................    { 
....................       spi_xfer(SPIPORT_3,data[byteNo]);  
013AC:  MOVF   x71,W
013AE:  ADDWF  x73,W
013B0:  MOVWF  FE9
013B2:  MOVF   x72,W
013B4:  ADDWFC x74,W
013B6:  MOVWF  FEA
013B8:  MOVFF  FEF,C87
013BC:  MOVLW  08
013BE:  MOVWF  x88
013C0:  MOVLB  0
013C2:  RCALL  0DC6
....................       if (byteNo%16==0) {fprintf(debugPort,"\r\n");} 
013C4:  MOVLB  C
013C6:  MOVF   x73,W
013C8:  ANDLW  0F
013CA:  MOVWF  x86
013CC:  CLRF   x87
013CE:  CLRF   x88
013D0:  CLRF   x89
013D2:  MOVF   x86,F
013D4:  BNZ   1412
013D6:  MOVF   x87,F
013D8:  BNZ   1412
013DA:  MOVF   x88,F
013DC:  BNZ   1412
013DE:  MOVF   x89,F
013E0:  BNZ   1412
013E2:  CLRF   1B
013E4:  BTFSC  FF2.7
013E6:  BSF    1B.7
013E8:  BCF    FF2.7
013EA:  MOVLW  0D
013EC:  MOVWF  x9E
013EE:  MOVLB  0
013F0:  CALL   054A
013F4:  BTFSC  1B.7
013F6:  BSF    FF2.7
013F8:  CLRF   1B
013FA:  BTFSC  FF2.7
013FC:  BSF    1B.7
013FE:  BCF    FF2.7
01400:  MOVLW  0A
01402:  MOVLB  C
01404:  MOVWF  x9E
01406:  MOVLB  0
01408:  CALL   054A
0140C:  BTFSC  1B.7
0140E:  BSF    FF2.7
01410:  MOVLB  C
....................       fprintf(debugPort,"%X ",data[byteNo]); 
01412:  MOVF   x71,W
01414:  ADDWF  x73,W
01416:  MOVWF  FE9
01418:  MOVF   x72,W
0141A:  ADDWFC x74,W
0141C:  MOVWF  FEA
0141E:  MOVFF  FEF,C9A
01422:  CLRF   1B
01424:  BTFSC  FF2.7
01426:  BSF    1B.7
01428:  BCF    FF2.7
0142A:  MOVLW  37
0142C:  MOVWF  x9B
0142E:  MOVLB  0
01430:  CALL   05E8
01434:  BTFSC  1B.7
01436:  BSF    FF2.7
01438:  CLRF   1B
0143A:  BTFSC  FF2.7
0143C:  BSF    1B.7
0143E:  BCF    FF2.7
01440:  MOVLW  20
01442:  MOVLB  C
01444:  MOVWF  x9E
01446:  MOVLB  0
01448:  CALL   054A
0144C:  BTFSC  1B.7
0144E:  BSF    FF2.7
....................       byteNo++; 
01450:  MOVLW  01
01452:  MOVLB  C
01454:  ADDWF  x73,F
01456:  BTFSC  FD8.0
01458:  INCF   x74,F
0145A:  BTFSC  FD8.2
0145C:  INCF   x75,F
0145E:  BTFSC  FD8.2
01460:  INCF   x76,F
01462:  BRA    136E
01464:  CLRF   1B
01466:  BTFSC  FF2.7
01468:  BSF    1B.7
0146A:  BCF    FF2.7
....................    } 
....................    fprintf(debugPort,"\r\n"); 
0146C:  MOVLW  0D
0146E:  MOVWF  x9E
01470:  MOVLB  0
01472:  CALL   054A
01476:  BTFSC  1B.7
01478:  BSF    FF2.7
0147A:  CLRF   1B
0147C:  BTFSC  FF2.7
0147E:  BSF    1B.7
01480:  BCF    FF2.7
01482:  MOVLW  0A
01484:  MOVLB  C
01486:  MOVWF  x9E
01488:  MOVLB  0
0148A:  CALL   054A
0148E:  BTFSC  1B.7
01490:  BSF    FF2.7
....................    //fprintf(debugPort,"Wrote the rest which is =%lu\r\n",rest); 
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
01492:  BCF    F92.2
01494:  BSF    F89.2
....................    delay_ms(writing_delay);   
01496:  MOVFF  1D,C86
0149A:  RCALL  0EE2
....................    WRITE_DISABLE4(); 
0149C:  RCALL  1134
....................  
....................    //fprintf(debugPort,"Writing address was: %lX \r\n",(writing_address)); 
....................    //fprintf(debugPort,"data size was: %ld \r\n",(size)); 
....................    writing_address=writing_address+byteNo; 
0149E:  MOVLB  C
014A0:  MOVF   x73,W
014A2:  ADDWF  x69,F
014A4:  MOVF   x74,W
014A6:  ADDWFC x6A,F
014A8:  MOVF   x75,W
014AA:  ADDWFC x6B,F
014AC:  MOVF   x76,W
014AE:  ADDWFC x6C,F
....................    //fprintf(debugPort,"writing_address= %lX\r\n",writing_address); 
....................    //size=size-byteNo; 
....................    //fprintf(debugPort,"Writing address became: %lX \r\n\r\n",(writing_address)); 
....................    //fprintf(debugPort,"data size became: %ld \r\n",(size)); 
....................    }    
....................     
....................     
....................    //size=size-byteNo; 
....................    pageNo=(int8)(size/256); 
014B0:  CLRF   x7A
014B2:  CLRF   x79
014B4:  CLRF   x78
014B6:  MOVFF  C6E,C77
....................    //fprintf(debugPort,"number of pages: %u\r\n",(int8)pageNo); 
....................     
....................    pageNoCounter=0; 
014BA:  CLRF   x7E
014BC:  CLRF   x7D
014BE:  CLRF   x7C
014C0:  CLRF   x7B
....................    while (pageNoCounter<=pageNo) //it is <= to run it one more time 
014C2:  MOVF   x7E,W
014C4:  SUBWF  x7A,W
014C6:  BTFSS  FD8.0
014C8:  BRA    166A
014CA:  BNZ   14E8
014CC:  MOVF   x7D,W
014CE:  SUBWF  x79,W
014D0:  BTFSS  FD8.0
014D2:  BRA    166A
014D4:  BNZ   14E8
014D6:  MOVF   x7C,W
014D8:  SUBWF  x78,W
014DA:  BTFSS  FD8.0
014DC:  BRA    166A
014DE:  BNZ   14E8
014E0:  MOVF   x7B,W
014E2:  SUBWF  x77,W
014E4:  BTFSS  FD8.0
014E6:  BRA    166A
....................    { 
....................       //fprintf(debugPort,"big loop...pageNoCounter=%lu \r\n ",pageNoCounter); 
....................       addsress_array[0]  = (int8)((writing_address>>24) & 0xFF); 
014E8:  MOVFF  C6C,C82
....................       addsress_array[1]  = (int8)((writing_address>>16) & 0xFF);       
014EC:  MOVFF  C6B,C83
....................       addsress_array[2]  = (int8)((writing_address>>8) & 0xFF);        
014F0:  MOVFF  C6A,C84
....................       addsress_array[3]  = (int8)((writing_address) & 0xFF);     
014F4:  MOVFF  C69,C85
....................        
....................       WRITE_ENABLE4(); 
014F8:  MOVLB  0
014FA:  RCALL  0FD0
....................       output_low(CS_PIN_3);                                                         //lower the CS PIN 
014FC:  BCF    F92.2
014FE:  BCF    F89.2
....................       spi_xfer(SPIPORT_3,WRITE4_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
01500:  MOVLW  12
01502:  MOVLB  C
01504:  MOVWF  x87
01506:  MOVLW  08
01508:  MOVWF  x88
0150A:  MOVLB  0
0150C:  RCALL  0DC6
....................    
....................       spi_xfer(SPIPORT_3,addsress_array[0]);     
0150E:  MOVFF  C82,C87
01512:  MOVLW  08
01514:  MOVLB  C
01516:  MOVWF  x88
01518:  MOVLB  0
0151A:  RCALL  0DC6
....................       spi_xfer(SPIPORT_3,addsress_array[1]);     
0151C:  MOVFF  C83,C87
01520:  MOVLW  08
01522:  MOVLB  C
01524:  MOVWF  x88
01526:  MOVLB  0
01528:  RCALL  0DC6
....................       spi_xfer(SPIPORT_3,addsress_array[2]);     
0152A:  MOVFF  C84,C87
0152E:  MOVLW  08
01530:  MOVLB  C
01532:  MOVWF  x88
01534:  MOVLB  0
01536:  RCALL  0DC6
....................       spi_xfer(SPIPORT_3,addsress_array[3]);   
01538:  MOVFF  C85,C87
0153C:  MOVLW  08
0153E:  MOVLB  C
01540:  MOVWF  x88
01542:  MOVLB  0
01544:  RCALL  0DC6
....................        
....................       //byteNo=0; 
....................       counter=0; // the number of bytes written in pageNoCounter loop 
01546:  MOVLB  C
01548:  CLRF   x7F
....................       while ((counter<256)&&(byteNo<size))  
0154A:  MOVF   x76,W
0154C:  SUBWF  x70,W
0154E:  BNC   160C
01550:  BNZ   1568
01552:  MOVF   x75,W
01554:  SUBWF  x6F,W
01556:  BNC   160C
01558:  BNZ   1568
0155A:  MOVF   x74,W
0155C:  SUBWF  x6E,W
0155E:  BNC   160C
01560:  BNZ   1568
01562:  MOVF   x6D,W
01564:  SUBWF  x73,W
01566:  BC    160C
....................       { 
....................          //fprintf(debugPort,"small loop...\r\n "); 
....................          spi_xfer(SPIPORT_3,data[byteNo]); 
01568:  MOVF   x71,W
0156A:  ADDWF  x73,W
0156C:  MOVWF  FE9
0156E:  MOVF   x72,W
01570:  ADDWFC x74,W
01572:  MOVWF  FEA
01574:  MOVFF  FEF,C87
01578:  MOVLW  08
0157A:  MOVWF  x88
0157C:  MOVLB  0
0157E:  RCALL  0DC6
....................          if (counter%16==0) {fprintf(debugPort,"\r\n");} 
01580:  MOVLB  C
01582:  MOVF   x7F,W
01584:  ANDLW  0F
01586:  BNZ   15B8
01588:  CLRF   1B
0158A:  BTFSC  FF2.7
0158C:  BSF    1B.7
0158E:  BCF    FF2.7
01590:  MOVLW  0D
01592:  MOVWF  x9E
01594:  MOVLB  0
01596:  CALL   054A
0159A:  BTFSC  1B.7
0159C:  BSF    FF2.7
0159E:  CLRF   1B
015A0:  BTFSC  FF2.7
015A2:  BSF    1B.7
015A4:  BCF    FF2.7
015A6:  MOVLW  0A
015A8:  MOVLB  C
015AA:  MOVWF  x9E
015AC:  MOVLB  0
015AE:  CALL   054A
015B2:  BTFSC  1B.7
015B4:  BSF    FF2.7
015B6:  MOVLB  C
....................          fprintf(debugPort,"%X ",data[byteNo]); 
015B8:  MOVF   x71,W
015BA:  ADDWF  x73,W
015BC:  MOVWF  FE9
015BE:  MOVF   x72,W
015C0:  ADDWFC x74,W
015C2:  MOVWF  FEA
015C4:  MOVFF  FEF,C9A
015C8:  CLRF   1B
015CA:  BTFSC  FF2.7
015CC:  BSF    1B.7
015CE:  BCF    FF2.7
015D0:  MOVLW  37
015D2:  MOVWF  x9B
015D4:  MOVLB  0
015D6:  CALL   05E8
015DA:  BTFSC  1B.7
015DC:  BSF    FF2.7
015DE:  CLRF   1B
015E0:  BTFSC  FF2.7
015E2:  BSF    1B.7
015E4:  BCF    FF2.7
015E6:  MOVLW  20
015E8:  MOVLB  C
015EA:  MOVWF  x9E
015EC:  MOVLB  0
015EE:  CALL   054A
015F2:  BTFSC  1B.7
015F4:  BSF    FF2.7
....................          byteNo++; 
015F6:  MOVLW  01
015F8:  MOVLB  C
015FA:  ADDWF  x73,F
015FC:  BTFSC  FD8.0
015FE:  INCF   x74,F
01600:  BTFSC  FD8.2
01602:  INCF   x75,F
01604:  BTFSC  FD8.2
01606:  INCF   x76,F
....................          counter++; 
01608:  INCF   x7F,F
0160A:  BRA    154A
0160C:  CLRF   1B
0160E:  BTFSC  FF2.7
01610:  BSF    1B.7
01612:  BCF    FF2.7
....................       } 
....................    fprintf(debugPort,"\r\n"); 
01614:  MOVLW  0D
01616:  MOVWF  x9E
01618:  MOVLB  0
0161A:  CALL   054A
0161E:  BTFSC  1B.7
01620:  BSF    FF2.7
01622:  CLRF   1B
01624:  BTFSC  FF2.7
01626:  BSF    1B.7
01628:  BCF    FF2.7
0162A:  MOVLW  0A
0162C:  MOVLB  C
0162E:  MOVWF  x9E
01630:  MOVLB  0
01632:  CALL   054A
01636:  BTFSC  1B.7
01638:  BSF    FF2.7
....................    //writing_address=writing_address+256; 
....................    writing_address=writing_address+counter; 
0163A:  MOVLB  C
0163C:  MOVF   x7F,W
0163E:  ADDWF  x69,F
01640:  MOVLW  00
01642:  ADDWFC x6A,F
01644:  ADDWFC x6B,F
01646:  ADDWFC x6C,F
....................    //fprintf(debugPort,"counter= %lX\r\n",counter); 
....................    //fprintf(debugPort,"Next writing_address=%lX \r\n",writing_address); 
....................    pageNoCounter++; 
01648:  MOVLW  01
0164A:  ADDWF  x7B,F
0164C:  BTFSC  FD8.0
0164E:  INCF   x7C,F
01650:  BTFSC  FD8.2
01652:  INCF   x7D,F
01654:  BTFSC  FD8.2
01656:  INCF   x7E,F
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
01658:  BCF    F92.2
0165A:  BSF    F89.2
....................    delay_ms(writing_delay);   
0165C:  MOVFF  1D,C86
01660:  MOVLB  0
01662:  RCALL  0EE2
....................    WRITE_DISABLE4(); 
01664:  RCALL  1134
01666:  MOVLB  C
01668:  BRA    14C2
....................    } 
....................    return writing_address; 
0166A:  MOVFF  C69,00
0166E:  MOVFF  C6A,01
01672:  MOVFF  C6B,02
01676:  MOVFF  C6C,03
0167A:  BRA    1688
....................    while(isBusy()); 
0167C:  MOVLB  0
0167E:  CALL   0E02
01682:  MOVF   01,F
01684:  BNZ   167E
01686:  MOVLB  C
01688:  MOVLB  0
0168A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... INT32 WRITE_DATA_N_DUMMY_BYTE4(INT32 writing_address,int32 size) //read and send the specified data 
*
051DC:  MOVLB  C
051DE:  CLRF   x62
051E0:  CLRF   x61
051E2:  CLRF   x60
051E4:  CLRF   x5F
051E6:  CLRF   x66
051E8:  CLRF   x65
051EA:  CLRF   x64
051EC:  CLRF   x63
051EE:  CLRF   x6A
051F0:  CLRF   x69
051F2:  CLRF   x68
051F4:  CLRF   x67
051F6:  CLRF   01
051F8:  MOVLW  00
051FA:  BSF    FD8.0
051FC:  SUBFWB x57,W
051FE:  MOVWF  x6C
05200:  MOVLW  01
05202:  SUBFWB 01,W
05204:  MOVWF  x6D
.................... { 
....................    int32 byteNo=0; 
....................    int32 pageNo=0; 
....................    int32 pageNoCounter=0; 
....................    int8 counter; 
....................    int16 rest = 256-(writing_address % 256); 
....................  
....................    int8 addsress_array[4]; 
....................     
....................    addsress_array[0]  = (int8)((writing_address>>24) & 0xFF);       
05206:  MOVFF  C5A,C6E
....................    addsress_array[1]  = (int8)((writing_address>>16) & 0xFF);       
0520A:  MOVFF  C59,C6F
....................    addsress_array[2]  = (int8)((writing_address>>8) & 0xFF);        
0520E:  MOVFF  C58,C70
....................    addsress_array[3]  = (int8)((writing_address) & 0xFF);           
05212:  MOVFF  C57,C71
....................     
....................    if(showDebug) fprintf(debugPort,"Writing...\r\n "); 
05216:  BTFSS  1E.0
05218:  BRA    523A
0521A:  MOVLW  A4
0521C:  MOVWF  FF6
0521E:  MOVLW  01
05220:  MOVWF  FF7
05222:  MOVLW  00
05224:  MOVWF  FF8
05226:  CLRF   1B
05228:  BTFSC  FF2.7
0522A:  BSF    1B.7
0522C:  BCF    FF2.7
0522E:  MOVLB  0
05230:  CALL   0590
05234:  BTFSC  1B.7
05236:  BSF    FF2.7
05238:  MOVLB  C
.................... if ((writing_address % 256)!=0) 
0523A:  MOVFF  C57,C72
0523E:  CLRF   x73
05240:  CLRF   x74
05242:  CLRF   x75
05244:  MOVF   x72,F
05246:  BNZ   5256
05248:  MOVF   x73,F
0524A:  BNZ   5256
0524C:  MOVF   x74,F
0524E:  BNZ   5256
05250:  MOVF   x75,F
05252:  BTFSC  FD8.2
05254:  BRA    53D4
.................... { 
....................    WRITE_ENABLE4(); 
05256:  MOVLB  0
05258:  CALL   0FD0
....................    output_low(CS_PIN_3);                                                         //lower the CS PIN 
0525C:  BCF    F92.2
0525E:  BCF    F89.2
....................    spi_xfer(SPIPORT_3,WRITE4_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
05260:  MOVLW  12
05262:  MOVLB  C
05264:  MOVWF  x87
05266:  MOVLW  08
05268:  MOVWF  x88
0526A:  MOVLB  0
0526C:  CALL   0DC6
....................    
....................    spi_xfer(SPIPORT_3,addsress_array[0]);     
05270:  MOVFF  C6E,C87
05274:  MOVLW  08
05276:  MOVLB  C
05278:  MOVWF  x88
0527A:  MOVLB  0
0527C:  CALL   0DC6
....................    spi_xfer(SPIPORT_3,addsress_array[1]);     
05280:  MOVFF  C6F,C87
05284:  MOVLW  08
05286:  MOVLB  C
05288:  MOVWF  x88
0528A:  MOVLB  0
0528C:  CALL   0DC6
....................    spi_xfer(SPIPORT_3,addsress_array[2]);     
05290:  MOVFF  C70,C87
05294:  MOVLW  08
05296:  MOVLB  C
05298:  MOVWF  x88
0529A:  MOVLB  0
0529C:  CALL   0DC6
....................    spi_xfer(SPIPORT_3,addsress_array[3]);    
052A0:  MOVFF  C71,C87
052A4:  MOVLW  08
052A6:  MOVLB  C
052A8:  MOVWF  x88
052AA:  MOVLB  0
052AC:  CALL   0DC6
....................    while ((byteNo<rest)&&(pageNoCounter*256+byteNo<size)) 
052B0:  MOVLB  C
052B2:  MOVF   x62,F
052B4:  BTFSS  FD8.2
052B6:  BRA    53B2
052B8:  MOVF   x61,F
052BA:  BTFSS  FD8.2
052BC:  BRA    53B2
052BE:  MOVF   x60,W
052C0:  SUBWF  x6D,W
052C2:  BTFSS  FD8.0
052C4:  BRA    53B2
052C6:  BNZ   52D0
052C8:  MOVF   x6C,W
052CA:  SUBWF  x5F,W
052CC:  BTFSC  FD8.0
052CE:  BRA    53B2
052D0:  MOVFF  C69,C75
052D4:  MOVFF  C68,C74
052D8:  MOVFF  C67,C73
052DC:  CLRF   x72
052DE:  MOVF   x5F,W
052E0:  ADDWF  x72,F
052E2:  MOVF   x60,W
052E4:  ADDWFC x73,F
052E6:  MOVF   x61,W
052E8:  ADDWFC x74,F
052EA:  MOVF   x62,W
052EC:  ADDWFC x75,F
052EE:  MOVF   x75,W
052F0:  SUBWF  x5E,W
052F2:  BNC   53B2
052F4:  BNZ   530C
052F6:  MOVF   x74,W
052F8:  SUBWF  x5D,W
052FA:  BNC   53B2
052FC:  BNZ   530C
052FE:  MOVF   x73,W
05300:  SUBWF  x5C,W
05302:  BNC   53B2
05304:  BNZ   530C
05306:  MOVF   x5B,W
05308:  SUBWF  x72,W
0530A:  BC    53B2
....................    { 
....................       spi_xfer(SPIPORT_3,byteNo);  
0530C:  MOVFF  C5F,C87
05310:  MOVLW  08
05312:  MOVWF  x88
05314:  MOVLB  0
05316:  CALL   0DC6
....................       if(showDebug) 
0531A:  BTFSS  1E.0
0531C:  BRA    539E
....................       { 
....................          if (byteNo%16==0) {fprintf(debugPort,"\r\n");} 
0531E:  MOVLB  C
05320:  MOVF   x5F,W
05322:  ANDLW  0F
05324:  MOVWF  x72
05326:  CLRF   x73
05328:  CLRF   x74
0532A:  CLRF   x75
0532C:  MOVF   x72,F
0532E:  BNZ   536C
05330:  MOVF   x73,F
05332:  BNZ   536C
05334:  MOVF   x74,F
05336:  BNZ   536C
05338:  MOVF   x75,F
0533A:  BNZ   536C
0533C:  CLRF   1B
0533E:  BTFSC  FF2.7
05340:  BSF    1B.7
05342:  BCF    FF2.7
05344:  MOVLW  0D
05346:  MOVWF  x9E
05348:  MOVLB  0
0534A:  CALL   054A
0534E:  BTFSC  1B.7
05350:  BSF    FF2.7
05352:  CLRF   1B
05354:  BTFSC  FF2.7
05356:  BSF    1B.7
05358:  BCF    FF2.7
0535A:  MOVLW  0A
0535C:  MOVLB  C
0535E:  MOVWF  x9E
05360:  MOVLB  0
05362:  CALL   054A
05366:  BTFSC  1B.7
05368:  BSF    FF2.7
0536A:  MOVLB  C
0536C:  CLRF   1B
0536E:  BTFSC  FF2.7
05370:  BSF    1B.7
05372:  BCF    FF2.7
....................          fprintf(debugPort,"%X ",byteNo); 
05374:  MOVFF  C5F,C9A
05378:  MOVLW  37
0537A:  MOVWF  x9B
0537C:  MOVLB  0
0537E:  CALL   05E8
05382:  BTFSC  1B.7
05384:  BSF    FF2.7
05386:  CLRF   1B
05388:  BTFSC  FF2.7
0538A:  BSF    1B.7
0538C:  BCF    FF2.7
0538E:  MOVLW  20
05390:  MOVLB  C
05392:  MOVWF  x9E
05394:  MOVLB  0
05396:  CALL   054A
0539A:  BTFSC  1B.7
0539C:  BSF    FF2.7
....................       } 
....................       byteNo++; 
0539E:  MOVLW  01
053A0:  MOVLB  C
053A2:  ADDWF  x5F,F
053A4:  BTFSC  FD8.0
053A6:  INCF   x60,F
053A8:  BTFSC  FD8.2
053AA:  INCF   x61,F
053AC:  BTFSC  FD8.2
053AE:  INCF   x62,F
053B0:  BRA    52B2
....................    } 
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
053B2:  BCF    F92.2
053B4:  BSF    F89.2
....................    delay_ms(writing_delay);   
053B6:  MOVFF  1D,C86
053BA:  MOVLB  0
053BC:  CALL   0EE2
....................    WRITE_DISABLE4(); 
053C0:  CALL   1134
....................  
....................    //fprintf(debugPort,"Writing address was: %lX \r\n",(writing_address)); 
....................    //fprintf(debugPort,"data size was: %ld \r\n",(size)); 
....................    writing_address=writing_address+rest; 
053C4:  MOVLB  C
053C6:  MOVF   x6C,W
053C8:  ADDWF  x57,F
053CA:  MOVF   x6D,W
053CC:  ADDWFC x58,F
053CE:  MOVLW  00
053D0:  ADDWFC x59,F
053D2:  ADDWFC x5A,F
....................    //size=size-byteNo; 
....................    //fprintf(debugPort,"Writing address became: %lX \r\n\r\n",(writing_address)); 
....................    //fprintf(debugPort,"data size became: %ld \r\n",(size)); 
.................... }    
....................     
....................    pageNo=(int8)(size/256); 
053D4:  CLRF   x66
053D6:  CLRF   x65
053D8:  CLRF   x64
053DA:  MOVFF  C5C,C63
....................    //fprintf(debugPort,"number of pages: %u\r\n",(int8)pageNo); 
....................     
....................    pageNoCounter=0; 
053DE:  CLRF   x6A
053E0:  CLRF   x69
053E2:  CLRF   x68
053E4:  CLRF   x67
....................    while (pageNoCounter<=pageNo) 
053E6:  MOVF   x6A,W
053E8:  SUBWF  x66,W
053EA:  BTFSS  FD8.0
053EC:  BRA    55D2
053EE:  BNZ   540C
053F0:  MOVF   x69,W
053F2:  SUBWF  x65,W
053F4:  BTFSS  FD8.0
053F6:  BRA    55D2
053F8:  BNZ   540C
053FA:  MOVF   x68,W
053FC:  SUBWF  x64,W
053FE:  BTFSS  FD8.0
05400:  BRA    55D2
05402:  BNZ   540C
05404:  MOVF   x67,W
05406:  SUBWF  x63,W
05408:  BTFSS  FD8.0
0540A:  BRA    55D2
....................    { 
....................       //fprintf(debugPort,"big loop...\r\n "); 
....................       addsress_array[0]  = (int8)((writing_address>>24) & 0xFF); 
0540C:  MOVFF  C5A,C6E
....................       addsress_array[1]  = (int8)((writing_address>>16) & 0xFF);       
05410:  MOVFF  C59,C6F
....................       addsress_array[2]  = (int8)((writing_address>>8) & 0xFF);        
05414:  MOVFF  C58,C70
....................       addsress_array[3]  = (int8)((writing_address) & 0xFF);     
05418:  MOVFF  C57,C71
....................        
....................       WRITE_ENABLE4(); 
0541C:  MOVLB  0
0541E:  CALL   0FD0
....................       output_low(CS_PIN_3);                                                         //lower the CS PIN 
05422:  BCF    F92.2
05424:  BCF    F89.2
....................       spi_xfer(SPIPORT_3,WRITE4_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
05426:  MOVLW  12
05428:  MOVLB  C
0542A:  MOVWF  x87
0542C:  MOVLW  08
0542E:  MOVWF  x88
05430:  MOVLB  0
05432:  CALL   0DC6
....................    
....................       spi_xfer(SPIPORT_3,addsress_array[0]);     
05436:  MOVFF  C6E,C87
0543A:  MOVLW  08
0543C:  MOVLB  C
0543E:  MOVWF  x88
05440:  MOVLB  0
05442:  CALL   0DC6
....................       spi_xfer(SPIPORT_3,addsress_array[1]);     
05446:  MOVFF  C6F,C87
0544A:  MOVLW  08
0544C:  MOVLB  C
0544E:  MOVWF  x88
05450:  MOVLB  0
05452:  CALL   0DC6
....................       spi_xfer(SPIPORT_3,addsress_array[2]);     
05456:  MOVFF  C70,C87
0545A:  MOVLW  08
0545C:  MOVLB  C
0545E:  MOVWF  x88
05460:  MOVLB  0
05462:  CALL   0DC6
....................       spi_xfer(SPIPORT_3,addsress_array[3]);   
05466:  MOVFF  C71,C87
0546A:  MOVLW  08
0546C:  MOVLB  C
0546E:  MOVWF  x88
05470:  MOVLB  0
05472:  CALL   0DC6
....................        
....................       //byteNo=0; 
....................       counter=0; 
05476:  MOVLB  C
05478:  CLRF   x6B
....................       while ((counter<256)&&(pageNoCounter*256+byteNo<size)) 
0547A:  MOVFF  C69,C75
0547E:  MOVFF  C68,C74
05482:  MOVFF  C67,C73
05486:  CLRF   x72
05488:  MOVF   x5F,W
0548A:  ADDWF  x72,F
0548C:  MOVF   x60,W
0548E:  ADDWFC x73,F
05490:  MOVF   x61,W
05492:  ADDWFC x74,F
05494:  MOVF   x62,W
05496:  ADDWFC x75,F
05498:  MOVF   x75,W
0549A:  SUBWF  x5E,W
0549C:  BTFSS  FD8.0
0549E:  BRA    55A0
054A0:  BNZ   54BC
054A2:  MOVF   x74,W
054A4:  SUBWF  x5D,W
054A6:  BTFSS  FD8.0
054A8:  BRA    55A0
054AA:  BNZ   54BC
054AC:  MOVF   x73,W
054AE:  SUBWF  x5C,W
054B0:  BTFSS  FD8.0
054B2:  BRA    55A0
054B4:  BNZ   54BC
054B6:  MOVF   x5B,W
054B8:  SUBWF  x72,W
054BA:  BC    55A0
....................       { 
....................          //fprintf(debugPort,"small loop...\r\n "); 
....................          spi_xfer(SPIPORT_3,pageNoCounter*256+byteNo); 
054BC:  MOVFF  C69,C75
054C0:  MOVFF  C68,C74
054C4:  MOVFF  C67,C73
054C8:  CLRF   x72
054CA:  MOVF   x5F,W
054CC:  ADDWF  x72,F
054CE:  MOVF   x60,W
054D0:  ADDWFC x73,F
054D2:  MOVF   x61,W
054D4:  ADDWFC x74,F
054D6:  MOVF   x62,W
054D8:  ADDWFC x75,F
054DA:  MOVFF  C72,C87
054DE:  MOVLW  08
054E0:  MOVWF  x88
054E2:  MOVLB  0
054E4:  CALL   0DC6
....................          if(showDebug) 
054E8:  BTFSS  1E.0
054EA:  BRA    558A
....................          { 
....................             if (byteNo%16==0) {fprintf(debugPort,"\r\n");} 
054EC:  MOVLB  C
054EE:  MOVF   x5F,W
054F0:  ANDLW  0F
054F2:  MOVWF  x72
054F4:  CLRF   x73
054F6:  CLRF   x74
054F8:  CLRF   x75
054FA:  MOVF   x72,F
054FC:  BNZ   553A
054FE:  MOVF   x73,F
05500:  BNZ   553A
05502:  MOVF   x74,F
05504:  BNZ   553A
05506:  MOVF   x75,F
05508:  BNZ   553A
0550A:  CLRF   1B
0550C:  BTFSC  FF2.7
0550E:  BSF    1B.7
05510:  BCF    FF2.7
05512:  MOVLW  0D
05514:  MOVWF  x9E
05516:  MOVLB  0
05518:  CALL   054A
0551C:  BTFSC  1B.7
0551E:  BSF    FF2.7
05520:  CLRF   1B
05522:  BTFSC  FF2.7
05524:  BSF    1B.7
05526:  BCF    FF2.7
05528:  MOVLW  0A
0552A:  MOVLB  C
0552C:  MOVWF  x9E
0552E:  MOVLB  0
05530:  CALL   054A
05534:  BTFSC  1B.7
05536:  BSF    FF2.7
05538:  MOVLB  C
....................             fprintf(debugPort,"%X ",pageNoCounter*256+byteNo); 
0553A:  MOVFF  C69,C75
0553E:  MOVFF  C68,C74
05542:  MOVFF  C67,C73
05546:  CLRF   x72
05548:  MOVF   x5F,W
0554A:  ADDWF  x72,F
0554C:  MOVF   x60,W
0554E:  ADDWFC x73,F
05550:  MOVF   x61,W
05552:  ADDWFC x74,F
05554:  MOVF   x62,W
05556:  ADDWFC x75,F
05558:  CLRF   1B
0555A:  BTFSC  FF2.7
0555C:  BSF    1B.7
0555E:  BCF    FF2.7
05560:  MOVFF  C72,C9A
05564:  MOVLW  37
05566:  MOVWF  x9B
05568:  MOVLB  0
0556A:  CALL   05E8
0556E:  BTFSC  1B.7
05570:  BSF    FF2.7
05572:  CLRF   1B
05574:  BTFSC  FF2.7
05576:  BSF    1B.7
05578:  BCF    FF2.7
0557A:  MOVLW  20
0557C:  MOVLB  C
0557E:  MOVWF  x9E
05580:  MOVLB  0
05582:  CALL   054A
05586:  BTFSC  1B.7
05588:  BSF    FF2.7
....................          } 
....................          byteNo++; 
0558A:  MOVLW  01
0558C:  MOVLB  C
0558E:  ADDWF  x5F,F
05590:  BTFSC  FD8.0
05592:  INCF   x60,F
05594:  BTFSC  FD8.2
05596:  INCF   x61,F
05598:  BTFSC  FD8.2
0559A:  INCF   x62,F
....................          counter++; 
0559C:  INCF   x6B,F
0559E:  BRA    547A
....................       } 
....................    //writing_address=writing_address+256; 
....................    writing_address=writing_address+counter; 
055A0:  MOVF   x6B,W
055A2:  ADDWF  x57,F
055A4:  MOVLW  00
055A6:  ADDWFC x58,F
055A8:  ADDWFC x59,F
055AA:  ADDWFC x5A,F
....................    pageNoCounter++; 
055AC:  MOVLW  01
055AE:  ADDWF  x67,F
055B0:  BTFSC  FD8.0
055B2:  INCF   x68,F
055B4:  BTFSC  FD8.2
055B6:  INCF   x69,F
055B8:  BTFSC  FD8.2
055BA:  INCF   x6A,F
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
055BC:  BCF    F92.2
055BE:  BSF    F89.2
....................    delay_ms(writing_delay);   
055C0:  MOVFF  1D,C86
055C4:  MOVLB  0
055C6:  CALL   0EE2
....................    WRITE_DISABLE4(); 
055CA:  CALL   1134
055CE:  MOVLB  C
055D0:  BRA    53E6
....................    } 
....................    return writing_address; 
055D2:  MOVFF  C57,00
055D6:  MOVFF  C58,01
055DA:  MOVFF  C59,02
055DE:  MOVFF  C5A,03
055E2:  MOVLB  0
055E4:  GOTO   5718 (RETURN)
.................... } 
....................  
....................  
.................... INT32 WRITE_DATA_N_DUMMY_BYTE4_show(INT32 writing_address,int32 size)  
.................... { 
....................    fprintf(debugPort,"Writing_address=%lX should end in %lX \r\n",writing_address,writing_address+size-1); 
....................    int32 byteNo=0; 
....................    int32 pageNo=0; 
....................    int32 pageNoCounter=0; 
....................    int16 counter; 
....................    int16 rest = 256-(writing_address % 256); 
....................    fprintf(debugPort,"rest= %lu\r\n",rest); 
....................  
....................    int8 addsress_array[4]; 
....................     
....................    addsress_array[0]  = (int8)((writing_address>>24) & 0xFF);       
....................    addsress_array[1]  = (int8)((writing_address>>16) & 0xFF);       
....................    addsress_array[2]  = (int8)((writing_address>>8) & 0xFF);        
....................    addsress_array[3]  = (int8)((writing_address) & 0xFF);           
....................     
....................    if ((writing_address % 256)!=0) 
....................    { 
....................       while ((byteNo<rest)&&(pageNoCounter*256+byteNo<size)) // do we need (pageNoCounter*256+byteNo<size) ????????? 
....................       { 
....................          fprintf(debugPort,"\r\n byteNo=%X ",byteNo); 
....................          byteNo++; 
....................       } 
....................       fprintf(debugPort,"\r\n"); 
....................       fprintf(debugPort,"Wrote the rest which is =%lu\r\n",rest); 
....................  
....................     
....................       fprintf(debugPort,"Writing address was: %lX \r\n",(writing_address)); 
....................       //fprintf(debugPort,"data size was: %ld \r\n",(size)); 
....................       writing_address=writing_address+byteNo; 
....................       fprintf(debugPort,"writing_address became= %lX\r\n",writing_address); 
....................       //size=size-byteNo; 
....................       //fprintf(debugPort,"Writing address became: %lX \r\n\r\n",(writing_address)); 
....................       //fprintf(debugPort,"data size became: %ld \r\n",(size)); 
....................    }    
....................     
....................     
....................    //size=size-byteNo; 
....................    pageNo=(int8)(size/256); 
....................    fprintf(debugPort,"number of pages: %u\r\n",(int8)pageNo); 
....................     
....................    pageNoCounter=0; 
....................    fprintf(debugPort,"pageNoCounter= %lX ",pageNoCounter); 
....................    while (pageNoCounter<=pageNo) //it is <= to run it one more time 
....................    { 
....................       fprintf(debugPort,"big loop...pageNoCounter=%lu \r\n ",pageNoCounter); 
....................       addsress_array[0]  = (int8)((writing_address>>24) & 0xFF); 
....................       addsress_array[1]  = (int8)((writing_address>>16) & 0xFF);       
....................       addsress_array[2]  = (int8)((writing_address>>8) & 0xFF);        
....................       addsress_array[3]  = (int8)((writing_address) & 0xFF);     
....................        
....................       //byteNo=0; 
....................       counter=0; // the number of bytes written in pageNoCounter loop 
....................       while ((counter<256)&&(byteNo<size)) // do we need pageNoCounter*256???? 
....................       { 
....................          fprintf(debugPort,"\r\npageNoCounter=%lX pageNoCounter*256+byteNo=%lX byteNo=%lX counter=%lX",pageNoCounter,pageNoCounter*256+byteNo,byteNo,counter); 
....................          //fprintf(debugPort,"\r\n                   byteNo=%lX counter=%lX",byteNo,counter); 
....................          byteNo++; 
....................          counter++; 
....................       } 
....................    fprintf(debugPort,"\r\n"); 
....................    //writing_address=writing_address+256; 
....................       fprintf(debugPort,"Writing address was: %lX \r\n",(writing_address)); 
....................    writing_address=writing_address+counter; 
....................       fprintf(debugPort,"writing_address became= %lX\r\n",writing_address); 
....................    //fprintf(debugPort,"counter= %lX\r\n",counter); 
....................    //fprintf(debugPort,"Next writing_address=%lX \r\n",writing_address); 
....................    pageNoCounter++; 
....................  
....................    } 
....................    return writing_address; 
....................  
.................... } 
....................  
.................... #include<String.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
059DA:  MOVFF  C50,C54
059DE:  MOVFF  C4F,C53
059E2:  MOVFF  C54,03
059E6:  MOVLB  C
059E8:  MOVFF  C53,FE9
059EC:  MOVFF  C54,FEA
059F0:  MOVF   FEF,F
059F2:  BZ    5A00
059F4:  INCF   x53,F
059F6:  BTFSC  FD8.2
059F8:  INCF   x54,F
059FA:  MOVLB  0
059FC:  BRA    59E2
059FE:  MOVLB  C
....................    while(*s2 != '\0') 
05A00:  MOVFF  C52,03
05A04:  MOVFF  C51,FE9
05A08:  MOVFF  C52,FEA
05A0C:  MOVF   FEF,F
05A0E:  BZ    5A36
....................    { 
....................       *s = *s2; 
05A10:  MOVFF  C51,FE9
05A14:  MOVFF  C52,FEA
05A18:  MOVFF  FEF,C57
05A1C:  MOVFF  C54,FEA
05A20:  MOVFF  C53,FE9
05A24:  MOVFF  C57,FEF
....................       ++s; 
05A28:  INCF   x53,F
05A2A:  BTFSC  FD8.2
05A2C:  INCF   x54,F
....................       ++s2; 
05A2E:  INCF   x51,F
05A30:  BTFSC  FD8.2
05A32:  INCF   x52,F
05A34:  BRA    5A00
....................    } 
....................  
....................    *s = '\0'; 
05A36:  MOVFF  C53,FE9
05A3A:  MOVFF  C54,FEA
05A3E:  CLRF   FEF
....................    return(s1); 
05A40:  MOVFF  C4F,01
05A44:  MOVFF  C50,02
05A48:  MOVLB  0
05A4A:  GOTO   6FF2 (RETURN)
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
021A4:  MOVFF  C56,C5C
021A8:  MOVFF  C55,C5B
021AC:  MOVFF  C58,C5E
021B0:  MOVFF  C57,C5D
021B4:  MOVLB  C
021B6:  MOVF   x5A,F
021B8:  BNZ   21C0
021BA:  MOVF   x59,W
021BC:  SUBLW  00
021BE:  BC    2220
.................... { 
....................    if(*su1!=*su2) 
021C0:  MOVFF  C5B,FE9
021C4:  MOVFF  C5C,FEA
021C8:  MOVFF  FEF,C5F
021CC:  MOVFF  C5E,03
021D0:  MOVFF  C5D,FE9
021D4:  MOVFF  C5E,FEA
021D8:  MOVF   FEF,W
021DA:  SUBWF  x5F,W
021DC:  BZ    220A
....................       return ((*su1<*su2)?-1:1); 
021DE:  MOVFF  C5C,03
021E2:  MOVFF  C5B,FE9
021E6:  MOVFF  03,FEA
021EA:  MOVFF  FEF,C5F
021EE:  MOVFF  C5E,03
021F2:  MOVFF  C5D,FE9
021F6:  MOVFF  C5E,FEA
021FA:  MOVF   FEF,W
021FC:  SUBWF  x5F,W
021FE:  BC    2204
02200:  MOVLW  FF
02202:  BRA    2206
02204:  MOVLW  01
02206:  MOVWF  01
02208:  BRA    2224
0220A:  INCF   x5B,F
0220C:  BTFSC  FD8.2
0220E:  INCF   x5C,F
02210:  INCF   x5D,F
02212:  BTFSC  FD8.2
02214:  INCF   x5E,F
02216:  MOVF   x59,W
02218:  BTFSC  FD8.2
0221A:  DECF   x5A,F
0221C:  DECF   x59,F
0221E:  BRA    21B6
.................... } 
.................... return 0; 
02220:  MOVLW  00
02222:  MOVWF  01
02224:  MOVLB  0
02226:  RETURN 0
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
06042:  MOVLB  C
06044:  MOVF   x5E,F
06046:  BNZ   604C
06048:  MOVF   x5F,F
0604A:  BZ    60D0
....................       if (*s1 != *s2) 
0604C:  MOVFF  C5A,FE9
06050:  MOVFF  C5B,FEA
06054:  MOVFF  FEF,C60
06058:  MOVFF  C5D,03
0605C:  MOVFF  C5C,FE9
06060:  MOVFF  C5D,FEA
06064:  MOVF   FEF,W
06066:  SUBWF  x60,W
06068:  BZ    6098
....................          return((*s1 <*s2) ? -1: 1); 
0606A:  MOVFF  C5B,03
0606E:  MOVFF  C5A,FE9
06072:  MOVFF  03,FEA
06076:  MOVFF  FEF,C60
0607A:  MOVFF  C5D,03
0607E:  MOVFF  C5C,FE9
06082:  MOVFF  C5D,FEA
06086:  MOVF   FEF,W
06088:  SUBWF  x60,W
0608A:  BC    6090
0608C:  MOVLW  FF
0608E:  BRA    6092
06090:  MOVLW  01
06092:  MOVWF  01
06094:  BRA    60D4
06096:  BRA    60AE
....................       else if (*s1 == '\0') 
06098:  MOVFF  C5B,03
0609C:  MOVFF  C5A,FE9
060A0:  MOVFF  C5B,FEA
060A4:  MOVF   FEF,F
060A6:  BNZ   60AE
....................          return(0); 
060A8:  MOVLW  00
060AA:  MOVWF  01
060AC:  BRA    60D4
060AE:  MOVFF  C5B,03
060B2:  MOVF   x5A,W
060B4:  INCF   x5A,F
060B6:  BTFSC  FD8.2
060B8:  INCF   x5B,F
060BA:  MOVFF  C5D,03
060BE:  MOVF   x5C,W
060C0:  INCF   x5C,F
060C2:  BTFSC  FD8.2
060C4:  INCF   x5D,F
060C6:  MOVF   x5E,W
060C8:  BTFSC  FD8.2
060CA:  DECF   x5F,F
060CC:  DECF   x5E,F
060CE:  BRA    6044
....................    return(0); 
060D0:  MOVLW  00
060D2:  MOVWF  01
060D4:  MOVLB  0
060D6:  RETURN 0
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
05B26:  MOVFF  C66,C68
05B2A:  MOVFF  C65,C67
05B2E:  MOVFF  C68,03
05B32:  MOVLB  C
05B34:  MOVFF  C67,FE9
05B38:  MOVFF  C68,FEA
05B3C:  MOVF   FEF,F
05B3E:  BZ    5B4C
05B40:  INCF   x67,F
05B42:  BTFSC  FD8.2
05B44:  INCF   x68,F
05B46:  MOVLB  0
05B48:  BRA    5B2E
05B4A:  MOVLB  C
....................    return(sc - s); 
05B4C:  MOVF   x65,W
05B4E:  SUBWF  x67,W
05B50:  MOVWF  00
05B52:  MOVF   x66,W
05B54:  SUBWFB x68,W
05B56:  MOVWF  03
05B58:  MOVFF  00,01
05B5C:  MOVWF  02
05B5E:  MOVLB  0
05B60:  GOTO   5CE8 (RETURN)
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
.................... #include<math.h>  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
027E0:  MOVLB  C
027E2:  BCF    x85.0
....................    y = x; 
027E4:  MOVFF  C79,C7E
027E8:  MOVFF  C78,C7D
027EC:  MOVFF  C77,C7C
027F0:  MOVFF  C76,C7B
....................  
....................    if (x < 0) 
027F4:  MOVFF  C79,C89
027F8:  MOVFF  C78,C88
027FC:  MOVFF  C77,C87
02800:  MOVFF  C76,C86
02804:  CLRF   x8D
02806:  CLRF   x8C
02808:  CLRF   x8B
0280A:  CLRF   x8A
0280C:  MOVLB  0
0280E:  RCALL  225E
02810:  BNC   281E
....................    { 
....................       s = 1; 
02812:  MOVLB  C
02814:  BSF    x85.0
....................       y = -y; 
02816:  MOVF   x7C,W
02818:  XORLW  80
0281A:  MOVWF  x7C
0281C:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
0281E:  MOVFF  C7E,C89
02822:  MOVFF  C7D,C88
02826:  MOVFF  C7C,C87
0282A:  MOVFF  C7B,C86
0282E:  MOVLB  C
02830:  CLRF   x8D
02832:  CLRF   x8C
02834:  CLRF   x8B
02836:  MOVLW  8E
02838:  MOVWF  x8A
0283A:  MOVLB  0
0283C:  RCALL  225E
0283E:  BC    2842
02840:  BNZ   2870
....................       res = (float32)(unsigned int16)y; 
02842:  MOVFF  C7E,C89
02846:  MOVFF  C7D,C88
0284A:  MOVFF  C7C,C87
0284E:  MOVFF  C7B,C86
02852:  RCALL  2436
02854:  MOVFF  02,C8B
02858:  MOVFF  01,C8A
0285C:  RCALL  2228
0285E:  MOVFF  03,C82
02862:  MOVFF  02,C81
02866:  MOVFF  01,C80
0286A:  MOVFF  00,C7F
0286E:  BRA    29FE
....................  
....................  else if (y < 10000000.0) 
02870:  MOVFF  C7E,C89
02874:  MOVFF  C7D,C88
02878:  MOVFF  C7C,C87
0287C:  MOVFF  C7B,C86
02880:  MOVLW  80
02882:  MOVLB  C
02884:  MOVWF  x8D
02886:  MOVLW  96
02888:  MOVWF  x8C
0288A:  MOVLW  18
0288C:  MOVWF  x8B
0288E:  MOVLW  96
02890:  MOVWF  x8A
02892:  MOVLB  0
02894:  RCALL  225E
02896:  BTFSS  FD8.0
02898:  BRA    29EE
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
0289A:  MOVFF  C7E,C89
0289E:  MOVFF  C7D,C88
028A2:  MOVFF  C7C,C87
028A6:  MOVFF  C7B,C86
028AA:  MOVLB  C
028AC:  CLRF   x8D
028AE:  CLRF   x8C
028B0:  CLRF   x8B
028B2:  MOVLW  70
028B4:  MOVWF  x8A
028B6:  MOVLB  0
028B8:  RCALL  2472
028BA:  MOVFF  03,C89
028BE:  MOVFF  02,C88
028C2:  MOVFF  01,C87
028C6:  MOVFF  00,C86
028CA:  RCALL  2436
028CC:  MOVFF  02,C84
028D0:  MOVFF  01,C83
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
028D4:  MOVFF  C7E,C89
028D8:  MOVFF  C7D,C88
028DC:  MOVFF  C7C,C87
028E0:  MOVFF  C7B,C86
028E4:  MOVLB  C
028E6:  CLRF   x8D
028E8:  CLRF   x8C
028EA:  CLRF   x8B
028EC:  MOVLW  70
028EE:  MOVWF  x8A
028F0:  MOVLB  0
028F2:  RCALL  2472
028F4:  MOVFF  03,C89
028F8:  MOVFF  02,C88
028FC:  MOVFF  01,C87
02900:  MOVFF  00,C86
02904:  MOVFF  C84,C8B
02908:  MOVFF  C83,C8A
0290C:  RCALL  2228
0290E:  BSF    FD8.1
02910:  MOVFF  C89,C8D
02914:  MOVFF  C88,C8C
02918:  MOVFF  C87,C8B
0291C:  MOVFF  C86,C8A
02920:  MOVFF  03,C91
02924:  MOVFF  02,C90
02928:  MOVFF  01,C8F
0292C:  MOVFF  00,C8E
02930:  RCALL  2568
02932:  MOVLB  C
02934:  CLRF   x89
02936:  CLRF   x88
02938:  CLRF   x87
0293A:  MOVLW  8E
0293C:  MOVWF  x86
0293E:  MOVFF  03,C8D
02942:  MOVFF  02,C8C
02946:  MOVFF  01,C8B
0294A:  MOVFF  00,C8A
0294E:  MOVLB  0
02950:  RCALL  2472
02952:  MOVFF  03,C7E
02956:  MOVFF  02,C7D
0295A:  MOVFF  01,C7C
0295E:  MOVFF  00,C7B
....................       res = 32768.0*(float32)l; 
02962:  MOVFF  C84,C8B
02966:  MOVFF  C83,C8A
0296A:  RCALL  2228
0296C:  MOVLB  C
0296E:  CLRF   x89
02970:  CLRF   x88
02972:  CLRF   x87
02974:  MOVLW  8E
02976:  MOVWF  x86
02978:  MOVFF  03,C8D
0297C:  MOVFF  02,C8C
02980:  MOVFF  01,C8B
02984:  MOVFF  00,C8A
02988:  MOVLB  0
0298A:  RCALL  2472
0298C:  MOVFF  03,C82
02990:  MOVFF  02,C81
02994:  MOVFF  01,C80
02998:  MOVFF  00,C7F
....................       res += (float32)(unsigned int16)y; 
0299C:  MOVFF  C7E,C89
029A0:  MOVFF  C7D,C88
029A4:  MOVFF  C7C,C87
029A8:  MOVFF  C7B,C86
029AC:  RCALL  2436
029AE:  MOVFF  02,C8B
029B2:  MOVFF  01,C8A
029B6:  RCALL  2228
029B8:  BCF    FD8.1
029BA:  MOVFF  C82,C8D
029BE:  MOVFF  C81,C8C
029C2:  MOVFF  C80,C8B
029C6:  MOVFF  C7F,C8A
029CA:  MOVFF  03,C91
029CE:  MOVFF  02,C90
029D2:  MOVFF  01,C8F
029D6:  MOVFF  00,C8E
029DA:  RCALL  2568
029DC:  MOVFF  03,C82
029E0:  MOVFF  02,C81
029E4:  MOVFF  01,C80
029E8:  MOVFF  00,C7F
....................    } 
029EC:  BRA    29FE
....................  
....................  else 
....................   res = y; 
029EE:  MOVFF  C7E,C82
029F2:  MOVFF  C7D,C81
029F6:  MOVFF  C7C,C80
029FA:  MOVFF  C7B,C7F
....................  
....................  y = y - (float32)(unsigned int16)y; 
029FE:  MOVFF  C7E,C89
02A02:  MOVFF  C7D,C88
02A06:  MOVFF  C7C,C87
02A0A:  MOVFF  C7B,C86
02A0E:  RCALL  2436
02A10:  MOVFF  02,C8B
02A14:  MOVFF  01,C8A
02A18:  RCALL  2228
02A1A:  BSF    FD8.1
02A1C:  MOVFF  C7E,C8D
02A20:  MOVFF  C7D,C8C
02A24:  MOVFF  C7C,C8B
02A28:  MOVFF  C7B,C8A
02A2C:  MOVFF  03,C91
02A30:  MOVFF  02,C90
02A34:  MOVFF  01,C8F
02A38:  MOVFF  00,C8E
02A3C:  RCALL  2568
02A3E:  MOVFF  03,C7E
02A42:  MOVFF  02,C7D
02A46:  MOVFF  01,C7C
02A4A:  MOVFF  00,C7B
....................  
....................  if (s) 
02A4E:  MOVLB  C
02A50:  BTFSS  x85.0
02A52:  BRA    2A5A
....................   res = -res; 
02A54:  MOVF   x80,W
02A56:  XORLW  80
02A58:  MOVWF  x80
....................  
....................  if (y != 0) 
02A5A:  MOVFF  C7E,C89
02A5E:  MOVFF  C7D,C88
02A62:  MOVFF  C7C,C87
02A66:  MOVFF  C7B,C86
02A6A:  CLRF   x8D
02A6C:  CLRF   x8C
02A6E:  CLRF   x8B
02A70:  CLRF   x8A
02A72:  MOVLB  0
02A74:  CALL   225E
02A78:  BZ    2AEE
....................  { 
....................   if (s == 1 && n == 0) 
02A7A:  MOVLB  C
02A7C:  BTFSS  x85.0
02A7E:  BRA    2AB6
02A80:  MOVF   x7A,F
02A82:  BNZ   2AB6
....................    res -= 1.0; 
02A84:  BSF    FD8.1
02A86:  MOVFF  C82,C8D
02A8A:  MOVFF  C81,C8C
02A8E:  MOVFF  C80,C8B
02A92:  MOVFF  C7F,C8A
02A96:  CLRF   x91
02A98:  CLRF   x90
02A9A:  CLRF   x8F
02A9C:  MOVLW  7F
02A9E:  MOVWF  x8E
02AA0:  MOVLB  0
02AA2:  RCALL  2568
02AA4:  MOVFF  03,C82
02AA8:  MOVFF  02,C81
02AAC:  MOVFF  01,C80
02AB0:  MOVFF  00,C7F
02AB4:  MOVLB  C
....................  
....................   if (s == 0 && n == 1) 
02AB6:  BTFSC  x85.0
02AB8:  BRA    2AF0
02ABA:  DECFSZ x7A,W
02ABC:  BRA    2AF0
....................    res += 1.0; 
02ABE:  BCF    FD8.1
02AC0:  MOVFF  C82,C8D
02AC4:  MOVFF  C81,C8C
02AC8:  MOVFF  C80,C8B
02ACC:  MOVFF  C7F,C8A
02AD0:  CLRF   x91
02AD2:  CLRF   x90
02AD4:  CLRF   x8F
02AD6:  MOVLW  7F
02AD8:  MOVWF  x8E
02ADA:  MOVLB  0
02ADC:  RCALL  2568
02ADE:  MOVFF  03,C82
02AE2:  MOVFF  02,C81
02AE6:  MOVFF  01,C80
02AEA:  MOVFF  00,C7F
02AEE:  MOVLB  C
....................  } 
....................  if (x == 0) 
02AF0:  MOVFF  C79,C89
02AF4:  MOVFF  C78,C88
02AF8:  MOVFF  C77,C87
02AFC:  MOVFF  C76,C86
02B00:  CLRF   x8D
02B02:  CLRF   x8C
02B04:  CLRF   x8B
02B06:  CLRF   x8A
02B08:  MOVLB  0
02B0A:  CALL   225E
02B0E:  BNZ   2B1C
....................     res = 0; 
02B10:  MOVLB  C
02B12:  CLRF   x82
02B14:  CLRF   x81
02B16:  CLRF   x80
02B18:  CLRF   x7F
02B1A:  MOVLB  0
....................  
....................  return (res); 
02B1C:  MOVFF  C7F,00
02B20:  MOVFF  C80,01
02B24:  MOVFF  C81,02
02B28:  MOVFF  C82,03
02B2C:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
02B4C:  MOVFF  C75,C79
02B50:  MOVFF  C74,C78
02B54:  MOVFF  C73,C77
02B58:  MOVFF  C72,C76
02B5C:  MOVLB  C
02B5E:  CLRF   x7A
02B60:  MOVLB  0
02B62:  RCALL  27E0
02B64:  GOTO   2C70 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
02B2E:  MOVFF  C75,C79
02B32:  MOVFF  C74,C78
02B36:  MOVFF  C73,C77
02B3A:  MOVFF  C72,C76
02B3E:  MOVLW  01
02B40:  MOVLB  C
02B42:  MOVWF  x7A
02B44:  MOVLB  0
02B46:  RCALL  27E0
02B48:  GOTO   2C28 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
02B68:  MOVFF  C69,C89
02B6C:  MOVFF  C68,C88
02B70:  MOVFF  C67,C87
02B74:  MOVFF  C66,C86
02B78:  MOVLB  C
02B7A:  CLRF   x8D
02B7C:  CLRF   x8C
02B7E:  CLRF   x8B
02B80:  CLRF   x8A
02B82:  MOVLB  0
02B84:  CALL   225E
02B88:  BTFSC  FD8.2
02B8A:  BRA    2CCA
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
02B8C:  MOVFF  C65,C82
02B90:  MOVFF  C64,C81
02B94:  MOVFF  C63,C80
02B98:  MOVFF  C62,C7F
02B9C:  MOVFF  C69,C86
02BA0:  MOVFF  C68,C85
02BA4:  MOVFF  C67,C84
02BA8:  MOVFF  C66,C83
02BAC:  CALL   22D8
02BB0:  MOVFF  03,C71
02BB4:  MOVFF  02,C70
02BB8:  MOVFF  01,C6F
02BBC:  MOVFF  00,C6E
02BC0:  MOVFF  03,C89
02BC4:  MOVFF  02,C88
02BC8:  MOVFF  01,C87
02BCC:  MOVFF  00,C86
02BD0:  MOVLB  C
02BD2:  CLRF   x8D
02BD4:  CLRF   x8C
02BD6:  CLRF   x8B
02BD8:  CLRF   x8A
02BDA:  MOVLB  0
02BDC:  CALL   225E
02BE0:  BNC   2C2A
02BE2:  MOVFF  C65,C82
02BE6:  MOVFF  C64,C81
02BEA:  MOVFF  C63,C80
02BEE:  MOVFF  C62,C7F
02BF2:  MOVFF  C69,C86
02BF6:  MOVFF  C68,C85
02BFA:  MOVFF  C67,C84
02BFE:  MOVFF  C66,C83
02C02:  CALL   22D8
02C06:  MOVFF  03,C71
02C0A:  MOVFF  02,C70
02C0E:  MOVFF  01,C6F
02C12:  MOVFF  00,C6E
02C16:  MOVFF  03,C75
02C1A:  MOVFF  02,C74
02C1E:  MOVFF  01,C73
02C22:  MOVFF  00,C72
02C26:  BRA    2B2E
02C28:  BRA    2C70
02C2A:  MOVFF  C65,C82
02C2E:  MOVFF  C64,C81
02C32:  MOVFF  C63,C80
02C36:  MOVFF  C62,C7F
02C3A:  MOVFF  C69,C86
02C3E:  MOVFF  C68,C85
02C42:  MOVFF  C67,C84
02C46:  MOVFF  C66,C83
02C4A:  CALL   22D8
02C4E:  MOVFF  03,C71
02C52:  MOVFF  02,C70
02C56:  MOVFF  01,C6F
02C5A:  MOVFF  00,C6E
02C5E:  MOVFF  03,C75
02C62:  MOVFF  02,C74
02C66:  MOVFF  01,C73
02C6A:  MOVFF  00,C72
02C6E:  BRA    2B4C
02C70:  MOVFF  03,C6D
02C74:  MOVFF  02,C6C
02C78:  MOVFF  01,C6B
02C7C:  MOVFF  00,C6A
....................       return(x-(i*y)); 
02C80:  MOVFF  C6D,C89
02C84:  MOVFF  C6C,C88
02C88:  MOVFF  C6B,C87
02C8C:  MOVFF  C6A,C86
02C90:  MOVFF  C69,C8D
02C94:  MOVFF  C68,C8C
02C98:  MOVFF  C67,C8B
02C9C:  MOVFF  C66,C8A
02CA0:  CALL   2472
02CA4:  BSF    FD8.1
02CA6:  MOVFF  C65,C8D
02CAA:  MOVFF  C64,C8C
02CAE:  MOVFF  C63,C8B
02CB2:  MOVFF  C62,C8A
02CB6:  MOVFF  03,C91
02CBA:  MOVFF  02,C90
02CBE:  MOVFF  01,C8F
02CC2:  MOVFF  00,C8E
02CC6:  RCALL  2568
02CC8:  BRA    2CCA
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
02CCA:  RETURN 0
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
*
030AC:  MOVFF  C69,C89
030B0:  MOVFF  C68,C88
030B4:  MOVFF  C67,C87
030B8:  MOVFF  C66,C86
030BC:  MOVLW  3B
030BE:  MOVLB  C
030C0:  MOVWF  x8D
030C2:  MOVLW  AA
030C4:  MOVWF  x8C
030C6:  MOVLW  38
030C8:  MOVWF  x8B
030CA:  MOVLW  7F
030CC:  MOVWF  x8A
030CE:  MOVLB  0
030D0:  CALL   2472
030D4:  MOVFF  03,C89
030D8:  MOVFF  02,C88
030DC:  MOVFF  01,C87
030E0:  MOVFF  00,C86
030E4:  CALL   2436
030E8:  MOVFF  01,C76
....................    s = 0; 
030EC:  MOVLB  C
030EE:  BCF    x77.0
....................    y = x; 
030F0:  MOVFF  C69,C6D
030F4:  MOVFF  C68,C6C
030F8:  MOVFF  C67,C6B
030FC:  MOVFF  C66,C6A
....................  
....................    if (x < 0) 
03100:  MOVFF  C69,C89
03104:  MOVFF  C68,C88
03108:  MOVFF  C67,C87
0310C:  MOVFF  C66,C86
03110:  CLRF   x8D
03112:  CLRF   x8C
03114:  CLRF   x8B
03116:  CLRF   x8A
03118:  MOVLB  0
0311A:  CALL   225E
0311E:  BNC   312E
....................    { 
....................       s = 1; 
03120:  MOVLB  C
03122:  BSF    x77.0
....................       n = -n; 
03124:  NEGF   x76
....................       y = -y; 
03126:  MOVF   x6B,W
03128:  XORLW  80
0312A:  MOVWF  x6B
0312C:  MOVLB  0
....................    } 
....................  
....................    res = 0.0; 
0312E:  MOVLB  C
03130:  CLRF   x71
03132:  CLRF   x70
03134:  CLRF   x6F
03136:  CLRF   x6E
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
03138:  MOVLW  0C
0313A:  MOVWF  x79
0313C:  MOVLW  6E
0313E:  MOVWF  FE9
03140:  MOVFF  C79,FEA
03144:  MOVLW  7F
03146:  ADDWF  x76,W
03148:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
0314A:  MOVFF  C6D,C89
0314E:  MOVFF  C6C,C88
03152:  MOVFF  C6B,C87
03156:  MOVFF  C6A,C86
0315A:  MOVLW  3B
0315C:  MOVWF  x8D
0315E:  MOVLW  AA
03160:  MOVWF  x8C
03162:  MOVLW  38
03164:  MOVWF  x8B
03166:  MOVLW  7F
03168:  MOVWF  x8A
0316A:  MOVLB  0
0316C:  CALL   2472
03170:  MOVFF  03,C7B
03174:  MOVFF  02,C7A
03178:  MOVFF  01,C79
0317C:  MOVFF  00,C78
03180:  MOVLB  C
03182:  CLRF   x7D
03184:  MOVFF  C76,C7C
03188:  BTFSC  x7C.7
0318A:  DECF   x7D,F
0318C:  MOVLB  0
0318E:  RCALL  2CCC
03190:  BSF    FD8.1
03192:  MOVFF  C7B,C8D
03196:  MOVFF  C7A,C8C
0319A:  MOVFF  C79,C8B
0319E:  MOVFF  C78,C8A
031A2:  MOVFF  03,C91
031A6:  MOVFF  02,C90
031AA:  MOVFF  01,C8F
031AE:  MOVFF  00,C8E
031B2:  CALL   2568
031B6:  MOVFF  03,C6D
031BA:  MOVFF  02,C6C
031BE:  MOVFF  01,C6B
031C2:  MOVFF  00,C6A
....................  
....................    r = pe[0]*y + pe[1]; 
031C6:  MOVLW  7C
031C8:  MOVLB  C
031CA:  MOVWF  x89
031CC:  MOVLW  88
031CE:  MOVWF  x88
031D0:  MOVLW  59
031D2:  MOVWF  x87
031D4:  MOVLW  72
031D6:  MOVWF  x86
031D8:  MOVFF  C6D,C8D
031DC:  MOVFF  C6C,C8C
031E0:  MOVFF  C6B,C8B
031E4:  MOVFF  C6A,C8A
031E8:  MOVLB  0
031EA:  CALL   2472
031EE:  MOVFF  03,C7B
031F2:  MOVFF  02,C7A
031F6:  MOVFF  01,C79
031FA:  MOVFF  00,C78
031FE:  BCF    FD8.1
03200:  MOVFF  03,C8D
03204:  MOVFF  02,C8C
03208:  MOVFF  01,C8B
0320C:  MOVFF  00,C8A
03210:  MOVLW  E0
03212:  MOVLB  C
03214:  MOVWF  x91
03216:  MOVLW  97
03218:  MOVWF  x90
0321A:  MOVLW  26
0321C:  MOVWF  x8F
0321E:  MOVLW  75
03220:  MOVWF  x8E
03222:  MOVLB  0
03224:  CALL   2568
03228:  MOVFF  03,C75
0322C:  MOVFF  02,C74
03230:  MOVFF  01,C73
03234:  MOVFF  00,C72
....................    r = r*y + pe[2]; 
03238:  MOVFF  C75,C89
0323C:  MOVFF  C74,C88
03240:  MOVFF  C73,C87
03244:  MOVFF  C72,C86
03248:  MOVFF  C6D,C8D
0324C:  MOVFF  C6C,C8C
03250:  MOVFF  C6B,C8B
03254:  MOVFF  C6A,C8A
03258:  CALL   2472
0325C:  MOVFF  03,C7B
03260:  MOVFF  02,C7A
03264:  MOVFF  01,C79
03268:  MOVFF  00,C78
0326C:  BCF    FD8.1
0326E:  MOVFF  03,C8D
03272:  MOVFF  02,C8C
03276:  MOVFF  01,C8B
0327A:  MOVFF  00,C8A
0327E:  MOVLW  C4
03280:  MOVLB  C
03282:  MOVWF  x91
03284:  MOVLW  1D
03286:  MOVWF  x90
03288:  MOVLW  1E
0328A:  MOVWF  x8F
0328C:  MOVLW  78
0328E:  MOVWF  x8E
03290:  MOVLB  0
03292:  CALL   2568
03296:  MOVFF  03,C75
0329A:  MOVFF  02,C74
0329E:  MOVFF  01,C73
032A2:  MOVFF  00,C72
....................    r = r*y + pe[3]; 
032A6:  MOVFF  C75,C89
032AA:  MOVFF  C74,C88
032AE:  MOVFF  C73,C87
032B2:  MOVFF  C72,C86
032B6:  MOVFF  C6D,C8D
032BA:  MOVFF  C6C,C8C
032BE:  MOVFF  C6B,C8B
032C2:  MOVFF  C6A,C8A
032C6:  CALL   2472
032CA:  MOVFF  03,C7B
032CE:  MOVFF  02,C7A
032D2:  MOVFF  01,C79
032D6:  MOVFF  00,C78
032DA:  BCF    FD8.1
032DC:  MOVFF  03,C8D
032E0:  MOVFF  02,C8C
032E4:  MOVFF  01,C8B
032E8:  MOVFF  00,C8A
032EC:  MOVLW  5E
032EE:  MOVLB  C
032F0:  MOVWF  x91
032F2:  MOVLW  50
032F4:  MOVWF  x90
032F6:  MOVLW  63
032F8:  MOVWF  x8F
032FA:  MOVLW  7A
032FC:  MOVWF  x8E
032FE:  MOVLB  0
03300:  CALL   2568
03304:  MOVFF  03,C75
03308:  MOVFF  02,C74
0330C:  MOVFF  01,C73
03310:  MOVFF  00,C72
....................    r = r*y + pe[4]; 
03314:  MOVFF  C75,C89
03318:  MOVFF  C74,C88
0331C:  MOVFF  C73,C87
03320:  MOVFF  C72,C86
03324:  MOVFF  C6D,C8D
03328:  MOVFF  C6C,C8C
0332C:  MOVFF  C6B,C8B
03330:  MOVFF  C6A,C8A
03334:  CALL   2472
03338:  MOVFF  03,C7B
0333C:  MOVFF  02,C7A
03340:  MOVFF  01,C79
03344:  MOVFF  00,C78
03348:  BCF    FD8.1
0334A:  MOVFF  03,C8D
0334E:  MOVFF  02,C8C
03352:  MOVFF  01,C8B
03356:  MOVFF  00,C8A
0335A:  MOVLW  1A
0335C:  MOVLB  C
0335E:  MOVWF  x91
03360:  MOVLW  FE
03362:  MOVWF  x90
03364:  MOVLW  75
03366:  MOVWF  x8F
03368:  MOVLW  7C
0336A:  MOVWF  x8E
0336C:  MOVLB  0
0336E:  CALL   2568
03372:  MOVFF  03,C75
03376:  MOVFF  02,C74
0337A:  MOVFF  01,C73
0337E:  MOVFF  00,C72
....................    r = r*y + pe[5]; 
03382:  MOVFF  C75,C89
03386:  MOVFF  C74,C88
0338A:  MOVFF  C73,C87
0338E:  MOVFF  C72,C86
03392:  MOVFF  C6D,C8D
03396:  MOVFF  C6C,C8C
0339A:  MOVFF  C6B,C8B
0339E:  MOVFF  C6A,C8A
033A2:  CALL   2472
033A6:  MOVFF  03,C7B
033AA:  MOVFF  02,C7A
033AE:  MOVFF  01,C79
033B2:  MOVFF  00,C78
033B6:  BCF    FD8.1
033B8:  MOVFF  03,C8D
033BC:  MOVFF  02,C8C
033C0:  MOVFF  01,C8B
033C4:  MOVFF  00,C8A
033C8:  MOVLW  18
033CA:  MOVLB  C
033CC:  MOVWF  x91
033CE:  MOVLW  72
033D0:  MOVWF  x90
033D2:  MOVLW  31
033D4:  MOVWF  x8F
033D6:  MOVLW  7E
033D8:  MOVWF  x8E
033DA:  MOVLB  0
033DC:  CALL   2568
033E0:  MOVFF  03,C75
033E4:  MOVFF  02,C74
033E8:  MOVFF  01,C73
033EC:  MOVFF  00,C72
....................  
....................    res = res*(1.0 + y*r); 
033F0:  MOVFF  C6D,C89
033F4:  MOVFF  C6C,C88
033F8:  MOVFF  C6B,C87
033FC:  MOVFF  C6A,C86
03400:  MOVFF  C75,C8D
03404:  MOVFF  C74,C8C
03408:  MOVFF  C73,C8B
0340C:  MOVFF  C72,C8A
03410:  CALL   2472
03414:  BCF    FD8.1
03416:  MOVLB  C
03418:  CLRF   x8D
0341A:  CLRF   x8C
0341C:  CLRF   x8B
0341E:  MOVLW  7F
03420:  MOVWF  x8A
03422:  MOVFF  03,C91
03426:  MOVFF  02,C90
0342A:  MOVFF  01,C8F
0342E:  MOVFF  00,C8E
03432:  MOVLB  0
03434:  CALL   2568
03438:  MOVFF  C71,C89
0343C:  MOVFF  C70,C88
03440:  MOVFF  C6F,C87
03444:  MOVFF  C6E,C86
03448:  MOVFF  03,C8D
0344C:  MOVFF  02,C8C
03450:  MOVFF  01,C8B
03454:  MOVFF  00,C8A
03458:  CALL   2472
0345C:  MOVFF  03,C71
03460:  MOVFF  02,C70
03464:  MOVFF  01,C6F
03468:  MOVFF  00,C6E
....................  
....................    if (s) 
0346C:  MOVLB  C
0346E:  BTFSS  x77.0
03470:  BRA    34A4
....................       res = 1.0/res; 
03472:  CLRF   x82
03474:  CLRF   x81
03476:  CLRF   x80
03478:  MOVLW  7F
0347A:  MOVWF  x7F
0347C:  MOVFF  C71,C86
03480:  MOVFF  C70,C85
03484:  MOVFF  C6F,C84
03488:  MOVFF  C6E,C83
0348C:  MOVLB  0
0348E:  CALL   22D8
03492:  MOVFF  03,C71
03496:  MOVFF  02,C70
0349A:  MOVFF  01,C6F
0349E:  MOVFF  00,C6E
034A2:  MOVLB  C
....................    return(res); 
034A4:  MOVFF  C6E,00
034A8:  MOVFF  C6F,01
034AC:  MOVFF  C70,02
034B0:  MOVFF  C71,03
034B4:  MOVLB  0
034B6:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
02D1C:  MOVFF  C69,C6D
02D20:  MOVFF  C68,C6C
02D24:  MOVFF  C67,C6B
02D28:  MOVFF  C66,C6A
....................  
....................    if (y != 1.0) 
02D2C:  MOVFF  C6D,C89
02D30:  MOVFF  C6C,C88
02D34:  MOVFF  C6B,C87
02D38:  MOVFF  C6A,C86
02D3C:  MOVLB  C
02D3E:  CLRF   x8D
02D40:  CLRF   x8C
02D42:  CLRF   x8B
02D44:  MOVLW  7F
02D46:  MOVWF  x8A
02D48:  MOVLB  0
02D4A:  CALL   225E
02D4E:  BTFSC  FD8.2
02D50:  BRA    308E
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
02D52:  MOVLW  0C
02D54:  MOVLB  C
02D56:  MOVWF  x7C
02D58:  MOVLW  6A
02D5A:  MOVWF  FE9
02D5C:  MOVFF  C7C,FEA
02D60:  MOVLW  7E
02D62:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
02D64:  BSF    FD8.1
02D66:  MOVFF  C6D,C8D
02D6A:  MOVFF  C6C,C8C
02D6E:  MOVFF  C6B,C8B
02D72:  MOVFF  C6A,C8A
02D76:  CLRF   x91
02D78:  CLRF   x90
02D7A:  CLRF   x8F
02D7C:  MOVLW  7F
02D7E:  MOVWF  x8E
02D80:  MOVLB  0
02D82:  CALL   2568
02D86:  MOVFF  03,C7E
02D8A:  MOVFF  02,C7D
02D8E:  MOVFF  01,C7C
02D92:  MOVFF  00,C7B
02D96:  BCF    FD8.1
02D98:  MOVFF  C6D,C8D
02D9C:  MOVFF  C6C,C8C
02DA0:  MOVFF  C6B,C8B
02DA4:  MOVFF  C6A,C8A
02DA8:  MOVLB  C
02DAA:  CLRF   x91
02DAC:  CLRF   x90
02DAE:  CLRF   x8F
02DB0:  MOVLW  7F
02DB2:  MOVWF  x8E
02DB4:  MOVLB  0
02DB6:  CALL   2568
02DBA:  MOVFF  C7E,C82
02DBE:  MOVFF  C7D,C81
02DC2:  MOVFF  C7C,C80
02DC6:  MOVFF  C7B,C7F
02DCA:  MOVFF  03,C86
02DCE:  MOVFF  02,C85
02DD2:  MOVFF  01,C84
02DD6:  MOVFF  00,C83
02DDA:  CALL   22D8
02DDE:  MOVFF  03,C6D
02DE2:  MOVFF  02,C6C
02DE6:  MOVFF  01,C6B
02DEA:  MOVFF  00,C6A
....................  
....................       y2=y*y; 
02DEE:  MOVFF  C6D,C89
02DF2:  MOVFF  C6C,C88
02DF6:  MOVFF  C6B,C87
02DFA:  MOVFF  C6A,C86
02DFE:  MOVFF  C6D,C8D
02E02:  MOVFF  C6C,C8C
02E06:  MOVFF  C6B,C8B
02E0A:  MOVFF  C6A,C8A
02E0E:  CALL   2472
02E12:  MOVFF  03,C79
02E16:  MOVFF  02,C78
02E1A:  MOVFF  01,C77
02E1E:  MOVFF  00,C76
....................  
....................       res = pl[0]*y2 + pl[1]; 
02E22:  MOVLW  99
02E24:  MOVLB  C
02E26:  MOVWF  x89
02E28:  MOVLW  47
02E2A:  MOVWF  x88
02E2C:  MOVLW  8A
02E2E:  MOVWF  x87
02E30:  MOVLW  7F
02E32:  MOVWF  x86
02E34:  MOVFF  C79,C8D
02E38:  MOVFF  C78,C8C
02E3C:  MOVFF  C77,C8B
02E40:  MOVFF  C76,C8A
02E44:  MOVLB  0
02E46:  CALL   2472
02E4A:  MOVFF  03,C7E
02E4E:  MOVFF  02,C7D
02E52:  MOVFF  01,C7C
02E56:  MOVFF  00,C7B
02E5A:  BCF    FD8.1
02E5C:  MOVFF  03,C8D
02E60:  MOVFF  02,C8C
02E64:  MOVFF  01,C8B
02E68:  MOVFF  00,C8A
02E6C:  MOVLB  C
02E6E:  CLRF   x91
02E70:  CLRF   x90
02E72:  CLRF   x8F
02E74:  MOVLW  80
02E76:  MOVWF  x8E
02E78:  MOVLB  0
02E7A:  CALL   2568
02E7E:  MOVFF  03,C71
02E82:  MOVFF  02,C70
02E86:  MOVFF  01,C6F
02E8A:  MOVFF  00,C6E
....................  
....................       r = ql[0]*y2 + ql[1]; 
02E8E:  MOVLW  4C
02E90:  MOVLB  C
02E92:  MOVWF  x89
02E94:  MOVLW  F3
02E96:  MOVWF  x88
02E98:  MOVLW  3A
02E9A:  MOVWF  x87
02E9C:  MOVLW  7B
02E9E:  MOVWF  x86
02EA0:  MOVFF  C79,C8D
02EA4:  MOVFF  C78,C8C
02EA8:  MOVFF  C77,C8B
02EAC:  MOVFF  C76,C8A
02EB0:  MOVLB  0
02EB2:  CALL   2472
02EB6:  MOVFF  03,C7E
02EBA:  MOVFF  02,C7D
02EBE:  MOVFF  01,C7C
02EC2:  MOVFF  00,C7B
02EC6:  BCF    FD8.1
02EC8:  MOVFF  03,C8D
02ECC:  MOVFF  02,C8C
02ED0:  MOVFF  01,C8B
02ED4:  MOVFF  00,C8A
02ED8:  MOVLW  2B
02EDA:  MOVLB  C
02EDC:  MOVWF  x91
02EDE:  MOVLW  9D
02EE0:  MOVWF  x90
02EE2:  MOVLW  DF
02EE4:  MOVWF  x8F
02EE6:  MOVLW  7E
02EE8:  MOVWF  x8E
02EEA:  MOVLB  0
02EEC:  CALL   2568
02EF0:  MOVFF  03,C75
02EF4:  MOVFF  02,C74
02EF8:  MOVFF  01,C73
02EFC:  MOVFF  00,C72
....................       r = r*y2 + 1.0; 
02F00:  MOVFF  C75,C89
02F04:  MOVFF  C74,C88
02F08:  MOVFF  C73,C87
02F0C:  MOVFF  C72,C86
02F10:  MOVFF  C79,C8D
02F14:  MOVFF  C78,C8C
02F18:  MOVFF  C77,C8B
02F1C:  MOVFF  C76,C8A
02F20:  CALL   2472
02F24:  MOVFF  03,C7E
02F28:  MOVFF  02,C7D
02F2C:  MOVFF  01,C7C
02F30:  MOVFF  00,C7B
02F34:  BCF    FD8.1
02F36:  MOVFF  03,C8D
02F3A:  MOVFF  02,C8C
02F3E:  MOVFF  01,C8B
02F42:  MOVFF  00,C8A
02F46:  MOVLB  C
02F48:  CLRF   x91
02F4A:  CLRF   x90
02F4C:  CLRF   x8F
02F4E:  MOVLW  7F
02F50:  MOVWF  x8E
02F52:  MOVLB  0
02F54:  CALL   2568
02F58:  MOVFF  03,C75
02F5C:  MOVFF  02,C74
02F60:  MOVFF  01,C73
02F64:  MOVFF  00,C72
....................  
....................       res = y*res/r; 
02F68:  MOVFF  C6D,C89
02F6C:  MOVFF  C6C,C88
02F70:  MOVFF  C6B,C87
02F74:  MOVFF  C6A,C86
02F78:  MOVFF  C71,C8D
02F7C:  MOVFF  C70,C8C
02F80:  MOVFF  C6F,C8B
02F84:  MOVFF  C6E,C8A
02F88:  CALL   2472
02F8C:  MOVFF  03,C7E
02F90:  MOVFF  02,C7D
02F94:  MOVFF  01,C7C
02F98:  MOVFF  00,C7B
02F9C:  MOVFF  03,C82
02FA0:  MOVFF  02,C81
02FA4:  MOVFF  01,C80
02FA8:  MOVFF  00,C7F
02FAC:  MOVFF  C75,C86
02FB0:  MOVFF  C74,C85
02FB4:  MOVFF  C73,C84
02FB8:  MOVFF  C72,C83
02FBC:  CALL   22D8
02FC0:  MOVFF  03,C71
02FC4:  MOVFF  02,C70
02FC8:  MOVFF  01,C6F
02FCC:  MOVFF  00,C6E
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
02FD0:  MOVLW  0C
02FD2:  MOVLB  C
02FD4:  MOVWF  x7C
02FD6:  MOVLW  66
02FD8:  MOVWF  FE9
02FDA:  MOVFF  C7C,FEA
02FDE:  MOVLW  7E
02FE0:  SUBWF  FEF,W
02FE2:  MOVWF  x7A
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
02FE4:  BTFSS  x7A.7
02FE6:  BRA    3010
....................          r = -(float32)-n; 
02FE8:  MOVLW  00
02FEA:  BSF    FD8.0
02FEC:  SUBFWB x7A,W
02FEE:  CLRF   x7D
02FF0:  MOVWF  x7C
02FF2:  BTFSC  x7C.7
02FF4:  DECF   x7D,F
02FF6:  MOVLB  0
02FF8:  RCALL  2CCC
02FFA:  MOVFF  00,C72
02FFE:  MOVF   01,W
03000:  XORLW  80
03002:  MOVLB  C
03004:  MOVWF  x73
03006:  MOVFF  02,C74
0300A:  MOVFF  03,C75
0300E:  BRA    3030
....................       else 
....................          r = (float32)n; 
03010:  CLRF   x7D
03012:  MOVFF  C7A,C7C
03016:  BTFSC  x7C.7
03018:  DECF   x7D,F
0301A:  MOVLB  0
0301C:  RCALL  2CCC
0301E:  MOVFF  03,C75
03022:  MOVFF  02,C74
03026:  MOVFF  01,C73
0302A:  MOVFF  00,C72
0302E:  MOVLB  C
....................  
....................       res += r*LN2; 
03030:  MOVFF  C75,C89
03034:  MOVFF  C74,C88
03038:  MOVFF  C73,C87
0303C:  MOVFF  C72,C86
03040:  MOVLW  18
03042:  MOVWF  x8D
03044:  MOVLW  72
03046:  MOVWF  x8C
03048:  MOVLW  31
0304A:  MOVWF  x8B
0304C:  MOVLW  7E
0304E:  MOVWF  x8A
03050:  MOVLB  0
03052:  CALL   2472
03056:  BCF    FD8.1
03058:  MOVFF  C71,C8D
0305C:  MOVFF  C70,C8C
03060:  MOVFF  C6F,C8B
03064:  MOVFF  C6E,C8A
03068:  MOVFF  03,C91
0306C:  MOVFF  02,C90
03070:  MOVFF  01,C8F
03074:  MOVFF  00,C8E
03078:  CALL   2568
0307C:  MOVFF  03,C71
03080:  MOVFF  02,C70
03084:  MOVFF  01,C6F
03088:  MOVFF  00,C6E
....................    } 
0308C:  BRA    309A
....................  
....................    else 
....................       res = 0.0; 
0308E:  MOVLB  C
03090:  CLRF   x71
03092:  CLRF   x70
03094:  CLRF   x6F
03096:  CLRF   x6E
03098:  MOVLB  0
....................  
....................    return(res); 
0309A:  MOVFF  C6E,00
0309E:  MOVFF  C6F,01
030A2:  MOVFF  C70,02
030A6:  MOVFF  C71,03
030AA:  RETURN 0
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
034B8:  MOVFF  C5D,C89
034BC:  MOVFF  C5C,C88
034C0:  MOVFF  C5B,C87
034C4:  MOVFF  C5A,C86
034C8:  MOVLB  C
034CA:  CLRF   x8D
034CC:  CLRF   x8C
034CE:  CLRF   x8B
034D0:  CLRF   x8A
034D2:  MOVLB  0
034D4:  CALL   225E
034D8:  BTFSS  FD8.0
034DA:  BRA    368E
034DC:  MOVFF  C61,C65
034E0:  MOVFF  C60,C64
034E4:  MOVFF  C5F,C63
034E8:  MOVFF  C5E,C62
034EC:  MOVLB  C
034EE:  CLRF   x69
034F0:  CLRF   x68
034F2:  CLRF   x67
034F4:  MOVLW  7F
034F6:  MOVWF  x66
034F8:  MOVLB  0
034FA:  CALL   2B68
034FE:  MOVFF  03,C65
03502:  MOVFF  02,C64
03506:  MOVFF  01,C63
0350A:  MOVFF  00,C62
0350E:  MOVFF  03,C89
03512:  MOVFF  02,C88
03516:  MOVFF  01,C87
0351A:  MOVFF  00,C86
0351E:  MOVLB  C
03520:  CLRF   x8D
03522:  CLRF   x8C
03524:  CLRF   x8B
03526:  CLRF   x8A
03528:  MOVLB  0
0352A:  CALL   225E
0352E:  BTFSS  FD8.2
03530:  BRA    368E
....................       if(fmod(y, 2) == 0) { 
03532:  MOVFF  C61,C65
03536:  MOVFF  C60,C64
0353A:  MOVFF  C5F,C63
0353E:  MOVFF  C5E,C62
03542:  MOVLB  C
03544:  CLRF   x69
03546:  CLRF   x68
03548:  CLRF   x67
0354A:  MOVLW  80
0354C:  MOVWF  x66
0354E:  MOVLB  0
03550:  CALL   2B68
03554:  MOVFF  03,C65
03558:  MOVFF  02,C64
0355C:  MOVFF  01,C63
03560:  MOVFF  00,C62
03564:  MOVFF  03,C89
03568:  MOVFF  02,C88
0356C:  MOVFF  01,C87
03570:  MOVFF  00,C86
03574:  MOVLB  C
03576:  CLRF   x8D
03578:  CLRF   x8C
0357A:  CLRF   x8B
0357C:  CLRF   x8A
0357E:  MOVLB  0
03580:  CALL   225E
03584:  BNZ   3608
....................          return (exp(log(-x) * y)); 
03586:  MOVFF  C5A,C62
0358A:  MOVLB  C
0358C:  MOVF   x5B,W
0358E:  XORLW  80
03590:  MOVWF  x63
03592:  MOVFF  C5C,C64
03596:  MOVFF  C5D,C65
0359A:  MOVFF  C5D,C69
0359E:  MOVFF  C5C,C68
035A2:  MOVWF  x67
035A4:  MOVFF  C5A,C66
035A8:  MOVLB  0
035AA:  CALL   2D1C
035AE:  MOVFF  03,C65
035B2:  MOVFF  02,C64
035B6:  MOVFF  01,C63
035BA:  MOVFF  00,C62
035BE:  MOVFF  03,C89
035C2:  MOVFF  02,C88
035C6:  MOVFF  01,C87
035CA:  MOVFF  00,C86
035CE:  MOVFF  C61,C8D
035D2:  MOVFF  C60,C8C
035D6:  MOVFF  C5F,C8B
035DA:  MOVFF  C5E,C8A
035DE:  CALL   2472
035E2:  MOVFF  03,C65
035E6:  MOVFF  02,C64
035EA:  MOVFF  01,C63
035EE:  MOVFF  00,C62
035F2:  MOVFF  03,C69
035F6:  MOVFF  02,C68
035FA:  MOVFF  01,C67
035FE:  MOVFF  00,C66
03602:  RCALL  30AC
03604:  BRA    37C0
....................       } else { 
03606:  BRA    368C
....................          return (-exp(log(-x) * y)); 
03608:  MOVFF  C5A,C62
0360C:  MOVLB  C
0360E:  MOVF   x5B,W
03610:  XORLW  80
03612:  MOVWF  x63
03614:  MOVFF  C5C,C64
03618:  MOVFF  C5D,C65
0361C:  MOVFF  C5D,C69
03620:  MOVFF  C5C,C68
03624:  MOVWF  x67
03626:  MOVFF  C5A,C66
0362A:  MOVLB  0
0362C:  CALL   2D1C
03630:  MOVFF  03,C65
03634:  MOVFF  02,C64
03638:  MOVFF  01,C63
0363C:  MOVFF  00,C62
03640:  MOVFF  03,C89
03644:  MOVFF  02,C88
03648:  MOVFF  01,C87
0364C:  MOVFF  00,C86
03650:  MOVFF  C61,C8D
03654:  MOVFF  C60,C8C
03658:  MOVFF  C5F,C8B
0365C:  MOVFF  C5E,C8A
03660:  CALL   2472
03664:  MOVFF  03,C65
03668:  MOVFF  02,C64
0366C:  MOVFF  01,C63
03670:  MOVFF  00,C62
03674:  MOVFF  03,C69
03678:  MOVFF  02,C68
0367C:  MOVFF  01,C67
03680:  MOVFF  00,C66
03684:  RCALL  30AC
03686:  MOVLW  80
03688:  XORWF  01,F
0368A:  BRA    37C0
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
0368C:  BRA    37C0
0368E:  MOVFF  C5D,C89
03692:  MOVFF  C5C,C88
03696:  MOVFF  C5B,C87
0369A:  MOVFF  C5A,C86
0369E:  MOVLB  C
036A0:  CLRF   x8D
036A2:  CLRF   x8C
036A4:  CLRF   x8B
036A6:  CLRF   x8A
036A8:  MOVLB  0
036AA:  CALL   225E
036AE:  BNC   3710
036B0:  MOVFF  C61,C65
036B4:  MOVFF  C60,C64
036B8:  MOVFF  C5F,C63
036BC:  MOVFF  C5E,C62
036C0:  MOVLB  C
036C2:  CLRF   x69
036C4:  CLRF   x68
036C6:  CLRF   x67
036C8:  MOVLW  7F
036CA:  MOVWF  x66
036CC:  MOVLB  0
036CE:  CALL   2B68
036D2:  MOVFF  03,C65
036D6:  MOVFF  02,C64
036DA:  MOVFF  01,C63
036DE:  MOVFF  00,C62
036E2:  MOVFF  03,C89
036E6:  MOVFF  02,C88
036EA:  MOVFF  01,C87
036EE:  MOVFF  00,C86
036F2:  MOVLB  C
036F4:  CLRF   x8D
036F6:  CLRF   x8C
036F8:  CLRF   x8B
036FA:  CLRF   x8A
036FC:  MOVLB  0
036FE:  CALL   225E
03702:  BZ    3710
....................       return 0; 
03704:  CLRF   00
03706:  CLRF   01
03708:  CLRF   02
0370A:  CLRF   03
0370C:  BRA    37C0
....................    } else { 
0370E:  BRA    37C0
....................       if(x != 0 || 0 >= y) { 
03710:  MOVFF  C5D,C89
03714:  MOVFF  C5C,C88
03718:  MOVFF  C5B,C87
0371C:  MOVFF  C5A,C86
03720:  MOVLB  C
03722:  CLRF   x8D
03724:  CLRF   x8C
03726:  CLRF   x8B
03728:  CLRF   x8A
0372A:  MOVLB  0
0372C:  CALL   225E
03730:  BNZ   3756
03732:  MOVFF  C61,C89
03736:  MOVFF  C60,C88
0373A:  MOVFF  C5F,C87
0373E:  MOVFF  C5E,C86
03742:  MOVLB  C
03744:  CLRF   x8D
03746:  CLRF   x8C
03748:  CLRF   x8B
0374A:  CLRF   x8A
0374C:  MOVLB  0
0374E:  CALL   225E
03752:  BC    3756
03754:  BNZ   37C0
....................          return (exp(log(x) * y)); 
03756:  MOVFF  C5D,C69
0375A:  MOVFF  C5C,C68
0375E:  MOVFF  C5B,C67
03762:  MOVFF  C5A,C66
03766:  CALL   2D1C
0376A:  MOVFF  03,C65
0376E:  MOVFF  02,C64
03772:  MOVFF  01,C63
03776:  MOVFF  00,C62
0377A:  MOVFF  03,C89
0377E:  MOVFF  02,C88
03782:  MOVFF  01,C87
03786:  MOVFF  00,C86
0378A:  MOVFF  C61,C8D
0378E:  MOVFF  C60,C8C
03792:  MOVFF  C5F,C8B
03796:  MOVFF  C5E,C8A
0379A:  CALL   2472
0379E:  MOVFF  03,C65
037A2:  MOVFF  02,C64
037A6:  MOVFF  01,C63
037AA:  MOVFF  00,C62
037AE:  MOVFF  03,C69
037B2:  MOVFF  02,C68
037B6:  MOVFF  01,C67
037BA:  MOVFF  00,C66
037BE:  RCALL  30AC
....................       } 
....................    } 
037C0:  GOTO   4226 (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <SFward_AX25_v2.h> 
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <ctype.h>  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................   
....................   
.................... //Start of ACS 
.................... #define LED_INDICATOR_PIN PIN_G0       //Pin used as indicator for testing 
.................... //#define TXONGOING_PIN PIN_B3           //Pin used to indicate that TNC module is still transmitting audio to BIM1H 
.................... //#define APSF_FM4_CS PIN_A3             //Chip Select 1, 0 means that S&F flash memory is selected, 1 means deselected 
....................  
.................... #define SOFTUART_RXPIN PIN_C7          //PIC16F1788 pin #18 
.................... #define SOFTUART_TXPIN PIN_C6          //PIC16F1788 pin #17 
....................  
.................... //#define APSF_FLAG PIN_A5   //pin used by APSF MCU to inform COM96 MCU that it has saved an uplink command received from BIRDS GS 
....................  
.................... #define UART_BAUDRATE 19.2      //in kbps 
.................... #define UART_BITPERIOD 52        //in us 
.................... #define UART_HALFBITPERIOD 26    //in us 
.................... #define UART_STOPBITPERIOD 52    //in us 
....................  
.................... #define INFO_FIELD_LEN  155       //number of bytes of AX.25 Information field 
.................... //#define UART_RXDATA_MAXLEN (2+16+INFO_FIELD_LEN+1+20)    //number of bytes of AX.25 frame including 2-byte KISS start, 6 bytes dest CS, 1 byte dest SSID, 6 bytes source CS, 1 byte source SSID, 1 byte control field, 1 byte PID, info field, 1-byte KISS end, 20-byte margin 
.................... //#define UART_TXDATA_MAXLEN (2+16+INFO_FIELD_LEN+1+20)    //number of bytes of AX.25 frame including 2-byte KISS start, 6 bytes dest CS, 1 byte dest SSID, 6 bytes source CS, 1 byte source SSID, 1 byte control field, 1 byte PID, info field, 1-byte KISS end, 20-byte margin    
.................... #define UART_RXDATA_MAXLEN 512 
.................... #define UART_TXDATA_MAXLEN 128 
....................  
....................  
.................... #define TX_DEST_CALLSIGN   ((unsigned char*)"S&FGST")    //destination callsign for downlink 
.................... #define TX_SOURCE_CALLSIGN ((unsigned char*)"JG6YKM")    //source callsign for downlink 
.................... #define RX_DEST_CALLSIGN   ((unsigned char*)"JG6YKM")    //destination callsign for uplink 
.................... #define RX_SOURCE_CALLSIGN ((unsigned char*)"S&FGST")    //source callsign for uplink 
.................... #define RECEIVEPACKET_END  ';'  //End of transmission block 
....................  
.................... #define TNC_PROCDELAY   100   //in ms 
....................  
.................... #define FEND   (unsigned char)0xC0  //192 
.................... #define FESC   (unsigned char)0xDB  //219 
.................... #define TFEND  (unsigned char)0xDC  //220 
.................... #define TFESC  (unsigned char)0xDD  //221 
....................  
.................... //function prototypes 
.................... unsigned int16 KISSframe_to_AX25packet(unsigned char* KISSframe, unsigned int16 KISSframe_len, unsigned char* AX25packet); 
.................... unsigned int16 AX25packet_to_KISSframe(unsigned char* AX25packet, unsigned int16 AX25packet_len, unsigned char* KISSframe); 
.................... int8 parse_received_packet(); 
.................... void send_acknowledgment_packet(); 
.................... void send_acknowledgment_packet_forcommanduplink(); 
.................... void send_TLE_packet(); 
.................... void save_TLE(); 
.................... void save_received_frame(); 
....................  
....................  
.................... void softwareUART_init(); 
.................... unsigned int16 receive_UARTdata(unsigned char* received_data); 
.................... unsigned int16 transmit_UARTdata(unsigned char* transmit_data, unsigned int16 transmit_data_len); 
.................... unsigned char softwareUART_receive_byte(); 
....................  
....................  
....................  
.................... //Global variables 
.................... unsigned int8 TX_KISSframe_len = 0;    //number of bytes of received KISS frame 
.................... unsigned char TX_KISSframe[UART_TXDATA_MAXLEN] = {}; 
.................... unsigned int8 TX_packet_len = 0;      //number of bytes of downlink command data to be transmitted, including dest/source CSs and SSIDs, control, PID, info fields, 2-byte FCS and RECEIVEPACKET_END, but excludiing end/start flags and bit stuffs 
.................... unsigned char TX_packet[UART_TXDATA_MAXLEN] = {}; 
.................... //unsigned char TX_callsign_dest[6]; 
.................... unsigned char TX_SSID_dest = 0x30; 
.................... //unsigned char TX_callsign_source[6];                               
.................... unsigned char TX_SSID_source = 0x30;            
.................... unsigned char TX_control = 0x3E;                                 
.................... unsigned char TX_PID = 0xF0;  
....................  
....................  
.................... int16 RX_KISSframe_len = 0;    //number of bytes of received KISS frame 
.................... //unsigned int8 RX_KISSframe[UART_RXDATA_MAXLEN] = {}; 
.................... //RX_KISSframe={0xC0, 0x00, 0x82, 0xA0 , 0x96 , 0x60 , 0x60 , 0x66 , 0x60 , 0x94 , 0x8E , 0x6C , 0xB2 , 0x84 , 0xAE , 0xEE , 0x82 , 0xA0 , 0xA4 , 0xA6 , 0x82 , 0xA8 , 0x61 , 0x03 , 0xF0 , 0x3A , 0x42 , 0x49 , 0x52 , 0x44 , 0x53 , 0x34 , 0x20 , 0x20 , 0x20 , 0x3A , 0x61 , 0x61 , 0x61 , 0x61 , 0x61 , 0x7B , 0x32 , 0x37 , 0x0D , 0xC0}; 
....................  
.................... unsigned int8 RX_KISSframe[] ={0xC0, 0x00, 0x4A, 0x47 , 0x36 , 0x59 , 0x4B , 0x4D , 0x30 , 0x53 , 0x26 , 0x46 , 0x47 , 0x53 , 0x54 , 0x31 , 0x3E , 0xF0 , 0x53 , 0x46 , 0x00 , 0x00 , 0x51 , 0x31 , 0x38 , 0x30 , 0x37 , 0x30 , 0x31 , 0x33 , 0x31 , 0x35 , 0x30 , 0x35 , 0x31 , 0x38 , 0x55 , 0x37 , 0x31 , 0x30 , 0x31 , 0x33 , 0x31 , 0x35 , 0x32 , 0x30 , 0x32 , 0x32 , 0x35 , 0x53 , 0xC0}; 
....................  
....................  
.................... unsigned int16 RX_packet_len = 0;    //number of bytes of uplink command data received including dest/source CSs and SSIDs, control, PID, info fields and 2-byte FCS, but excluding RECEIVEPACKET_END, end/start flags and bit stuffs 
.................... unsigned char RX_packet[UART_RXDATA_MAXLEN] = {}; 
....................  
.................... unsigned char RX_callsign_dest[7] = {'\0','\0','\0','\0','\0','\0','\0'}; 
.................... unsigned char RX_SSID_dest = 0x30; 
.................... unsigned char RX_callsign_source[7] = {'\0','\0','\0','\0','\0','\0','\0'};                                  
.................... unsigned char RX_SSID_source = 0x30;            
.................... unsigned char RX_control = 0x3E;                                 
.................... unsigned char RX_PID = 0xF0;  
.................... unsigned char RX_info_field[256]; 
.................... //unsigned char RX_FCS[2]; 
....................                  
.................... unsigned char info_header[2] = {'S', 'F'};                       
.................... unsigned char info_footer[2] = {'S', 'F'};                         
....................                        
....................   
.................... //Convert only one KISS frame to an AX.25 packet 
....................  
.................... unsigned int16 KISSframe_to_AX25packet(unsigned char* KISSframe, unsigned int16 KISSframe_len, unsigned char* AX25packet) 
*
05D80:  MOVLB  C
05D82:  CLRF   x56
05D84:  CLRF   x55
.................... { 
....................    unsigned int16 RX_AX25packet_len = 0;   //number of recently decoded bytes and serves as index to where the next decoded byte should be placed 
....................     
....................    //Check if valid KISS frame 
....................    if(!(RX_KISSframe[0]==FEND && RX_KISSframe[RX_KISSframe_len-1]==FEND)) return RX_AX25packet_len; 
05D86:  MOVLB  1
05D88:  MOVF   x2D,W
05D8A:  SUBLW  C0
05D8C:  BNZ   5DB2
05D8E:  MOVLW  01
05D90:  SUBWF  x2B,W
05D92:  MOVLB  C
05D94:  MOVWF  x59
05D96:  MOVLW  00
05D98:  MOVLB  1
05D9A:  SUBWFB x2C,W
05D9C:  MOVLB  C
05D9E:  MOVWF  x5A
05DA0:  MOVLW  2D
05DA2:  ADDWF  x59,W
05DA4:  MOVWF  FE9
05DA6:  MOVLW  01
05DA8:  ADDWFC x5A,W
05DAA:  MOVWF  FEA
05DAC:  MOVF   FEF,W
05DAE:  SUBLW  C0
05DB0:  BZ    5DBE
05DB2:  MOVLB  C
05DB4:  MOVFF  C55,01
05DB8:  MOVFF  C56,02
05DBC:  BRA    5F30
....................     
....................    //Else, assume a valid KISS frame, begin decoding at the third byte and stop before the end of frame 
....................    for(unsigned int16 k=2; k < (RX_KISSframe_len-1); k++) 
05DBE:  CLRF   x58
05DC0:  MOVLW  02
05DC2:  MOVWF  x57
05DC4:  MOVLW  01
05DC6:  MOVLB  1
05DC8:  SUBWF  x2B,W
05DCA:  MOVWF  00
05DCC:  MOVLW  00
05DCE:  SUBWFB x2C,W
05DD0:  MOVWF  03
05DD2:  MOVFF  00,01
05DD6:  MOVLB  C
05DD8:  MOVF   x58,W
05DDA:  SUBWF  03,W
05DDC:  BTFSS  FD8.0
05DDE:  BRA    5F28
05DE0:  BNZ   5DEA
05DE2:  MOVF   01,W
05DE4:  SUBWF  x57,W
05DE6:  BTFSC  FD8.0
05DE8:  BRA    5F28
....................    { 
....................       //Corresponding to received AX.25 data FEND 
....................       if(RX_KISSframe[k]==TFESC && RX_KISSframe[k-1]==FESC) RX_packet[RX_AX25packet_len++]=FESC;  
05DEA:  MOVLW  2D
05DEC:  ADDWF  x57,W
05DEE:  MOVWF  FE9
05DF0:  MOVLW  01
05DF2:  ADDWFC x58,W
05DF4:  MOVWF  FEA
05DF6:  MOVF   FEF,W
05DF8:  SUBLW  DD
05DFA:  BNZ   5E3A
05DFC:  MOVLW  01
05DFE:  SUBWF  x57,W
05E00:  MOVWF  x59
05E02:  MOVLW  00
05E04:  SUBWFB x58,W
05E06:  MOVWF  x5A
05E08:  MOVLW  2D
05E0A:  ADDWF  x59,W
05E0C:  MOVWF  FE9
05E0E:  MOVLW  01
05E10:  ADDWFC x5A,W
05E12:  MOVWF  FEA
05E14:  MOVF   FEF,W
05E16:  SUBLW  DB
05E18:  BNZ   5E3A
05E1A:  MOVFF  C56,C5A
05E1E:  MOVF   x55,W
05E20:  INCF   x55,F
05E22:  BTFSC  FD8.2
05E24:  INCF   x56,F
05E26:  MOVWF  x59
05E28:  MOVLW  62
05E2A:  ADDWF  x59,W
05E2C:  MOVWF  FE9
05E2E:  MOVLW  01
05E30:  ADDWFC x5A,W
05E32:  MOVWF  FEA
05E34:  MOVLW  DB
05E36:  MOVWF  FEF
05E38:  BRA    5F20
....................        
....................       //Corresponding to received AX.25 data FESC 
....................       else if(RX_KISSframe[k]==TFESC && RX_KISSframe[k-1]==FESC) RX_packet[RX_AX25packet_len++]=FESC; 
05E3A:  MOVLW  2D
05E3C:  ADDWF  x57,W
05E3E:  MOVWF  FE9
05E40:  MOVLW  01
05E42:  ADDWFC x58,W
05E44:  MOVWF  FEA
05E46:  MOVF   FEF,W
05E48:  SUBLW  DD
05E4A:  BNZ   5E8A
05E4C:  MOVLW  01
05E4E:  SUBWF  x57,W
05E50:  MOVWF  x59
05E52:  MOVLW  00
05E54:  SUBWFB x58,W
05E56:  MOVWF  x5A
05E58:  MOVLW  2D
05E5A:  ADDWF  x59,W
05E5C:  MOVWF  FE9
05E5E:  MOVLW  01
05E60:  ADDWFC x5A,W
05E62:  MOVWF  FEA
05E64:  MOVF   FEF,W
05E66:  SUBLW  DB
05E68:  BNZ   5E8A
05E6A:  MOVFF  C56,C5A
05E6E:  MOVF   x55,W
05E70:  INCF   x55,F
05E72:  BTFSC  FD8.2
05E74:  INCF   x56,F
05E76:  MOVWF  x59
05E78:  MOVLW  62
05E7A:  ADDWF  x59,W
05E7C:  MOVWF  FE9
05E7E:  MOVLW  01
05E80:  ADDWFC x5A,W
05E82:  MOVWF  FEA
05E84:  MOVLW  DB
05E86:  MOVWF  FEF
05E88:  BRA    5F20
....................        
....................       //Special ESC character was encountered in the last iteration but present byte is invalid 
....................       else if(RX_KISSframe[k-1]==FESC && !(RX_KISSframe[k]==TFEND || RX_KISSframe[k]==TFESC)) 
05E8A:  MOVLW  01
05E8C:  SUBWF  x57,W
05E8E:  MOVWF  x59
05E90:  MOVLW  00
05E92:  SUBWFB x58,W
05E94:  MOVWF  x5A
05E96:  MOVLW  2D
05E98:  ADDWF  x59,W
05E9A:  MOVWF  FE9
05E9C:  MOVLW  01
05E9E:  ADDWFC x5A,W
05EA0:  MOVWF  FEA
05EA2:  MOVF   FEF,W
05EA4:  SUBLW  DB
05EA6:  BNZ   5ED4
05EA8:  MOVLW  2D
05EAA:  ADDWF  x57,W
05EAC:  MOVWF  FE9
05EAE:  MOVLW  01
05EB0:  ADDWFC x58,W
05EB2:  MOVWF  FEA
05EB4:  MOVF   FEF,W
05EB6:  SUBLW  DC
05EB8:  BZ    5ED4
05EBA:  MOVLW  2D
05EBC:  ADDWF  x57,W
05EBE:  MOVWF  FE9
05EC0:  MOVLW  01
05EC2:  ADDWFC x58,W
05EC4:  MOVWF  FEA
05EC6:  MOVF   FEF,W
05EC8:  SUBLW  DD
05ECA:  BZ    5ED4
....................       { 
....................          RX_AX25packet_len = 0; 
05ECC:  CLRF   x56
05ECE:  CLRF   x55
....................          break; 
05ED0:  BRA    5F28
....................       } 
05ED2:  BRA    5F20
....................  
....................       //Special ESC character encountered so examine the next byte 
....................       else if (RX_KISSframe[k]==FESC) continue;    //Escape mode 
05ED4:  MOVLW  2D
05ED6:  ADDWF  x57,W
05ED8:  MOVWF  FE9
05EDA:  MOVLW  01
05EDC:  ADDWFC x58,W
05EDE:  MOVWF  FEA
05EE0:  MOVF   FEF,W
05EE2:  SUBLW  DB
05EE4:  BNZ   5EEA
05EE6:  BRA    5F20
05EE8:  BRA    5F20
....................        
....................       //No special character, just copy the received data as it is 
....................       else RX_packet[RX_AX25packet_len++]=RX_KISSframe[k]; 
05EEA:  MOVFF  C56,C5A
05EEE:  MOVF   x55,W
05EF0:  INCF   x55,F
05EF2:  BTFSC  FD8.2
05EF4:  INCF   x56,F
05EF6:  MOVWF  x59
05EF8:  MOVLW  62
05EFA:  ADDWF  x59,W
05EFC:  MOVWF  01
05EFE:  MOVLW  01
05F00:  ADDWFC x5A,W
05F02:  MOVWF  03
05F04:  MOVLW  2D
05F06:  ADDWF  x57,W
05F08:  MOVWF  FE9
05F0A:  MOVLW  01
05F0C:  ADDWFC x58,W
05F0E:  MOVWF  FEA
05F10:  MOVFF  FEF,C5D
05F14:  MOVFF  03,FEA
05F18:  MOVFF  01,FE9
05F1C:  MOVFF  C5D,FEF
05F20:  INCF   x57,F
05F22:  BTFSC  FD8.2
05F24:  INCF   x58,F
05F26:  BRA    5DC4
....................     
....................    } 
....................    return RX_AX25packet_len; 
05F28:  MOVFF  C55,01
05F2C:  MOVFF  C56,02
05F30:  MOVLB  0
05F32:  GOTO   717E (RETURN)
.................... } 
....................  
....................  
....................        
.................... int8 parse_received_packet() 
*
060D8:  MOVLB  C
060DA:  CLRF   x50
060DC:  CLRF   x4F
.................... { 
....................  
....................    unsigned int16 index = 0; 
....................    
....................    for(index=0; index<6; index++)  RX_callsign_dest[index] = RX_packet[index];  
060DE:  CLRF   x50
060E0:  CLRF   x4F
060E2:  MOVF   x50,F
060E4:  BNZ   6122
060E6:  MOVF   x4F,W
060E8:  SUBLW  05
060EA:  BNC   6122
060EC:  MOVLW  62
060EE:  ADDWF  x4F,W
060F0:  MOVWF  01
060F2:  MOVLW  03
060F4:  ADDWFC x50,W
060F6:  MOVWF  03
060F8:  MOVFF  01,C58
060FC:  MOVWF  x59
060FE:  MOVLW  62
06100:  ADDWF  x4F,W
06102:  MOVWF  FE9
06104:  MOVLW  01
06106:  ADDWFC x50,W
06108:  MOVWF  FEA
0610A:  MOVFF  FEF,C5A
0610E:  MOVFF  03,FEA
06112:  MOVFF  01,FE9
06116:  MOVFF  C5A,FEF
0611A:  INCF   x4F,F
0611C:  BTFSC  FD8.2
0611E:  INCF   x50,F
06120:  BRA    60E2
....................    RX_SSID_dest = RX_packet[6]; 
06122:  MOVFF  168,369
....................    //fprintf(debugPort,"RX_callsign_dest:%s\r\n",RX_callsign_dest); 
....................     
....................    for(index=7; index<13; index++)  RX_callsign_source[index-7] = RX_packet[index];  
06126:  CLRF   x50
06128:  MOVLW  07
0612A:  MOVWF  x4F
0612C:  MOVF   x50,F
0612E:  BNZ   6178
06130:  MOVF   x4F,W
06132:  SUBLW  0C
06134:  BNC   6178
06136:  MOVLW  07
06138:  SUBWF  x4F,W
0613A:  MOVWF  x58
0613C:  MOVLW  00
0613E:  SUBWFB x50,W
06140:  MOVWF  x59
06142:  MOVLW  6A
06144:  ADDWF  x58,W
06146:  MOVWF  01
06148:  MOVLW  03
0614A:  ADDWFC x59,W
0614C:  MOVWF  03
0614E:  MOVFF  01,C5A
06152:  MOVWF  x5B
06154:  MOVLW  62
06156:  ADDWF  x4F,W
06158:  MOVWF  FE9
0615A:  MOVLW  01
0615C:  ADDWFC x50,W
0615E:  MOVWF  FEA
06160:  MOVFF  FEF,C5C
06164:  MOVFF  03,FEA
06168:  MOVFF  01,FE9
0616C:  MOVFF  C5C,FEF
06170:  INCF   x4F,F
06172:  BTFSC  FD8.2
06174:  INCF   x50,F
06176:  BRA    612C
....................    RX_SSID_source = RX_packet[13]; 
06178:  MOVFF  16F,371
....................    //fprintf(debugPort,"RX_callsign_source:%s\r\n",RX_callsign_source); 
....................     
....................    RX_control = RX_packet[14]; 
0617C:  MOVFF  170,372
....................    RX_PID = RX_packet[15]; 
06180:  MOVFF  171,373
....................     
....................    for(index=16; index<RX_packet_len; index++)  RX_info_field[index-16] = RX_packet[index];  
06184:  CLRF   x50
06186:  MOVLW  10
06188:  MOVWF  x4F
0618A:  MOVF   x50,W
0618C:  MOVLB  1
0618E:  SUBWF  x61,W
06190:  BNC   61E8
06192:  BNZ   61A2
06194:  MOVF   x60,W
06196:  MOVLB  C
06198:  SUBWF  x4F,W
0619A:  BTFSS  FD8.0
0619C:  BRA    61A2
0619E:  MOVLB  1
061A0:  BRA    61E8
061A2:  MOVLW  10
061A4:  MOVLB  C
061A6:  SUBWF  x4F,W
061A8:  MOVWF  x58
061AA:  MOVLW  00
061AC:  SUBWFB x50,W
061AE:  MOVWF  x59
061B0:  MOVLW  74
061B2:  ADDWF  x58,W
061B4:  MOVWF  01
061B6:  MOVLW  03
061B8:  ADDWFC x59,W
061BA:  MOVWF  03
061BC:  MOVFF  01,C5A
061C0:  MOVWF  x5B
061C2:  MOVLW  62
061C4:  ADDWF  x4F,W
061C6:  MOVWF  FE9
061C8:  MOVLW  01
061CA:  ADDWFC x50,W
061CC:  MOVWF  FEA
061CE:  MOVFF  FEF,C5C
061D2:  MOVFF  03,FEA
061D6:  MOVFF  01,FE9
061DA:  MOVFF  C5C,FEF
061DE:  INCF   x4F,F
061E0:  BTFSC  FD8.2
061E2:  INCF   x50,F
061E4:  BRA    618A
061E6:  MOVLB  1
....................    //fprintf(debugPort,"RX_info_field:%s\r\n",RX_info_field); 
....................     
....................     
....................    //print parsed data 
....................    //puts(""); 
....................    fprintf(debugPort,"RX_callsign_dest: %s \r\n", RX_callsign_dest); 
061E8:  MOVLW  1E
061EA:  MOVWF  FF6
061EC:  MOVLW  03
061EE:  MOVWF  FF7
061F0:  MOVLW  00
061F2:  MOVWF  FF8
061F4:  CLRF   1B
061F6:  BTFSC  FF2.7
061F8:  BSF    1B.7
061FA:  BCF    FF2.7
061FC:  MOVLW  12
061FE:  MOVLB  C
06200:  MOVWF  x9A
06202:  MOVLB  0
06204:  CALL   05B8
06208:  BTFSC  1B.7
0620A:  BSF    FF2.7
0620C:  MOVLW  03
0620E:  MOVWF  FEA
06210:  MOVLW  62
06212:  MOVWF  FE9
06214:  RCALL  5A4E
06216:  MOVLW  32
06218:  MOVWF  FF6
0621A:  MOVLW  03
0621C:  MOVWF  FF7
0621E:  MOVLW  00
06220:  MOVWF  FF8
06222:  CLRF   1B
06224:  BTFSC  FF2.7
06226:  BSF    1B.7
06228:  BCF    FF2.7
0622A:  MOVLW  03
0622C:  MOVLB  C
0622E:  MOVWF  x9A
06230:  MOVLB  0
06232:  CALL   05B8
06236:  BTFSC  1B.7
06238:  BSF    FF2.7
....................    //puts(""); 
....................     
....................    fprintf(debugPort,"RX_SSID_dest: %c", RX_SSID_dest); 
0623A:  MOVLW  36
0623C:  MOVWF  FF6
0623E:  MOVLW  03
06240:  MOVWF  FF7
06242:  MOVLW  00
06244:  MOVWF  FF8
06246:  CLRF   1B
06248:  BTFSC  FF2.7
0624A:  BSF    1B.7
0624C:  BCF    FF2.7
0624E:  MOVLW  0E
06250:  MOVLB  C
06252:  MOVWF  x9A
06254:  MOVLB  0
06256:  CALL   05B8
0625A:  BTFSC  1B.7
0625C:  BSF    FF2.7
0625E:  CLRF   1B
06260:  BTFSC  FF2.7
06262:  BSF    1B.7
06264:  BCF    FF2.7
06266:  MOVFF  369,C9E
0626A:  CALL   054A
0626E:  BTFSC  1B.7
06270:  BSF    FF2.7
....................    //puts(""); 
....................  
....................    fprintf(debugPort,"RX_callsign_source: %s \r\n", RX_callsign_source); 
06272:  MOVLW  48
06274:  MOVWF  FF6
06276:  MOVLW  03
06278:  MOVWF  FF7
0627A:  MOVLW  00
0627C:  MOVWF  FF8
0627E:  CLRF   1B
06280:  BTFSC  FF2.7
06282:  BSF    1B.7
06284:  BCF    FF2.7
06286:  MOVLW  14
06288:  MOVLB  C
0628A:  MOVWF  x9A
0628C:  MOVLB  0
0628E:  CALL   05B8
06292:  BTFSC  1B.7
06294:  BSF    FF2.7
06296:  MOVLW  03
06298:  MOVWF  FEA
0629A:  MOVLW  6A
0629C:  MOVWF  FE9
0629E:  CALL   5A4E
062A2:  MOVLW  5E
062A4:  MOVWF  FF6
062A6:  MOVLW  03
062A8:  MOVWF  FF7
062AA:  MOVLW  00
062AC:  MOVWF  FF8
062AE:  CLRF   1B
062B0:  BTFSC  FF2.7
062B2:  BSF    1B.7
062B4:  BCF    FF2.7
062B6:  MOVLW  03
062B8:  MOVLB  C
062BA:  MOVWF  x9A
062BC:  MOVLB  0
062BE:  CALL   05B8
062C2:  BTFSC  1B.7
062C4:  BSF    FF2.7
....................    //puts(""); 
....................     
....................    fprintf(debugPort,"RX_SSID_source: %c \r\n", RX_SSID_source); 
062C6:  MOVLW  62
062C8:  MOVWF  FF6
062CA:  MOVLW  03
062CC:  MOVWF  FF7
062CE:  MOVLW  00
062D0:  MOVWF  FF8
062D2:  CLRF   1B
062D4:  BTFSC  FF2.7
062D6:  BSF    1B.7
062D8:  BCF    FF2.7
062DA:  MOVLW  10
062DC:  MOVLB  C
062DE:  MOVWF  x9A
062E0:  MOVLB  0
062E2:  CALL   05B8
062E6:  BTFSC  1B.7
062E8:  BSF    FF2.7
062EA:  CLRF   1B
062EC:  BTFSC  FF2.7
062EE:  BSF    1B.7
062F0:  BCF    FF2.7
062F2:  MOVFF  371,C9E
062F6:  CALL   054A
062FA:  BTFSC  1B.7
062FC:  BSF    FF2.7
062FE:  MOVLW  74
06300:  MOVWF  FF6
06302:  MOVLW  03
06304:  MOVWF  FF7
06306:  MOVLW  00
06308:  MOVWF  FF8
0630A:  CLRF   1B
0630C:  BTFSC  FF2.7
0630E:  BSF    1B.7
06310:  BCF    FF2.7
06312:  MOVLW  03
06314:  MOVLB  C
06316:  MOVWF  x9A
06318:  MOVLB  0
0631A:  CALL   05B8
0631E:  BTFSC  1B.7
06320:  BSF    FF2.7
....................    //puts(""); 
....................  
....................    fprintf(debugPort,"RX_control: %x \r\n", RX_control); 
06322:  MOVLW  78
06324:  MOVWF  FF6
06326:  MOVLW  03
06328:  MOVWF  FF7
0632A:  MOVLW  00
0632C:  MOVWF  FF8
0632E:  CLRF   1B
06330:  BTFSC  FF2.7
06332:  BSF    1B.7
06334:  BCF    FF2.7
06336:  MOVLW  0C
06338:  MOVLB  C
0633A:  MOVWF  x9A
0633C:  MOVLB  0
0633E:  CALL   05B8
06342:  BTFSC  1B.7
06344:  BSF    FF2.7
06346:  CLRF   1B
06348:  BTFSC  FF2.7
0634A:  BSF    1B.7
0634C:  BCF    FF2.7
0634E:  MOVFF  372,C9A
06352:  MOVLW  57
06354:  MOVLB  C
06356:  MOVWF  x9B
06358:  MOVLB  0
0635A:  CALL   05E8
0635E:  BTFSC  1B.7
06360:  BSF    FF2.7
06362:  MOVLW  86
06364:  MOVWF  FF6
06366:  MOVLW  03
06368:  MOVWF  FF7
0636A:  MOVLW  00
0636C:  MOVWF  FF8
0636E:  CLRF   1B
06370:  BTFSC  FF2.7
06372:  BSF    1B.7
06374:  BCF    FF2.7
06376:  MOVLW  03
06378:  MOVLB  C
0637A:  MOVWF  x9A
0637C:  MOVLB  0
0637E:  CALL   05B8
06382:  BTFSC  1B.7
06384:  BSF    FF2.7
....................    //puts(""); 
....................     
....................    fprintf(debugPort,"RX_PID: %x \r\n", RX_PID); 
06386:  MOVLW  8A
06388:  MOVWF  FF6
0638A:  MOVLW  03
0638C:  MOVWF  FF7
0638E:  MOVLW  00
06390:  MOVWF  FF8
06392:  CLRF   1B
06394:  BTFSC  FF2.7
06396:  BSF    1B.7
06398:  BCF    FF2.7
0639A:  MOVLW  08
0639C:  MOVLB  C
0639E:  MOVWF  x9A
063A0:  MOVLB  0
063A2:  CALL   05B8
063A6:  BTFSC  1B.7
063A8:  BSF    FF2.7
063AA:  CLRF   1B
063AC:  BTFSC  FF2.7
063AE:  BSF    1B.7
063B0:  BCF    FF2.7
063B2:  MOVFF  373,C9A
063B6:  MOVLW  57
063B8:  MOVLB  C
063BA:  MOVWF  x9B
063BC:  MOVLB  0
063BE:  CALL   05E8
063C2:  BTFSC  1B.7
063C4:  BSF    FF2.7
063C6:  MOVLW  94
063C8:  MOVWF  FF6
063CA:  MOVLW  03
063CC:  MOVWF  FF7
063CE:  MOVLW  00
063D0:  MOVWF  FF8
063D2:  CLRF   1B
063D4:  BTFSC  FF2.7
063D6:  BSF    1B.7
063D8:  BCF    FF2.7
063DA:  MOVLW  03
063DC:  MOVLB  C
063DE:  MOVWF  x9A
063E0:  MOVLB  0
063E2:  CALL   05B8
063E6:  BTFSC  1B.7
063E8:  BSF    FF2.7
....................    //puts(""); 
....................     
....................    //transmit_UARTdata((unsigned char*)"RX_info_field: ",15); 
....................    //transmit_UARTdata(RX_info_field,RX_packet_len-16); 
....................    //puts(""); 
....................     
....................    fprintf(debugPort,"RX_packet_len: %li \r\n", RX_packet_len); 
063EA:  MOVLW  98
063EC:  MOVWF  FF6
063EE:  MOVLW  03
063F0:  MOVWF  FF7
063F2:  MOVLW  00
063F4:  MOVWF  FF8
063F6:  CLRF   1B
063F8:  BTFSC  FF2.7
063FA:  BSF    1B.7
063FC:  BCF    FF2.7
063FE:  MOVLW  0F
06400:  MOVLB  C
06402:  MOVWF  x9A
06404:  MOVLB  0
06406:  CALL   05B8
0640A:  BTFSC  1B.7
0640C:  BSF    FF2.7
0640E:  MOVLW  10
06410:  MOVWF  FE9
06412:  MOVFF  161,C5B
06416:  MOVFF  160,C5A
0641A:  RCALL  5F36
0641C:  MOVLW  AA
0641E:  MOVWF  FF6
06420:  MOVLW  03
06422:  MOVWF  FF7
06424:  MOVLW  00
06426:  MOVWF  FF8
06428:  CLRF   1B
0642A:  BTFSC  FF2.7
0642C:  BSF    1B.7
0642E:  BCF    FF2.7
06430:  MOVLW  03
06432:  MOVLB  C
06434:  MOVWF  x9A
06436:  MOVLB  0
06438:  CALL   05B8
0643C:  BTFSC  1B.7
0643E:  BSF    FF2.7
....................    //puts(""); 
....................  
....................    fprintf(debugPort,"RX_info_field length: %li \r\n", RX_packet_len-16); 
06440:  MOVLW  10
06442:  MOVLB  1
06444:  SUBWF  x60,W
06446:  MOVLB  C
06448:  MOVWF  x58
0644A:  MOVLW  00
0644C:  MOVLB  1
0644E:  SUBWFB x61,W
06450:  MOVLB  C
06452:  MOVWF  x59
06454:  MOVLW  AE
06456:  MOVWF  FF6
06458:  MOVLW  03
0645A:  MOVWF  FF7
0645C:  MOVLW  00
0645E:  MOVWF  FF8
06460:  CLRF   1B
06462:  BTFSC  FF2.7
06464:  BSF    1B.7
06466:  BCF    FF2.7
06468:  MOVLW  16
0646A:  MOVWF  x9A
0646C:  MOVLB  0
0646E:  CALL   05B8
06472:  BTFSC  1B.7
06474:  BSF    FF2.7
06476:  MOVLW  10
06478:  MOVWF  FE9
0647A:  MOVFF  C59,C5B
0647E:  MOVFF  C58,C5A
06482:  RCALL  5F36
06484:  MOVLW  C7
06486:  MOVWF  FF6
06488:  MOVLW  03
0648A:  MOVWF  FF7
0648C:  MOVLW  00
0648E:  MOVWF  FF8
06490:  CLRF   1B
06492:  BTFSC  FF2.7
06494:  BSF    1B.7
06496:  BCF    FF2.7
06498:  MOVLW  03
0649A:  MOVLB  C
0649C:  MOVWF  x9A
0649E:  MOVLB  0
064A0:  CALL   05B8
064A4:  BTFSC  1B.7
064A6:  BSF    FF2.7
....................    //puts("");   
....................     
....................    
....................    if( strncmp(RX_callsign_dest,RX_DEST_CALLSIGN,6)==0 &&  
....................        RX_info_field[0] == info_header[0] &&  
....................        RX_info_field[1] == info_header[1] && 
....................        RX_info_field[RX_packet_len-16-2] == info_footer[0] && 
....................        RX_info_field[RX_packet_len-16-1] == info_footer[1] 
064A8:  MOVLW  0C
064AA:  MOVWF  FEA
064AC:  MOVLW  51
064AE:  MOVWF  FE9
064B0:  MOVLW  07
064B2:  MOVWF  01
064B4:  CLRF   FF7
064B6:  MOVLW  00
064B8:  CALL   00CA
064BC:  TBLRD*-
064BE:  TBLRD*+
064C0:  MOVFF  FF5,FEE
064C4:  DECFSZ 01,F
064C6:  BRA    64BE
064C8:  MOVLW  03
064CA:  MOVLB  C
064CC:  MOVWF  x5B
064CE:  MOVLW  62
064D0:  MOVWF  x5A
064D2:  MOVLW  0C
064D4:  MOVWF  x5D
064D6:  MOVLW  51
064D8:  MOVWF  x5C
064DA:  CLRF   x5F
064DC:  MOVLW  06
064DE:  MOVWF  x5E
064E0:  MOVLB  0
064E2:  RCALL  6042
064E4:  MOVF   01,F
064E6:  BNZ   659A
064E8:  MOVLB  4
064EA:  MOVF   x74,W
064EC:  MOVLB  3
064EE:  SUBWF  x74,W
064F0:  BTFSC  FD8.2
064F2:  BRA    64F8
064F4:  MOVLB  0
064F6:  BRA    659A
064F8:  MOVLB  4
064FA:  MOVF   x75,W
064FC:  MOVLB  3
064FE:  SUBWF  x75,W
06500:  BTFSC  FD8.2
06502:  BRA    6508
06504:  MOVLB  0
06506:  BRA    659A
06508:  MOVLW  10
0650A:  MOVLB  1
0650C:  SUBWF  x60,W
0650E:  MOVLB  C
06510:  MOVWF  x5A
06512:  MOVLW  00
06514:  MOVLB  1
06516:  SUBWFB x61,W
06518:  MOVLB  C
0651A:  MOVWF  x5B
0651C:  MOVLW  02
0651E:  SUBWF  x5A,F
06520:  MOVLW  00
06522:  SUBWFB x5B,F
06524:  MOVLW  74
06526:  ADDWF  x5A,W
06528:  MOVWF  FE9
0652A:  MOVLW  03
0652C:  ADDWFC x5B,W
0652E:  MOVWF  FEA
06530:  MOVLB  4
06532:  MOVF   x76,W
06534:  SUBWF  FEF,W
06536:  BTFSC  FD8.2
06538:  BRA    653E
0653A:  MOVLB  0
0653C:  BRA    659A
0653E:  MOVLW  10
06540:  MOVLB  1
06542:  SUBWF  x60,W
06544:  MOVLB  C
06546:  MOVWF  x5C
06548:  MOVLW  00
0654A:  MOVLB  1
0654C:  SUBWFB x61,W
0654E:  MOVLB  C
06550:  MOVWF  x5D
06552:  MOVLW  01
06554:  SUBWF  x5C,F
06556:  MOVLW  00
06558:  SUBWFB x5D,F
0655A:  MOVLW  74
0655C:  ADDWF  x5C,W
0655E:  MOVWF  FE9
06560:  MOVLW  03
06562:  ADDWFC x5D,W
06564:  MOVWF  FEA
06566:  MOVLB  4
06568:  MOVF   x77,W
0656A:  SUBWF  FEF,W
0656C:  BTFSC  FD8.2
0656E:  BRA    6574
06570:  MOVLB  0
06572:  BRA    659A
....................      ) 
....................    { 
....................       fprintf(debugPort,"Valid S&F packet! \r\n"); 
06574:  MOVLW  CC
06576:  MOVWF  FF6
06578:  MOVLW  03
0657A:  MOVWF  FF7
0657C:  MOVLW  00
0657E:  MOVWF  FF8
06580:  CLRF   1B
06582:  BTFSC  FF2.7
06584:  BSF    1B.7
06586:  BCF    FF2.7
06588:  MOVLB  0
0658A:  CALL   0590
0658E:  BTFSC  1B.7
06590:  BSF    FF2.7
....................       return 1;    //Valid S&F packet 
06592:  MOVLW  01
06594:  MOVWF  01
06596:  BRA    6652
....................    } 
06598:  BRA    6652
....................     
....................     
....................    else if(  RX_packet_len == 30 && /*Excluding FCS*/ 
....................              strncmp(RX_callsign_dest,RX_DEST_CALLSIGN,6)==0 && 
....................              RX_info_field[0] == 0xAA &&  
....................              RX_info_field[13] == 0xEE 
0659A:  MOVLB  1
0659C:  MOVF   x60,W
0659E:  SUBLW  1E
065A0:  BNZ   6630
065A2:  MOVF   x61,F
065A4:  BNZ   6630
065A6:  MOVLW  0C
065A8:  MOVWF  FEA
065AA:  MOVLW  51
065AC:  MOVWF  FE9
065AE:  MOVLW  07
065B0:  MOVWF  01
065B2:  CLRF   FF7
065B4:  MOVLW  00
065B6:  MOVLB  0
065B8:  CALL   00CA
065BC:  TBLRD*-
065BE:  TBLRD*+
065C0:  MOVFF  FF5,FEE
065C4:  DECFSZ 01,F
065C6:  BRA    65BE
065C8:  MOVLW  03
065CA:  MOVLB  C
065CC:  MOVWF  x5B
065CE:  MOVLW  62
065D0:  MOVWF  x5A
065D2:  MOVLW  0C
065D4:  MOVWF  x5D
065D6:  MOVLW  51
065D8:  MOVWF  x5C
065DA:  CLRF   x5F
065DC:  MOVLW  06
065DE:  MOVWF  x5E
065E0:  MOVLB  0
065E2:  RCALL  6042
065E4:  MOVF   01,F
065E6:  BTFSC  FD8.2
065E8:  BRA    65EE
065EA:  MOVLB  1
065EC:  BRA    6630
065EE:  MOVLB  3
065F0:  MOVF   x74,W
065F2:  SUBLW  AA
065F4:  BTFSC  FD8.2
065F6:  BRA    65FC
065F8:  MOVLB  1
065FA:  BRA    6630
065FC:  MOVF   x81,W
065FE:  SUBLW  EE
06600:  BTFSC  FD8.2
06602:  BRA    6608
06604:  MOVLB  1
06606:  BRA    6630
....................           ) 
....................    { 
....................       fprintf(debugPort,"Command uplink packet from BIRDS GS! \r\n"); 
06608:  MOVLW  E2
0660A:  MOVWF  FF6
0660C:  MOVLW  03
0660E:  MOVWF  FF7
06610:  MOVLW  00
06612:  MOVWF  FF8
06614:  CLRF   1B
06616:  BTFSC  FF2.7
06618:  BSF    1B.7
0661A:  BCF    FF2.7
0661C:  MOVLB  0
0661E:  CALL   0590
06622:  BTFSC  1B.7
06624:  BSF    FF2.7
....................       return 2;    //Valid S&F packet 
06626:  MOVLW  02
06628:  MOVWF  01
0662A:  BRA    6652
....................    }    
0662C:  BRA    6652
0662E:  MOVLB  1
....................  
....................  
....................  
....................    else 
....................    {   
....................       fprintf(debugPort,"Invalid S&F packet! \r\n"); 
06630:  MOVLW  0A
06632:  MOVWF  FF6
06634:  MOVLW  04
06636:  MOVWF  FF7
06638:  MOVLW  00
0663A:  MOVWF  FF8
0663C:  CLRF   1B
0663E:  BTFSC  FF2.7
06640:  BSF    1B.7
06642:  BCF    FF2.7
06644:  MOVLB  0
06646:  CALL   0590
0664A:  BTFSC  1B.7
0664C:  BSF    FF2.7
....................       return 0;   //Invalid S&F packet 
0664E:  MOVLW  00
06650:  MOVWF  01
....................    } 
06652:  GOTO   7318 (RETURN)
....................     
....................     
.................... } 
....................  
.................... /* 
.................... int8 sendingAX25(void) 
.................... { 
.................... //   int8 SendData[] = {0x86,   0xA2,  0x40,  0x40,  0x40,  0x40,  0x60,  0xAE,  0x64,  0x8C,  0xA6, 0x40,   0x40,   0x68, 0xA4, 0x8A,  0x98,  0x82,   0xB2,  0x40,   0x61,  0x03, 0xF0,   0x54,   0x65,  0x73, 0x74}; 
....................    int8 SendData[] = {0x43,   0x51,  0x20,  0x20,  0x20,  0x20,  0x60,  0xAE,  0x64,  0x8C,  0xA6, 0x40,   0x40,   0x68, 0xA4, 0x8A,  0x98,  0x82,   0xB2,  0x40,   0x61,  0x03, 0xF0,   0x54,   0x65,  0x73, 0x74}; 
....................  
....................     
....................     
....................    #define AX25_MAX_length 100 
....................     
....................    int8 AX25_packet[AX25_MAX_length]; 
....................    int8 AX25_info[]="HelloWorld"; 
....................    int8 callsign_dest[]="JG6YBW"; 
....................    int8 callsign_source[]="BIRDS4"; 
....................    int8 SSID_dest=0x30; 
....................    int8 SSID_source=0x30; 
....................    int8 AX25_control= 0x3E;                                 
....................    int8 AX25_PID= 0xF0; 
.................... //!   int8 SSID_dest=0x61; 
.................... //!   int8 SSID_source=0x60; 
.................... //!   int8 AX25_control= 0x03;                                 
.................... //!   int8 AX25_PID= 0xF0; 
....................    int8 AX25_length=sizeof(AX25_info)+16; 
....................    int8 counter; 
....................    int16 index = 0; 
....................    int8 tx_delay=5; 
....................    counter=0; 
....................    while (counter<6)  
....................    {AX25_packet[index++]=callsign_source[counter++];} 
....................    AX25_packet[index++]=SSID_source; 
....................     
....................    counter=0; 
....................    while (counter<6)  
....................    {AX25_packet[index++]=callsign_dest[counter++];} 
....................    AX25_packet[index++]=SSID_dest; 
....................     
....................     
....................    AX25_packet[index++]=AX25_control; 
....................    AX25_packet[index++]=AX25_PID; 
....................     
....................    counter=0; 
....................    while (counter<sizeof(AX25_info))  
....................    {AX25_packet[index++]=AX25_info[counter++];} 
....................     
....................    AX25_length=index; 
....................     
....................     
....................    //for(index=0; index<6; index++)  AX25_packet[index]=callsign_source[index];  
....................    //AX25_packet[6]=SSID_source; 
....................     
....................     
....................     
....................    //for(index=7; index<13; index++)  AX25_packet[index]=callsign_dest[index-7];  
....................    //AX25_packet[13]=SSID_dest; 
....................    //fprintf(debugPort,"RX_callsign_source:%s\r\n",RX_callsign_source); 
....................  
....................    //AX25_packet[14]=AX25_control; 
....................    //AX25_packet[15]=AX25_PID; 
....................  
....................    //for(index=16; index<AX25_length-1; index++)  AX25_packet[index]=AX25_info[index-16];  
....................     
....................  
....................  
.................... //! 
.................... //!   for(index=0; index<sizeof(SendData); index++)   
.................... //!   { 
.................... //!      fprintf(debugPort,"%X ",SendData[index]); 
.................... //!      putc(SendData[index],serial2APRS); 
.................... //!      delay_ms(tx_delay); 
.................... //!   } 
.................... //!   putc('\r',serial2APRS); 
.................... //!   fprintf(debugPort,"\r\n"); 
.................... //!    
.................... //!delay_ms(2000); 
....................     
....................    for(index=0; index<AX25_length; index++)   
....................    { 
....................       fprintf(debugPort,"%X ",AX25_packet[index]); 
....................       putc(AX25_packet[index],serial2APRS); 
....................       delay_ms(tx_delay); 
....................    } 
....................    putc('\r',serial2APRS); 
....................    fprintf(debugPort,"\r\n"); 
.................... } 
....................  
.................... */ 
....................  
....................  
....................  
.................... int8 send_APRS(int8 APRS_packet_no, int8 *APRS_info) 
*
05B88:  CLRF   x62
05B8A:  CLRF   x61
05B8C:  MOVLW  05
05B8E:  MOVWF  x63
.................... { 
....................    int8 APRS_packet_info[4]; 
....................    //int8 APRS_info[]="HelloWorld"; 
....................    int8 packet_length; 
....................    //int8 dest_callsign[]="DV1PUI   "; 
....................    int8 dest_callsign[]="BIRDGS   "; 
*
05B64:  MOVLW  42
05B66:  MOVLB  C
05B68:  MOVWF  x57
05B6A:  MOVLW  49
05B6C:  MOVWF  x58
05B6E:  MOVLW  52
05B70:  MOVWF  x59
05B72:  MOVLW  44
05B74:  MOVWF  x5A
05B76:  MOVLW  47
05B78:  MOVWF  x5B
05B7A:  MOVLW  53
05B7C:  MOVWF  x5C
05B7E:  MOVLW  20
05B80:  MOVWF  x5D
05B82:  MOVWF  x5E
05B84:  MOVWF  x5F
05B86:  CLRF   x60
....................    int16 index = 0; 
....................    int8 tx_delay=5; 
....................    int8 APRS_packet_no_length; 
....................     
....................    if (APRS_packet_no<10) APRS_packet_no_length=1; 
*
05B90:  MOVF   x4F,W
05B92:  SUBLW  09
05B94:  BNC   5B9C
05B96:  MOVLW  01
05B98:  MOVWF  x64
05B9A:  BRA    5BA0
....................    else APRS_packet_no_length=2; 
05B9C:  MOVLW  02
05B9E:  MOVWF  x64
....................     
....................    fprintf(debugPort,"APRS_Packet:\r\n"); 
05BA0:  MOVLW  22
05BA2:  MOVWF  FF6
05BA4:  MOVLW  04
05BA6:  MOVWF  FF7
05BA8:  MOVLW  00
05BAA:  MOVWF  FF8
05BAC:  CLRF   1B
05BAE:  BTFSC  FF2.7
05BB0:  BSF    1B.7
05BB2:  BCF    FF2.7
05BB4:  MOVLB  0
05BB6:  CALL   0590
05BBA:  BTFSC  1B.7
05BBC:  BSF    FF2.7
05BBE:  CLRF   1B
05BC0:  BTFSC  FF2.7
05BC2:  BSF    1B.7
05BC4:  BCF    FF2.7
....................     
....................       fprintf(debugPort,"%c",':'); 
05BC6:  MOVLW  3A
05BC8:  MOVLB  C
05BCA:  MOVWF  x9E
05BCC:  MOVLB  0
05BCE:  CALL   054A
05BD2:  BTFSC  1B.7
05BD4:  BSF    FF2.7
....................       putc(':',serial2APRS); 
05BD6:  MOVLW  3A
05BD8:  RCALL  5A80
....................       delay_ms(tx_delay); 
05BDA:  MOVFF  C63,C86
05BDE:  CALL   0EE2
....................     
....................    for(index=0; index<9; index++) 
05BE2:  MOVLB  C
05BE4:  CLRF   x62
05BE6:  CLRF   x61
05BE8:  MOVF   x62,F
05BEA:  BNZ   5C3E
05BEC:  MOVF   x61,W
05BEE:  SUBLW  08
05BF0:  BNC   5C3E
....................    { 
....................       fprintf(debugPort,"%c",dest_callsign[index]); 
05BF2:  MOVLW  57
05BF4:  ADDWF  x61,W
05BF6:  MOVWF  FE9
05BF8:  MOVLW  0C
05BFA:  ADDWFC x62,W
05BFC:  MOVWF  FEA
05BFE:  MOVFF  FEF,C9E
05C02:  CLRF   1B
05C04:  BTFSC  FF2.7
05C06:  BSF    1B.7
05C08:  BCF    FF2.7
05C0A:  MOVLB  0
05C0C:  CALL   054A
05C10:  BTFSC  1B.7
05C12:  BSF    FF2.7
....................       putc(dest_callsign[index],serial2APRS); 
05C14:  MOVLW  57
05C16:  MOVLB  C
05C18:  ADDWF  x61,W
05C1A:  MOVWF  FE9
05C1C:  MOVLW  0C
05C1E:  ADDWFC x62,W
05C20:  MOVWF  FEA
05C22:  MOVFF  FEF,C65
05C26:  MOVF   x65,W
05C28:  MOVLB  0
05C2A:  RCALL  5A80
....................       delay_ms(tx_delay); 
05C2C:  MOVFF  C63,C86
05C30:  CALL   0EE2
05C34:  MOVLB  C
05C36:  INCF   x61,F
05C38:  BTFSC  FD8.2
05C3A:  INCF   x62,F
05C3C:  BRA    5BE8
05C3E:  CLRF   1B
05C40:  BTFSC  FF2.7
05C42:  BSF    1B.7
05C44:  BCF    FF2.7
....................    } 
....................        
....................       fprintf(debugPort,"%c",':'); 
05C46:  MOVLW  3A
05C48:  MOVWF  x9E
05C4A:  MOVLB  0
05C4C:  CALL   054A
05C50:  BTFSC  1B.7
05C52:  BSF    FF2.7
....................       putc(':',serial2APRS); 
05C54:  MOVLW  3A
05C56:  RCALL  5A80
....................       delay_ms(tx_delay); 
05C58:  MOVFF  C63,C86
05C5C:  CALL   0EE2
....................        
....................        
....................    for(index=0; index<(78); index++) 
05C60:  MOVLB  C
05C62:  CLRF   x62
05C64:  CLRF   x61
05C66:  MOVF   x62,F
05C68:  BNZ   5CBC
05C6A:  MOVF   x61,W
05C6C:  SUBLW  4D
05C6E:  BNC   5CBC
....................    { 
....................    fprintf(debugPort,"%c",APRS_info[index]); 
05C70:  MOVF   x50,W
05C72:  ADDWF  x61,W
05C74:  MOVWF  FE9
05C76:  MOVF   x51,W
05C78:  ADDWFC x62,W
05C7A:  MOVWF  FEA
05C7C:  MOVFF  FEF,C9E
05C80:  CLRF   1B
05C82:  BTFSC  FF2.7
05C84:  BSF    1B.7
05C86:  BCF    FF2.7
05C88:  MOVLB  0
05C8A:  CALL   054A
05C8E:  BTFSC  1B.7
05C90:  BSF    FF2.7
....................    putc(APRS_info[index],serial2APRS); 
05C92:  MOVLB  C
05C94:  MOVF   x50,W
05C96:  ADDWF  x61,W
05C98:  MOVWF  FE9
05C9A:  MOVF   x51,W
05C9C:  ADDWFC x62,W
05C9E:  MOVWF  FEA
05CA0:  MOVFF  FEF,C65
05CA4:  MOVF   x65,W
05CA6:  MOVLB  0
05CA8:  RCALL  5A80
....................    delay_ms(tx_delay); 
05CAA:  MOVFF  C63,C86
05CAE:  CALL   0EE2
05CB2:  MOVLB  C
05CB4:  INCF   x61,F
05CB6:  BTFSC  FD8.2
05CB8:  INCF   x62,F
05CBA:  BRA    5C66
....................    } 
....................     
....................  
....................    sprintf(APRS_packet_info,"%c%u",'{',APRS_packet_no); 
05CBC:  MOVLW  0C
05CBE:  MOVWF  20
05CC0:  MOVLW  52
05CC2:  MOVWF  1F
05CC4:  MOVLW  7B
05CC6:  MOVWF  x67
05CC8:  MOVLB  0
05CCA:  RCALL  5974
05CCC:  MOVFF  C4F,C65
05CD0:  MOVLW  1B
05CD2:  MOVLB  C
05CD4:  MOVWF  x66
05CD6:  MOVLB  0
05CD8:  BRA    5A8C
....................    packet_length=strlen(APRS_packet_info); 
05CDA:  MOVLW  0C
05CDC:  MOVLB  C
05CDE:  MOVWF  x66
05CE0:  MOVLW  52
05CE2:  MOVWF  x65
05CE4:  MOVLB  0
05CE6:  BRA    5B26
05CE8:  MOVFF  01,C56
....................    //packet_length=sizeof(APRS_packet_info); 
....................    //fprintf(debugPort,"packet_length=%u\r\n",packet_length); 
....................    //fprintf(debugPort,"%s\r\n",APRS_packet_info); 
....................     
....................  
....................    for(index=0; index<packet_length; index++) 
05CEC:  MOVLB  C
05CEE:  CLRF   x62
05CF0:  CLRF   x61
05CF2:  MOVF   x62,F
05CF4:  BNZ   5D48
05CF6:  MOVF   x56,W
05CF8:  SUBWF  x61,W
05CFA:  BC    5D48
....................    { 
....................       fprintf(debugPort,"%c",APRS_packet_info[index]); 
05CFC:  MOVLW  52
05CFE:  ADDWF  x61,W
05D00:  MOVWF  FE9
05D02:  MOVLW  0C
05D04:  ADDWFC x62,W
05D06:  MOVWF  FEA
05D08:  MOVFF  FEF,C9E
05D0C:  CLRF   1B
05D0E:  BTFSC  FF2.7
05D10:  BSF    1B.7
05D12:  BCF    FF2.7
05D14:  MOVLB  0
05D16:  CALL   054A
05D1A:  BTFSC  1B.7
05D1C:  BSF    FF2.7
....................       putc(APRS_packet_info[index],serial2APRS); 
05D1E:  MOVLW  52
05D20:  MOVLB  C
05D22:  ADDWF  x61,W
05D24:  MOVWF  FE9
05D26:  MOVLW  0C
05D28:  ADDWFC x62,W
05D2A:  MOVWF  FEA
05D2C:  MOVFF  FEF,C65
05D30:  MOVF   x65,W
05D32:  MOVLB  0
05D34:  RCALL  5A80
....................       delay_ms(tx_delay); 
05D36:  MOVFF  C63,C86
05D3A:  CALL   0EE2
05D3E:  MOVLB  C
05D40:  INCF   x61,F
05D42:  BTFSC  FD8.2
05D44:  INCF   x62,F
05D46:  BRA    5CF2
....................    } 
....................    putc('\r',serial2APRS); 
05D48:  MOVLW  0D
05D4A:  MOVLB  0
05D4C:  RCALL  5A80
05D4E:  CLRF   1B
05D50:  BTFSC  FF2.7
05D52:  BSF    1B.7
05D54:  BCF    FF2.7
....................    fprintf(debugPort,"\r\n"); 
05D56:  MOVLW  0D
05D58:  MOVLB  C
05D5A:  MOVWF  x9E
05D5C:  MOVLB  0
05D5E:  CALL   054A
05D62:  BTFSC  1B.7
05D64:  BSF    FF2.7
05D66:  CLRF   1B
05D68:  BTFSC  FF2.7
05D6A:  BSF    1B.7
05D6C:  BCF    FF2.7
05D6E:  MOVLW  0A
05D70:  MOVLB  C
05D72:  MOVWF  x9E
05D74:  MOVLB  0
05D76:  CALL   054A
05D7A:  BTFSC  1B.7
05D7C:  BSF    FF2.7
05D7E:  RETURN 0
....................     
....................    //delay_ms(200); 
.................... } 
....................  
....................  
....................  
....................     
....................  
....................  
.................... #define commandSizeMB 7 
.................... #define delayTX 10  // Confirmed working good for sending data to MB. 5ms is not working! 
.................... //#define dataSizeAPRS 300 // = (x) + info size.... x=39 for the first 10 bytes, x= 40 till 99 bytes 
.................... #define APRS_packet_max_length 300 
....................  
.................... int32 rcved_data_adrs; 
.................... int32 MyAdress; 
....................  
.................... int32 i=0; //defined in SFward_AX25 
.................... unsigned int1 actionMB=0; 
.................... unsigned int1 actionAPRS=0; 
.................... //*********************************** 
.................... int8 satellite_name[]="BIRDJP"; 
.................... //*********************************** 
.................... int8 callsign_size_SFward=0; 
.................... int8 paraguayCallsign_GS01[]="JG6YBW"; 
.................... int8 paraguayGS01_ID=0x11; 
.................... int8 philippineCallsign_GS01[]="JG6YBA"; 
.................... int8 philippineGS01_ID=0x22; 
.................... int8 japanCallsign_GS01[]="JG6YBC"; 
.................... int8 japanGS01_ID=0x33; 
.................... int8 GS_ID_SFward=0x00; 
....................  
.................... int8 senderCallsign[8]; 
.................... int8 info_size_SFward=0; 
.................... int8 Packet_no_APRS=0x99; 
.................... int8 info_APRS[67]; 
.................... int8 info_end_SFward[]={0x88,0x88}; 
....................  
.................... int8 byteNumAPRS=0; 
.................... unsigned int8 byteNumMB=0; 
.................... unsigned int8 rec_bytes_number_APRS=0; //CHANGE IT TO INT16 to receive bigger packets ( Might unleash issues!!! ) 
.................... unsigned int8 receivedDataMB=0; 
.................... unsigned int8 dataAPRS[APRS_packet_max_length]; 
.................... unsigned int8 commandLine[commandSizeMB];//={0,0,0,0,0,0,0,0}; 
.................... unsigned int8 lastCommandLine[commandSizeMB]; 
....................  
.................... int32 addressInTheCommand=0; 
....................  
.................... long packetLength=81; 
.................... //int32 packetLength = 81; 
....................  
....................  
.................... #define TLE_data_inFM 0x3000 
.................... #define TLE_size 35 
.................... int8 TLE_array[TLE_size]={1,2,3,4,5,6,7,1,2,3,4,5,6,7,1,2,3,4,5,6,7,1,2,3,4,5,6,7,1,2,3,4,5,6,7}; 
.................... int8 TLE_array_header[]="TLE"; 
....................  
.................... int8 packetsNoInTheCommand=0; 
.................... //unsigned int32 packetsNoInTheCommand=0; 
.................... int8 Command_00_ackMB=0x77; 
.................... int8 Command_DD_ackMB=0x33; 
.................... int8 need_restart_ackMB=0x44; 
.................... int1 isCommandData=0; 
.................... //int1 isSFwardData=0; 
.................... int1 isDuplicatedData=0; 
....................  
.................... #define satellite_info_pointer 0x00002000 // 00 00 20 00 
.................... #define SF_Data_start_Adrs 0x00011000 // 00 01 10 00 
.................... #define SF_Data_Addres_pointer 0x00010000 //  00 01 00 00 
....................  
.................... int32 SF_Data_Addres=SF_Data_start_Adrs; 
....................  
.................... unsigned int8 first_adsress[4]={0x00,0x01,0x10,0x00}; 
.................... unsigned int8 after_last_adsress[4]; 
....................  
.................... #define log_array_SFward_in_FM 0x6000 // 00 00 60 00 
.................... #define log_array_SFward_adrs_pointer 0x7000 // 00 00 70 00 
.................... int8 no_of_SFward_callsigns=0; 
.................... #define SFward_packet_array_columns 10 
.................... #define max_no_of_SFward_callsigns 100 
.................... int8 log_array_SFward[max_no_of_SFward_callsigns][SFward_packet_array_columns]={  {"\0BIRDS5\0\0"},{"\0JG6YBA\0\0\0"},{"\0JG6YBC\0\0\0"}  }; 
....................  
.................... #define rcved_data_adrs_pointer 0x05FEF000 // 00 05 FE F0 00 
.................... #define rcved_data_in_FM 0x05FF0000 // 00 05 FF 00 00 
....................  
....................  
.................... #INT_RDA2 //from APRS 
.................... void rxAPRS() 
.................... { 
.................... dataAPRS[byteNumAPRS]=getc(serial2APRS); 
*
0049A:  MOVLW  F8
0049C:  MOVLB  4
0049E:  ADDWF  xF4,W
004A0:  MOVWF  FE9
004A2:  MOVLW  04
004A4:  MOVWF  FEA
004A6:  BTFSC  FD8.0
004A8:  INCF   FEA,F
004AA:  MOVFF  FEA,C9D
004AE:  MOVFF  FE9,C9C
004B2:  MOVLB  0
004B4:  BRA    0456
004B6:  MOVFF  C9D,FEA
004BA:  MOVFF  C9C,FE9
004BE:  MOVFF  01,FEF
.................... //if (byteNumAPRS==dataSizeAPRS-1) { 
.................... if (dataAPRS[byteNumAPRS]==0x0A) 
004C2:  MOVLW  F8
004C4:  MOVLB  4
004C6:  ADDWF  xF4,W
004C8:  MOVWF  FE9
004CA:  MOVLW  04
004CC:  MOVWF  FEA
004CE:  BTFSC  FD8.0
004D0:  INCF   FEA,F
004D2:  MOVF   FEF,W
004D4:  SUBLW  0A
004D6:  BNZ   04F4
.................... { 
.................... if(dataAPRS[byteNumAPRS-1]==0x0D) 
004D8:  MOVLW  01
004DA:  SUBWF  xF4,W
004DC:  ADDLW  F8
004DE:  MOVWF  FE9
004E0:  MOVLW  04
004E2:  MOVWF  FEA
004E4:  BTFSC  FD8.0
004E6:  INCF   FEA,F
004E8:  MOVF   FEF,W
004EA:  SUBLW  0D
004EC:  BNZ   04F4
.................... { 
.................... actionAPRS=1; rec_bytes_number_APRS=byteNumAPRS; 
004EE:  BSF    1E.2
004F0:  MOVFF  4F4,4F6
.................... } 
.................... } 
.................... byteNumAPRS = (byteNumAPRS+1);//% dataSizeAPRS; 
004F4:  MOVLW  01
004F6:  ADDWF  xF4,F
.................... } 
....................  
004F8:  BCF    FA4.5
004FA:  MOVLB  0
004FC:  GOTO   0074
.................... #INT_RDA3 // from Mission Boss 
.................... void rxMB() 
.................... { 
.................... //RCSTA1bits.OERR = 0; 
.................... receivedDataMB=fgetc(serial2MB); 
*
006D6:  RCALL  0500
006D8:  MOVFF  01,4F7
.................... //putc(receivedDataMB,serial2MB); 
....................  
.................... if (receivedDataMB==0xE0) {byteNumMB=0;isCommandData=1; fprintf(debugPort,"\r\n Received an E0 \r\n");} 
006DC:  MOVLB  4
006DE:  MOVF   xF7,W
006E0:  SUBLW  E0
006E2:  BNZ   06FA
006E4:  CLRF   xF5
006E6:  BSF    1E.3
006E8:  MOVLW  AE
006EA:  MOVWF  FF6
006EC:  MOVLW  07
006EE:  MOVWF  FF7
006F0:  MOVLW  00
006F2:  MOVWF  FF8
006F4:  MOVLB  0
006F6:  RCALL  0590
006F8:  MOVLB  4
.................... commandLine[byteNumMB]=receivedDataMB; 
006FA:  CLRF   03
006FC:  MOVF   xF5,W
006FE:  ADDLW  24
00700:  MOVWF  FE9
00702:  MOVLW  06
00704:  ADDWFC 03,W
00706:  MOVWF  FEA
00708:  MOVFF  4F7,FEF
....................  
.................... //if (receivedDataMB==0x0F) {byteNumMB=0;isCommandData=1; fprintf(debugPort,"\r\n Received an 0F \r\n");} 
.................... //commandLine[byteNumMB]=receivedDataMB; 
....................  
.................... fprintf(debugPort,"from MB we received %X, number of command bytes rcvd=%u \r\n",receivedDataMB,byteNumMB); //try to move it to the main function 
0070C:  MOVLW  C4
0070E:  MOVWF  FF6
00710:  MOVLW  07
00712:  MOVWF  FF7
00714:  MOVLW  00
00716:  MOVWF  FF8
00718:  MOVLW  14
0071A:  MOVLB  C
0071C:  MOVWF  x9A
0071E:  MOVLB  0
00720:  RCALL  05B8
00722:  MOVFF  4F7,C9A
00726:  MOVLW  37
00728:  MOVLB  C
0072A:  MOVWF  x9B
0072C:  MOVLB  0
0072E:  RCALL  05E8
00730:  MOVLW  DA
00732:  MOVWF  FF6
00734:  MOVLW  07
00736:  MOVWF  FF7
00738:  MOVLW  00
0073A:  MOVWF  FF8
0073C:  MOVLW  1F
0073E:  MOVLB  C
00740:  MOVWF  x9A
00742:  MOVLB  0
00744:  RCALL  05B8
00746:  MOVFF  4F5,C9A
0074A:  MOVLW  1B
0074C:  MOVLB  C
0074E:  MOVWF  x9B
00750:  MOVLB  0
00752:  RCALL  065A
00754:  MOVLW  FB
00756:  MOVWF  FF6
00758:  MOVLW  07
0075A:  MOVWF  FF7
0075C:  MOVLW  00
0075E:  MOVWF  FF8
00760:  MOVLW  03
00762:  MOVLB  C
00764:  MOVWF  x9A
00766:  MOVLB  0
00768:  RCALL  05B8
....................  
.................... if (byteNumMB==commandSizeMB-1) { 
0076A:  MOVLB  4
0076C:  MOVF   xF5,W
0076E:  SUBLW  06
00770:  BNZ   078A
.................... actionMB=1; 
00772:  BSF    1E.1
.................... byteNumMB=0; 
00774:  CLRF   xF5
.................... isCommandData=0; 
00776:  BCF    1E.3
.................... fprintf(debugPort,"full command is received \r\n\r\n"); 
00778:  MOVLW  00
0077A:  MOVWF  FF6
0077C:  MOVLW  08
0077E:  MOVWF  FF7
00780:  MOVLW  00
00782:  MOVWF  FF8
00784:  MOVLB  0
00786:  RCALL  0590
00788:  MOVLB  4
.................... } 
....................  
.................... if (isCommandData==1) {byteNumMB = ((byteNumMB + 1) % commandSizeMB);} 
0078A:  BTFSS  1E.3
0078C:  BRA    07A6
0078E:  MOVLW  01
00790:  ADDWF  xF5,W
00792:  MOVLB  C
00794:  MOVWF  x9B
00796:  MOVWF  x9C
00798:  MOVLW  07
0079A:  MOVWF  x9D
0079C:  MOVLB  0
0079E:  RCALL  062E
007A0:  MOVFF  00,4F5
007A4:  MOVLB  4
....................  
007A6:  BCF    FA6.5
007A8:  MOVLB  0
007AA:  GOTO   0074
.................... } 
....................  
.................... void write_satellite_info() 
.................... { 
....................    //delay_ms(10000); 
....................    fprintf(debugPort,"Writing_satellite_info\r\n"); 
*
0168C:  MOVLW  1E
0168E:  MOVWF  FF6
01690:  MOVLW  08
01692:  MOVWF  FF7
01694:  MOVLW  00
01696:  MOVWF  FF8
01698:  CLRF   1B
0169A:  BTFSC  FF2.7
0169C:  BSF    1B.7
0169E:  BCF    FF2.7
016A0:  CALL   0590
016A4:  BTFSC  1B.7
016A6:  BSF    FF2.7
....................    SUBSECTOR_4KB_ERASE4(satellite_info_pointer); 
016A8:  MOVLB  C
016AA:  CLRF   x6C
016AC:  CLRF   x6B
016AE:  MOVLW  20
016B0:  MOVWF  x6A
016B2:  CLRF   x69
016B4:  MOVLB  0
016B6:  RCALL  0FF4
....................    WRITE_DATA_N_BYTE4(satellite_info_pointer,sizeof(satellite_name),satellite_name); 
016B8:  MOVLB  C
016BA:  CLRF   x6C
016BC:  CLRF   x6B
016BE:  MOVLW  20
016C0:  MOVWF  x6A
016C2:  CLRF   x69
016C4:  CLRF   x70
016C6:  CLRF   x6F
016C8:  CLRF   x6E
016CA:  MOVLW  07
016CC:  MOVWF  x6D
016CE:  MOVLW  04
016D0:  MOVWF  x72
016D2:  MOVLW  84
016D4:  MOVWF  x71
016D6:  MOVLB  0
016D8:  RCALL  1158
016DA:  RETURN 0
....................  
.................... } 
....................  
.................... void prepare_DummyData(int32 packetsNo) 
.................... { 
.................... //delay_ms(10000); 
.................... SUBSECTOR_4KB_ERASE4(0); 
*
056BA:  MOVLB  C
056BC:  CLRF   x6C
056BE:  CLRF   x6B
056C0:  CLRF   x6A
056C2:  CLRF   x69
056C4:  MOVLB  0
056C6:  CALL   0FF4
.................... WRITE_DATA_N_DUMMY_BYTE4(0,packetsNo*81); 
056CA:  MOVFF  C52,C56
056CE:  MOVFF  C51,C55
056D2:  MOVFF  C50,C54
056D6:  MOVFF  C4F,C53
056DA:  MOVLB  C
056DC:  CLRF   x5A
056DE:  CLRF   x59
056E0:  CLRF   x58
056E2:  MOVLW  51
056E4:  MOVWF  x57
056E6:  MOVLB  0
056E8:  BRA    517E
056EA:  MOVFF  03,C56
056EE:  MOVFF  02,C55
056F2:  MOVFF  01,C54
056F6:  MOVFF  00,C53
056FA:  MOVLB  C
056FC:  CLRF   x5A
056FE:  CLRF   x59
05700:  CLRF   x58
05702:  CLRF   x57
05704:  MOVFF  03,C5E
05708:  MOVFF  02,C5D
0570C:  MOVFF  01,C5C
05710:  MOVFF  00,C5B
05714:  MOVLB  0
05716:  BRA    51DC
.................... fprintf(debugPort,"\r\nFinished writing %lu packets of dummy Bytes in SF_FM\r\n\r\n",(packetsNo)); 
05718:  MOVLW  38
0571A:  MOVWF  FF6
0571C:  MOVLW  08
0571E:  MOVWF  FF7
05720:  MOVLW  00
05722:  MOVWF  FF8
05724:  CLRF   1B
05726:  BTFSC  FF2.7
05728:  BSF    1B.7
0572A:  BCF    FF2.7
0572C:  MOVLW  13
0572E:  MOVLB  C
05730:  MOVWF  x9A
05732:  MOVLB  0
05734:  CALL   05B8
05738:  BTFSC  1B.7
0573A:  BSF    FF2.7
0573C:  MOVLW  41
0573E:  MOVWF  FE9
05740:  MOVFF  C52,C56
05744:  MOVFF  C51,C55
05748:  MOVFF  C50,C54
0574C:  MOVFF  C4F,C53
05750:  BRA    55E8
05752:  MOVLW  4E
05754:  MOVWF  FF6
05756:  MOVLW  08
05758:  MOVWF  FF7
0575A:  MOVLW  00
0575C:  MOVWF  FF8
0575E:  CLRF   1B
05760:  BTFSC  FF2.7
05762:  BSF    1B.7
05764:  BCF    FF2.7
05766:  MOVLW  24
05768:  MOVLB  C
0576A:  MOVWF  x9A
0576C:  MOVLB  0
0576E:  CALL   05B8
05772:  BTFSC  1B.7
05774:  BSF    FF2.7
05776:  GOTO   57B6 (RETURN)
.................... } 
....................  
.................... void show_FM_data(void) 
.................... { 
.................... fprintf(debugPort,"\r\nFM Data from addrss %X%X%X%X:\r\n",first_adsress[0],first_adsress[1],first_adsress[2],first_adsress[3]); 
*
01802:  MOVLW  74
01804:  MOVWF  FF6
01806:  MOVLW  08
01808:  MOVWF  FF7
0180A:  MOVLW  00
0180C:  MOVWF  FF8
0180E:  CLRF   1B
01810:  BTFSC  FF2.7
01812:  BSF    1B.7
01814:  BCF    FF2.7
01816:  MOVLW  16
01818:  MOVLB  C
0181A:  MOVWF  x9A
0181C:  MOVLB  0
0181E:  CALL   05B8
01822:  BTFSC  1B.7
01824:  BSF    FF2.7
01826:  CLRF   1B
01828:  BTFSC  FF2.7
0182A:  BSF    1B.7
0182C:  BCF    FF2.7
0182E:  MOVFF  667,C9A
01832:  MOVLW  37
01834:  MOVLB  C
01836:  MOVWF  x9B
01838:  MOVLB  0
0183A:  CALL   05E8
0183E:  BTFSC  1B.7
01840:  BSF    FF2.7
01842:  CLRF   1B
01844:  BTFSC  FF2.7
01846:  BSF    1B.7
01848:  BCF    FF2.7
0184A:  MOVFF  668,C9A
0184E:  MOVLW  37
01850:  MOVLB  C
01852:  MOVWF  x9B
01854:  MOVLB  0
01856:  CALL   05E8
0185A:  BTFSC  1B.7
0185C:  BSF    FF2.7
0185E:  CLRF   1B
01860:  BTFSC  FF2.7
01862:  BSF    1B.7
01864:  BCF    FF2.7
01866:  MOVFF  669,C9A
0186A:  MOVLW  37
0186C:  MOVLB  C
0186E:  MOVWF  x9B
01870:  MOVLB  0
01872:  CALL   05E8
01876:  BTFSC  1B.7
01878:  BSF    FF2.7
0187A:  CLRF   1B
0187C:  BTFSC  FF2.7
0187E:  BSF    1B.7
01880:  BCF    FF2.7
01882:  MOVFF  66A,C9A
01886:  MOVLW  37
01888:  MOVLB  C
0188A:  MOVWF  x9B
0188C:  MOVLB  0
0188E:  CALL   05E8
01892:  BTFSC  1B.7
01894:  BSF    FF2.7
01896:  MOVLW  92
01898:  MOVWF  FF6
0189A:  MOVLW  08
0189C:  MOVWF  FF7
0189E:  MOVLW  00
018A0:  MOVWF  FF8
018A2:  CLRF   1B
018A4:  BTFSC  FF2.7
018A6:  BSF    1B.7
018A8:  BCF    FF2.7
018AA:  MOVLW  03
018AC:  MOVLB  C
018AE:  MOVWF  x9A
018B0:  MOVLB  0
018B2:  CALL   05B8
018B6:  BTFSC  1B.7
018B8:  BSF    FF2.7
.................... //fprintf(debugPort,"\r\nFM Data:\r\n"); 
.................... SF_Data_Addres=make32(first_adsress[0],first_adsress[1],first_adsress[2],first_adsress[3]); 
018BA:  MOVFF  667,666
018BE:  MOVFF  668,665
018C2:  MOVFF  669,664
018C6:  MOVFF  66A,663
....................  
....................    for (i=SF_Data_start_Adrs;i<SF_Data_start_Adrs+162;++i) 
018CA:  MOVLB  4
018CC:  CLRF   x83
018CE:  MOVLW  01
018D0:  MOVWF  x82
018D2:  MOVLW  10
018D4:  MOVWF  x81
018D6:  CLRF   x80
018D8:  MOVF   x83,F
018DA:  BTFSS  FD8.2
018DC:  BRA    1A2A
018DE:  MOVF   x82,W
018E0:  SUBLW  01
018E2:  BTFSS  FD8.0
018E4:  BRA    1A2A
018E6:  BNZ   18FA
018E8:  MOVF   x81,W
018EA:  SUBLW  10
018EC:  BTFSS  FD8.0
018EE:  BRA    1A2A
018F0:  BNZ   18FA
018F2:  MOVF   x80,W
018F4:  SUBLW  A1
018F6:  BTFSS  FD8.0
018F8:  BRA    1A2A
....................    { 
....................       if ((i-SF_Data_start_Adrs)%25==0) {fprintf(debugPort,"\r\n");} 
018FA:  MOVLW  00
018FC:  SUBWF  x80,W
018FE:  MOVLB  C
01900:  MOVWF  x4F
01902:  MOVLW  10
01904:  MOVLB  4
01906:  SUBWFB x81,W
01908:  MOVLB  C
0190A:  MOVWF  x50
0190C:  MOVLW  01
0190E:  MOVLB  4
01910:  SUBWFB x82,W
01912:  MOVLB  C
01914:  MOVWF  x51
01916:  MOVLW  00
01918:  MOVLB  4
0191A:  SUBWFB x83,W
0191C:  MOVLB  C
0191E:  MOVWF  x52
01920:  BSF    FD8.1
01922:  MOVLW  0C
01924:  MOVWF  FEA
01926:  MOVLW  53
01928:  MOVWF  FE9
0192A:  MOVFF  C52,C62
0192E:  MOVFF  C51,C61
01932:  MOVFF  C50,C60
01936:  MOVFF  C4F,C5F
0193A:  CLRF   x66
0193C:  CLRF   x65
0193E:  CLRF   x64
01940:  MOVLW  19
01942:  MOVWF  x63
01944:  MOVLB  0
01946:  RCALL  176E
01948:  MOVFF  C56,C52
0194C:  MOVFF  C55,C51
01950:  MOVFF  C54,C50
01954:  MOVFF  C53,C4F
01958:  MOVLB  C
0195A:  MOVF   x4F,F
0195C:  BNZ   199A
0195E:  MOVF   x50,F
01960:  BNZ   199A
01962:  MOVF   x51,F
01964:  BNZ   199A
01966:  MOVF   x52,F
01968:  BNZ   199A
0196A:  CLRF   1B
0196C:  BTFSC  FF2.7
0196E:  BSF    1B.7
01970:  BCF    FF2.7
01972:  MOVLW  0D
01974:  MOVWF  x9E
01976:  MOVLB  0
01978:  CALL   054A
0197C:  BTFSC  1B.7
0197E:  BSF    FF2.7
01980:  CLRF   1B
01982:  BTFSC  FF2.7
01984:  BSF    1B.7
01986:  BCF    FF2.7
01988:  MOVLW  0A
0198A:  MOVLB  C
0198C:  MOVWF  x9E
0198E:  MOVLB  0
01990:  CALL   054A
01994:  BTFSC  1B.7
01996:  BSF    FF2.7
01998:  MOVLB  C
....................       fprintf(debugPort,"%X ",READ_DATA_BYTE4(i)); 
0199A:  MOVFF  483,C6D
0199E:  MOVFF  482,C6C
019A2:  MOVFF  481,C6B
019A6:  MOVFF  480,C6A
019AA:  MOVLB  0
019AC:  CALL   0E60
019B0:  MOVFF  01,C4F
019B4:  CLRF   1B
019B6:  BTFSC  FF2.7
019B8:  BSF    1B.7
019BA:  BCF    FF2.7
019BC:  MOVFF  01,C9A
019C0:  MOVLW  37
019C2:  MOVLB  C
019C4:  MOVWF  x9B
019C6:  MOVLB  0
019C8:  CALL   05E8
019CC:  BTFSC  1B.7
019CE:  BSF    FF2.7
019D0:  CLRF   1B
019D2:  BTFSC  FF2.7
019D4:  BSF    1B.7
019D6:  BCF    FF2.7
019D8:  MOVLW  20
019DA:  MOVLB  C
019DC:  MOVWF  x9E
019DE:  MOVLB  0
019E0:  CALL   054A
019E4:  BTFSC  1B.7
019E6:  BSF    FF2.7
....................       fputc(READ_DATA_BYTE4(i),serial2MB); 
019E8:  MOVFF  483,C6D
019EC:  MOVFF  482,C6C
019F0:  MOVFF  481,C6B
019F4:  MOVFF  480,C6A
019F8:  CALL   0E60
019FC:  MOVFF  01,C4F
01A00:  MOVLB  C
01A02:  MOVF   x4F,W
01A04:  MOVLB  0
01A06:  CALL   0F56
....................       delay_ms(delayTX); 
01A0A:  MOVLW  0A
01A0C:  MOVLB  C
01A0E:  MOVWF  x86
01A10:  MOVLB  0
01A12:  CALL   0EE2
01A16:  MOVLW  01
01A18:  MOVLB  4
01A1A:  ADDWF  x80,F
01A1C:  BTFSC  FD8.0
01A1E:  INCF   x81,F
01A20:  BTFSC  FD8.2
01A22:  INCF   x82,F
01A24:  BTFSC  FD8.2
01A26:  INCF   x83,F
01A28:  BRA    18D8
01A2A:  CLRF   1B
01A2C:  BTFSC  FF2.7
01A2E:  BSF    1B.7
01A30:  BCF    FF2.7
....................    } 
.................... fprintf(debugPort,"\r\n"); 
01A32:  MOVLW  0D
01A34:  MOVLB  C
01A36:  MOVWF  x9E
01A38:  MOVLB  0
01A3A:  CALL   054A
01A3E:  BTFSC  1B.7
01A40:  BSF    FF2.7
01A42:  CLRF   1B
01A44:  BTFSC  FF2.7
01A46:  BSF    1B.7
01A48:  BCF    FF2.7
01A4A:  MOVLW  0A
01A4C:  MOVLB  C
01A4E:  MOVWF  x9E
01A50:  MOVLB  0
01A52:  CALL   054A
01A56:  BTFSC  1B.7
01A58:  BSF    FF2.7
01A5A:  RETURN 0
.................... } 
....................  
.................... // Ack to Mission Boss 
.................... void sendACKtoMB(int8 ackByte) 
.................... { 
....................    fputc(ackByte,serial2MB); 
*
00F62:  MOVLB  C
00F64:  MOVF   x4F,W
00F66:  MOVLB  0
00F68:  RCALL  0F56
....................    fprintf(debugPort," This ack is sent: %X \r\n",ackByte); 
00F6A:  MOVLW  96
00F6C:  MOVWF  FF6
00F6E:  MOVLW  08
00F70:  MOVWF  FF7
00F72:  MOVLW  00
00F74:  MOVWF  FF8
00F76:  CLRF   1B
00F78:  BTFSC  FF2.7
00F7A:  BSF    1B.7
00F7C:  BCF    FF2.7
00F7E:  MOVLW  13
00F80:  MOVLB  C
00F82:  MOVWF  x9A
00F84:  MOVLB  0
00F86:  CALL   05B8
00F8A:  BTFSC  1B.7
00F8C:  BSF    FF2.7
00F8E:  CLRF   1B
00F90:  BTFSC  FF2.7
00F92:  BSF    1B.7
00F94:  BCF    FF2.7
00F96:  MOVFF  C4F,C9A
00F9A:  MOVLW  37
00F9C:  MOVLB  C
00F9E:  MOVWF  x9B
00FA0:  MOVLB  0
00FA2:  CALL   05E8
00FA6:  BTFSC  1B.7
00FA8:  BSF    FF2.7
00FAA:  MOVLW  AB
00FAC:  MOVWF  FF6
00FAE:  MOVLW  08
00FB0:  MOVWF  FF7
00FB2:  MOVLW  00
00FB4:  MOVWF  FF8
00FB6:  CLRF   1B
00FB8:  BTFSC  FF2.7
00FBA:  BSF    1B.7
00FBC:  BCF    FF2.7
00FBE:  MOVLW  03
00FC0:  MOVLB  C
00FC2:  MOVWF  x9A
00FC4:  MOVLB  0
00FC6:  CALL   05B8
00FCA:  BTFSC  1B.7
00FCC:  BSF    FF2.7
00FCE:  RETURN 0
.................... } 
....................  
....................  
.................... // E0 command from Mission Boss 
.................... void executeE0Command(int32 sendAddres,long packetsNoInTheCommand) 
.................... { 
.................... //unsigned int8 i; 
.................... //unsigned int32 i; 
.................... unsigned int8 data2MB; 
....................  
.................... fprintf(debugPort,"\r\n\r\n"); 
*
04FBA:  MOVLW  B0
04FBC:  MOVWF  FF6
04FBE:  MOVLW  08
04FC0:  MOVWF  FF7
04FC2:  MOVLW  00
04FC4:  MOVWF  FF8
04FC6:  CLRF   1B
04FC8:  BTFSC  FF2.7
04FCA:  BSF    1B.7
04FCC:  BCF    FF2.7
04FCE:  CALL   0590
04FD2:  BTFSC  1B.7
04FD4:  BSF    FF2.7
....................    for (int32 i=0;i<(packetsNoInTheCommand*packetLength);++i) 
04FD6:  MOVLB  C
04FD8:  CLRF   x59
04FDA:  CLRF   x58
04FDC:  CLRF   x57
04FDE:  CLRF   x56
04FE0:  MOVFF  C54,C6C
04FE4:  MOVFF  C53,C6B
04FE8:  MOVFF  637,C6E
04FEC:  MOVFF  636,C6D
04FF0:  MOVLB  0
04FF2:  CALL   37C4
04FF6:  MOVFF  02,03
04FFA:  MOVF   01,W
04FFC:  MOVLB  C
04FFE:  MOVF   x59,F
05000:  BTFSS  FD8.2
05002:  BRA    5126
05004:  MOVF   x58,F
05006:  BTFSS  FD8.2
05008:  BRA    5126
0500A:  MOVF   x57,W
0500C:  SUBWF  03,W
0500E:  BTFSS  FD8.0
05010:  BRA    5126
05012:  BNZ   501C
05014:  MOVF   01,W
05016:  SUBWF  x56,W
05018:  BTFSC  FD8.0
0501A:  BRA    5126
....................    { 
....................     
....................       if (i%20==0) {fprintf(debugPort,"\r\n");} 
0501C:  BSF    FD8.1
0501E:  MOVLW  0C
05020:  MOVWF  FEA
05022:  MOVLW  5A
05024:  MOVWF  FE9
05026:  MOVFF  C59,C62
0502A:  MOVFF  C58,C61
0502E:  MOVFF  C57,C60
05032:  MOVFF  C56,C5F
05036:  CLRF   x66
05038:  CLRF   x65
0503A:  CLRF   x64
0503C:  MOVLW  14
0503E:  MOVWF  x63
05040:  MOVLB  0
05042:  CALL   176E
05046:  MOVFF  C5D,C61
0504A:  MOVFF  C5C,C60
0504E:  MOVFF  C5B,C5F
05052:  MOVFF  C5A,C5E
05056:  MOVLB  C
05058:  MOVF   x5E,F
0505A:  BNZ   5098
0505C:  MOVF   x5F,F
0505E:  BNZ   5098
05060:  MOVF   x60,F
05062:  BNZ   5098
05064:  MOVF   x61,F
05066:  BNZ   5098
05068:  CLRF   1B
0506A:  BTFSC  FF2.7
0506C:  BSF    1B.7
0506E:  BCF    FF2.7
05070:  MOVLW  0D
05072:  MOVWF  x9E
05074:  MOVLB  0
05076:  CALL   054A
0507A:  BTFSC  1B.7
0507C:  BSF    FF2.7
0507E:  CLRF   1B
05080:  BTFSC  FF2.7
05082:  BSF    1B.7
05084:  BCF    FF2.7
05086:  MOVLW  0A
05088:  MOVLB  C
0508A:  MOVWF  x9E
0508C:  MOVLB  0
0508E:  CALL   054A
05092:  BTFSC  1B.7
05094:  BSF    FF2.7
05096:  MOVLB  C
....................       data2MB=READ_DATA_BYTE4(sendAddres+i); 
05098:  MOVF   x56,W
0509A:  ADDWF  x4F,W
0509C:  MOVWF  x5A
0509E:  MOVF   x57,W
050A0:  ADDWFC x50,W
050A2:  MOVWF  x5B
050A4:  MOVF   x58,W
050A6:  ADDWFC x51,W
050A8:  MOVWF  x5C
050AA:  MOVF   x59,W
050AC:  ADDWFC x52,W
050AE:  MOVWF  x5D
050B0:  MOVWF  x6D
050B2:  MOVFF  C5C,C6C
050B6:  MOVFF  C5B,C6B
050BA:  MOVFF  C5A,C6A
050BE:  MOVLB  0
050C0:  CALL   0E60
050C4:  MOVFF  01,C55
....................       fputc(data2MB,serial2MB); 
050C8:  MOVLB  C
050CA:  MOVF   x55,W
050CC:  MOVLB  0
050CE:  CALL   0F56
050D2:  CLRF   1B
050D4:  BTFSC  FF2.7
050D6:  BSF    1B.7
050D8:  BCF    FF2.7
....................       //fputc(data2MB,debugPort); 
....................       fprintf(debugPort,"%X ",data2MB); 
050DA:  MOVFF  C55,C9A
050DE:  MOVLW  37
050E0:  MOVLB  C
050E2:  MOVWF  x9B
050E4:  MOVLB  0
050E6:  CALL   05E8
050EA:  BTFSC  1B.7
050EC:  BSF    FF2.7
050EE:  CLRF   1B
050F0:  BTFSC  FF2.7
050F2:  BSF    1B.7
050F4:  BCF    FF2.7
050F6:  MOVLW  20
050F8:  MOVLB  C
050FA:  MOVWF  x9E
050FC:  MOVLB  0
050FE:  CALL   054A
05102:  BTFSC  1B.7
05104:  BSF    FF2.7
....................       delay_ms(delayTX);  
05106:  MOVLW  0A
05108:  MOVLB  C
0510A:  MOVWF  x86
0510C:  MOVLB  0
0510E:  CALL   0EE2
05112:  MOVLW  01
05114:  MOVLB  C
05116:  ADDWF  x56,F
05118:  BTFSC  FD8.0
0511A:  INCF   x57,F
0511C:  BTFSC  FD8.2
0511E:  INCF   x58,F
05120:  BTFSC  FD8.2
05122:  INCF   x59,F
05124:  BRA    4FE0
....................    } 
.................... //fprintf(debugPort,"\r\nFinished sending %u packets, %u Bytes\r\n\r\n",packetsNoInTheCommand,(packetsNoInTheCommand*81)); 
.................... //fprintf(debugPort,"\r\n %X\r\n", m); 
.................... fprintf(debugPort,"\r\nFinished sending %lu packets\r\n\r\n",packetsNoInTheCommand); 
05126:  MOVLW  B6
05128:  MOVWF  FF6
0512A:  MOVLW  08
0512C:  MOVWF  FF7
0512E:  MOVLW  00
05130:  MOVWF  FF8
05132:  CLRF   1B
05134:  BTFSC  FF2.7
05136:  BSF    1B.7
05138:  BCF    FF2.7
0513A:  MOVLW  13
0513C:  MOVWF  x9A
0513E:  MOVLB  0
05140:  CALL   05B8
05144:  BTFSC  1B.7
05146:  BSF    FF2.7
05148:  MOVLW  10
0514A:  MOVWF  FE9
0514C:  MOVFF  C54,C5B
05150:  MOVFF  C53,C5A
05154:  BRA    4EE4
05156:  MOVLW  CC
05158:  MOVWF  FF6
0515A:  MOVLW  08
0515C:  MOVWF  FF7
0515E:  MOVLW  00
05160:  MOVWF  FF8
05162:  CLRF   1B
05164:  BTFSC  FF2.7
05166:  BSF    1B.7
05168:  BCF    FF2.7
0516A:  MOVLW  0C
0516C:  MOVLB  C
0516E:  MOVWF  x9A
05170:  MOVLB  0
05172:  CALL   05B8
05176:  BTFSC  1B.7
05178:  BSF    FF2.7
0517A:  GOTO   6E04 (RETURN)
....................  
.................... } 
....................  
.................... void show_SFward_info_array(void) 
*
039AC:  MOVLB  C
039AE:  CLRF   x59
039B0:  CLRF   x5A
.................... { 
....................    int8 rawLoop=0; 
....................    int8 columnLoop=0; 
....................  
....................     
....................    fprintf(debugPort,"SFward packet array in RAM\r\n"); 
039B2:  MOVLW  DA
039B4:  MOVWF  FF6
039B6:  MOVLW  08
039B8:  MOVWF  FF7
039BA:  MOVLW  00
039BC:  MOVWF  FF8
039BE:  CLRF   1B
039C0:  BTFSC  FF2.7
039C2:  BSF    1B.7
039C4:  BCF    FF2.7
039C6:  MOVLB  0
039C8:  CALL   0590
039CC:  BTFSC  1B.7
039CE:  BSF    FF2.7
....................    fprintf(debugPort,"no_of_SFward_callsigns=%u\r\n",no_of_SFward_callsigns); 
039D0:  MOVLW  F8
039D2:  MOVWF  FF6
039D4:  MOVLW  08
039D6:  MOVWF  FF7
039D8:  MOVLW  00
039DA:  MOVWF  FF8
039DC:  CLRF   1B
039DE:  BTFSC  FF2.7
039E0:  BSF    1B.7
039E2:  BCF    FF2.7
039E4:  MOVLW  17
039E6:  MOVLB  C
039E8:  MOVWF  x9A
039EA:  MOVLB  0
039EC:  CALL   05B8
039F0:  BTFSC  1B.7
039F2:  BSF    FF2.7
039F4:  CLRF   1B
039F6:  BTFSC  FF2.7
039F8:  BSF    1B.7
039FA:  BCF    FF2.7
039FC:  MOVFF  66F,C9A
03A00:  MOVLW  1B
03A02:  MOVLB  C
03A04:  MOVWF  x9B
03A06:  MOVLB  0
03A08:  CALL   065A
03A0C:  BTFSC  1B.7
03A0E:  BSF    FF2.7
03A10:  CLRF   1B
03A12:  BTFSC  FF2.7
03A14:  BSF    1B.7
03A16:  BCF    FF2.7
03A18:  MOVLW  0D
03A1A:  MOVLB  C
03A1C:  MOVWF  x9E
03A1E:  MOVLB  0
03A20:  CALL   054A
03A24:  BTFSC  1B.7
03A26:  BSF    FF2.7
03A28:  CLRF   1B
03A2A:  BTFSC  FF2.7
03A2C:  BSF    1B.7
03A2E:  BCF    FF2.7
03A30:  MOVLW  0A
03A32:  MOVLB  C
03A34:  MOVWF  x9E
03A36:  MOVLB  0
03A38:  CALL   054A
03A3C:  BTFSC  1B.7
03A3E:  BSF    FF2.7
....................    for (rawLoop=0;rawLoop<no_of_SFward_callsigns;rawLoop++) 
03A40:  MOVLB  C
03A42:  CLRF   x59
03A44:  MOVLB  6
03A46:  MOVF   x6F,W
03A48:  MOVLB  C
03A4A:  SUBWF  x59,W
03A4C:  BC    3AF4
....................       { 
....................          for (columnLoop=0;columnLoop<SFward_packet_array_columns;columnLoop++) 
03A4E:  CLRF   x5A
03A50:  MOVF   x5A,W
03A52:  SUBLW  09
03A54:  BNC   3AC0
....................             {fprintf(debugPort,"%X ",log_array_SFward[rawLoop][columnLoop]);} 
03A56:  CLRF   x6C
03A58:  MOVFF  C59,C6B
03A5C:  CLRF   x6E
03A5E:  MOVLW  0A
03A60:  MOVWF  x6D
03A62:  MOVLB  0
03A64:  RCALL  37C4
03A66:  MOVFF  02,C5C
03A6A:  MOVFF  01,C5B
03A6E:  MOVLB  C
03A70:  MOVF   x5A,W
03A72:  ADDWF  01,W
03A74:  MOVWF  01
03A76:  MOVLW  00
03A78:  ADDWFC 02,W
03A7A:  MOVWF  03
03A7C:  MOVF   01,W
03A7E:  ADDLW  70
03A80:  MOVWF  FE9
03A82:  MOVLW  06
03A84:  ADDWFC 03,W
03A86:  MOVWF  FEA
03A88:  MOVFF  FEF,C9A
03A8C:  CLRF   1B
03A8E:  BTFSC  FF2.7
03A90:  BSF    1B.7
03A92:  BCF    FF2.7
03A94:  MOVLW  37
03A96:  MOVWF  x9B
03A98:  MOVLB  0
03A9A:  CALL   05E8
03A9E:  BTFSC  1B.7
03AA0:  BSF    FF2.7
03AA2:  CLRF   1B
03AA4:  BTFSC  FF2.7
03AA6:  BSF    1B.7
03AA8:  BCF    FF2.7
03AAA:  MOVLW  20
03AAC:  MOVLB  C
03AAE:  MOVWF  x9E
03AB0:  MOVLB  0
03AB2:  CALL   054A
03AB6:  BTFSC  1B.7
03AB8:  BSF    FF2.7
03ABA:  MOVLB  C
03ABC:  INCF   x5A,F
03ABE:  BRA    3A50
03AC0:  CLRF   1B
03AC2:  BTFSC  FF2.7
03AC4:  BSF    1B.7
03AC6:  BCF    FF2.7
....................          fprintf(debugPort,"\r\n"); 
03AC8:  MOVLW  0D
03ACA:  MOVWF  x9E
03ACC:  MOVLB  0
03ACE:  CALL   054A
03AD2:  BTFSC  1B.7
03AD4:  BSF    FF2.7
03AD6:  CLRF   1B
03AD8:  BTFSC  FF2.7
03ADA:  BSF    1B.7
03ADC:  BCF    FF2.7
03ADE:  MOVLW  0A
03AE0:  MOVLB  C
03AE2:  MOVWF  x9E
03AE4:  MOVLB  0
03AE6:  CALL   054A
03AEA:  BTFSC  1B.7
03AEC:  BSF    FF2.7
03AEE:  MOVLB  C
03AF0:  INCF   x59,F
03AF2:  BRA    3A44
03AF4:  CLRF   1B
03AF6:  BTFSC  FF2.7
03AF8:  BSF    1B.7
03AFA:  BCF    FF2.7
....................       } 
....................       fprintf(debugPort,"\r\n"); 
03AFC:  MOVLW  0D
03AFE:  MOVWF  x9E
03B00:  MOVLB  0
03B02:  CALL   054A
03B06:  BTFSC  1B.7
03B08:  BSF    FF2.7
03B0A:  CLRF   1B
03B0C:  BTFSC  FF2.7
03B0E:  BSF    1B.7
03B10:  BCF    FF2.7
03B12:  MOVLW  0A
03B14:  MOVLB  C
03B16:  MOVWF  x9E
03B18:  MOVLB  0
03B1A:  CALL   054A
03B1E:  BTFSC  1B.7
03B20:  BSF    FF2.7
03B22:  GOTO   3F16 (RETURN)
....................     
.................... //!   int16 no_of_SFward_callsigns_FM=make16(READ_DATA_BYTE4(pointer_no_of_SFward_callsigns),READ_DATA_BYTE4(pointer_no_of_SFward_callsigns+1));    
.................... //!   int32 arrayElementAddrs=pointer_no_of_SFward_callsigns+2; 
....................  
.................... //!   fprintf(debugPort,"\r\nSFward packet array in Flash Mem.\r\n"); 
.................... //!   fprintf(debugPort,"no_of_SFward_callsigns=%lu\r\n",no_of_SFward_callsigns_FM); 
.................... //!   for (rawLoop=0;rawLoop<no_of_SFward_callsigns_FM;rawLoop++) 
.................... //!      { 
.................... //!         for (columnLoop=0;columnLoop<SFward_packet_array_columns;columnLoop++) 
.................... //!            {fprintf(debugPort,"%X ",READ_DATA_BYTE4(arrayElementAddrs++));} 
.................... //!         fprintf(debugPort,"\r\n"); 
.................... //!      } 
.................... } 
....................  
.................... void write_log_entery_FM(int8 raw_index) 
*
037E6:  MOVLB  C
037E8:  CLRF   x5A
037EA:  CLRF   x6D
037EC:  CLRF   x6C
037EE:  MOVLW  70
037F0:  MOVWF  x6B
037F2:  MOVLW  02
037F4:  MOVWF  x6A
037F6:  MOVLB  0
037F8:  CALL   0E60
037FC:  MOVFF  01,C69
03800:  MOVLB  C
03802:  CLRF   x6D
03804:  CLRF   x6C
03806:  MOVLW  70
03808:  MOVWF  x6B
0380A:  MOVLW  03
0380C:  MOVWF  x6A
0380E:  MOVLB  0
03810:  CALL   0E60
03814:  MOVFF  C69,C66
03818:  MOVFF  01,C65
0381C:  MOVLB  C
0381E:  CLRF   x67
03820:  CLRF   x68
.................... { 
....................    //int8 rawLoop=0; 
....................    int8 columnLoop=0; 
....................    int8 temp_one_raw_array[SFward_packet_array_columns]; 
....................    int32 arrayElementAddrs=make16(READ_DATA_BYTE4(log_array_SFward_adrs_pointer+2),READ_DATA_BYTE4(log_array_SFward_adrs_pointer+3)); 
....................     
....................    if (arrayElementAddrs >= (log_array_SFward_in_FM+0xFFD-SFward_packet_array_columns) ) 
03822:  MOVF   x68,F
03824:  BNZ   383A
03826:  MOVF   x67,F
03828:  BNZ   383A
0382A:  MOVF   x66,W
0382C:  SUBLW  6E
0382E:  BC    38C2
03830:  XORLW  FF
03832:  BNZ   383A
03834:  MOVF   x65,W
03836:  SUBLW  F2
03838:  BC    38C2
....................    { 
....................       SUBSECTOR_4KB_ERASE4(log_array_SFward_adrs_pointer); 
0383A:  CLRF   x6C
0383C:  CLRF   x6B
0383E:  MOVLW  70
03840:  MOVWF  x6A
03842:  CLRF   x69
03844:  MOVLB  0
03846:  CALL   0FF4
....................       SUBSECTOR_4KB_ERASE4(log_array_SFward_in_FM); 
0384A:  MOVLB  C
0384C:  CLRF   x6C
0384E:  CLRF   x6B
03850:  MOVLW  60
03852:  MOVWF  x6A
03854:  CLRF   x69
03856:  MOVLB  0
03858:  CALL   0FF4
....................       fprintf(debugPort,"Writing log_array_SFward_adrs_pointer to FM\r\n"); 
0385C:  MOVLW  14
0385E:  MOVWF  FF6
03860:  MOVLW  09
03862:  MOVWF  FF7
03864:  MOVLW  00
03866:  MOVWF  FF8
03868:  CLRF   1B
0386A:  BTFSC  FF2.7
0386C:  BSF    1B.7
0386E:  BCF    FF2.7
03870:  CALL   0590
03874:  BTFSC  1B.7
03876:  BSF    FF2.7
....................       arrayElementAddrs=log_array_SFward_in_FM; 
03878:  MOVLB  C
0387A:  CLRF   x68
0387C:  CLRF   x67
0387E:  MOVLW  60
03880:  MOVWF  x66
03882:  CLRF   x65
....................       WRITE_DATA_BYTE4(log_array_SFward_adrs_pointer+2,arrayElementAddrs>>8); 
03884:  MOVFF  C66,C6A
03888:  MOVFF  C67,C6B
0388C:  MOVFF  C68,C6C
03890:  CLRF   x6D
03892:  CLRF   x71
03894:  CLRF   x70
03896:  MOVLW  70
03898:  MOVWF  x6F
0389A:  MOVLW  02
0389C:  MOVWF  x6E
0389E:  MOVFF  C66,C72
038A2:  MOVLB  0
038A4:  CALL   16DC
....................       WRITE_DATA_BYTE4(log_array_SFward_adrs_pointer+3,arrayElementAddrs); 
038A8:  MOVLB  C
038AA:  CLRF   x71
038AC:  CLRF   x70
038AE:  MOVLW  70
038B0:  MOVWF  x6F
038B2:  MOVLW  03
038B4:  MOVWF  x6E
038B6:  MOVFF  C65,C72
038BA:  MOVLB  0
038BC:  CALL   16DC
038C0:  MOVLB  C
....................    } 
....................  
....................     for (columnLoop=0;columnLoop<SFward_packet_array_columns;columnLoop++) 
038C2:  CLRF   x5A
038C4:  MOVF   x5A,W
038C6:  SUBLW  09
038C8:  BNC   3920
....................     { 
....................          temp_one_raw_array[columnLoop]=log_array_SFward[raw_index][columnLoop]; 
038CA:  CLRF   03
038CC:  MOVF   x5A,W
038CE:  ADDLW  5B
038D0:  MOVWF  01
038D2:  MOVLW  0C
038D4:  ADDWFC 03,F
038D6:  MOVFF  01,C69
038DA:  MOVFF  03,C6A
038DE:  CLRF   x6C
038E0:  MOVFF  C59,C6B
038E4:  CLRF   x6E
038E6:  MOVLW  0A
038E8:  MOVWF  x6D
038EA:  MOVLB  0
038EC:  RCALL  37C4
038EE:  MOVFF  01,C6B
038F2:  MOVLB  C
038F4:  MOVF   x5A,W
038F6:  ADDWF  01,W
038F8:  MOVWF  01
038FA:  MOVLW  00
038FC:  ADDWFC 02,W
038FE:  MOVWF  03
03900:  MOVF   01,W
03902:  ADDLW  70
03904:  MOVWF  FE9
03906:  MOVLW  06
03908:  ADDWFC 03,W
0390A:  MOVWF  FEA
0390C:  MOVFF  FEF,C6B
03910:  MOVFF  C6A,FEA
03914:  MOVFF  C69,FE9
03918:  MOVFF  C6B,FEF
0391C:  INCF   x5A,F
0391E:  BRA    38C4
....................     } 
....................     arrayElementAddrs=WRITE_DATA_N_BYTE4(arrayElementAddrs,SFward_packet_array_columns,temp_one_raw_array); 
03920:  MOVFF  C68,C6C
03924:  MOVFF  C67,C6B
03928:  MOVFF  C66,C6A
0392C:  MOVFF  C65,C69
03930:  CLRF   x70
03932:  CLRF   x6F
03934:  CLRF   x6E
03936:  MOVLW  0A
03938:  MOVWF  x6D
0393A:  MOVLW  0C
0393C:  MOVWF  x72
0393E:  MOVLW  5B
03940:  MOVWF  x71
03942:  MOVLB  0
03944:  CALL   1158
03948:  MOVFF  03,C68
0394C:  MOVFF  02,C67
03950:  MOVFF  01,C66
03954:  MOVFF  00,C65
....................      
....................     SUBSECTOR_4KB_ERASE4(log_array_SFward_adrs_pointer); 
03958:  MOVLB  C
0395A:  CLRF   x6C
0395C:  CLRF   x6B
0395E:  MOVLW  70
03960:  MOVWF  x6A
03962:  CLRF   x69
03964:  MOVLB  0
03966:  CALL   0FF4
....................     WRITE_DATA_BYTE4(log_array_SFward_adrs_pointer+2,arrayElementAddrs>>8); 
0396A:  MOVFF  C66,C6A
0396E:  MOVFF  C67,C6B
03972:  MOVFF  C68,C6C
03976:  MOVLB  C
03978:  CLRF   x6D
0397A:  CLRF   x71
0397C:  CLRF   x70
0397E:  MOVLW  70
03980:  MOVWF  x6F
03982:  MOVLW  02
03984:  MOVWF  x6E
03986:  MOVFF  C66,C72
0398A:  MOVLB  0
0398C:  CALL   16DC
....................     WRITE_DATA_BYTE4(log_array_SFward_adrs_pointer+3,arrayElementAddrs); 
03990:  MOVLB  C
03992:  CLRF   x71
03994:  CLRF   x70
03996:  MOVLW  70
03998:  MOVWF  x6F
0399A:  MOVLW  03
0399C:  MOVWF  x6E
0399E:  MOVFF  C65,C72
039A2:  MOVLB  0
039A4:  CALL   16DC
039A8:  GOTO   3F14 (RETURN)
.................... } 
....................  
.................... void update_SFward_info_array_RAM (void) 
*
03B26:  MOVLB  C
03B28:  CLRF   x55
03B2A:  CLRF   x56
03B2C:  BSF    x57.0
03B2E:  CLRF   x58
.................... { 
....................       //fprintf(debugPort,"\r\nUpdating SFward packet array in the RAM\r\n"); 
....................       int8 rawLoop=0; 
....................       int8 columnLoop=0; 
....................       int1 new_entery=1; 
....................       int8 raw_index=0; 
....................        
....................       for (rawLoop=0;rawLoop<=no_of_SFward_callsigns;rawLoop++) //should be < not <= , right?        //to be removed to allow duplication  
03B30:  CLRF   x55
03B32:  MOVF   x55,W
03B34:  MOVLB  6
03B36:  SUBWF  x6F,W
03B38:  BTFSS  FD8.0
03B3A:  BRA    3D32
....................       { 
....................          if (log_array_SFward[rawLoop][9]==Packet_no_APRS){ 
03B3C:  MOVLB  C
03B3E:  CLRF   x6C
03B40:  MOVFF  C55,C6B
03B44:  CLRF   x6E
03B46:  MOVLW  0A
03B48:  MOVWF  x6D
03B4A:  MOVLB  0
03B4C:  RCALL  37C4
03B4E:  MOVFF  02,C5A
03B52:  MOVFF  01,C59
03B56:  MOVLW  09
03B58:  MOVLB  C
03B5A:  ADDWF  01,W
03B5C:  MOVWF  01
03B5E:  MOVLW  00
03B60:  ADDWFC 02,W
03B62:  MOVWF  03
03B64:  MOVF   01,W
03B66:  ADDLW  70
03B68:  MOVWF  FE9
03B6A:  MOVLW  06
03B6C:  ADDWFC 03,W
03B6E:  MOVWF  FEA
03B70:  MOVLB  4
03B72:  MOVF   xAE,W
03B74:  SUBWF  FEF,W
03B76:  BTFSS  FD8.2
03B78:  BRA    3D2A
....................             if (log_array_SFward[rawLoop][8]==info_size_SFward) 
03B7A:  MOVLB  C
03B7C:  CLRF   x6C
03B7E:  MOVFF  C55,C6B
03B82:  CLRF   x6E
03B84:  MOVLW  0A
03B86:  MOVWF  x6D
03B88:  MOVLB  0
03B8A:  RCALL  37C4
03B8C:  MOVFF  02,C5A
03B90:  MOVFF  01,C59
03B94:  MOVLW  08
03B96:  MOVLB  C
03B98:  ADDWF  01,W
03B9A:  MOVWF  01
03B9C:  MOVLW  00
03B9E:  ADDWFC 02,W
03BA0:  MOVWF  03
03BA2:  MOVF   01,W
03BA4:  ADDLW  70
03BA6:  MOVWF  FE9
03BA8:  MOVLW  06
03BAA:  ADDWFC 03,W
03BAC:  MOVWF  FEA
03BAE:  MOVLB  4
03BB0:  MOVF   xAD,W
03BB2:  SUBWF  FEF,W
03BB4:  BTFSS  FD8.2
03BB6:  BRA    3D2A
....................                if (log_array_SFward[rawLoop][6]==senderCallsign[5]) 
03BB8:  MOVLB  C
03BBA:  CLRF   x6C
03BBC:  MOVFF  C55,C6B
03BC0:  CLRF   x6E
03BC2:  MOVLW  0A
03BC4:  MOVWF  x6D
03BC6:  MOVLB  0
03BC8:  RCALL  37C4
03BCA:  MOVFF  02,C5A
03BCE:  MOVFF  01,C59
03BD2:  MOVLW  06
03BD4:  MOVLB  C
03BD6:  ADDWF  01,W
03BD8:  MOVWF  01
03BDA:  MOVLW  00
03BDC:  ADDWFC 02,W
03BDE:  MOVWF  03
03BE0:  MOVF   01,W
03BE2:  ADDLW  70
03BE4:  MOVWF  FE9
03BE6:  MOVLW  06
03BE8:  ADDWFC 03,W
03BEA:  MOVWF  FEA
03BEC:  MOVLB  4
03BEE:  MOVF   xAA,W
03BF0:  SUBWF  FEF,W
03BF2:  BTFSS  FD8.2
03BF4:  BRA    3D2A
....................                   if (log_array_SFward[rawLoop][5]==senderCallsign[4]) 
03BF6:  MOVLB  C
03BF8:  CLRF   x6C
03BFA:  MOVFF  C55,C6B
03BFE:  CLRF   x6E
03C00:  MOVLW  0A
03C02:  MOVWF  x6D
03C04:  MOVLB  0
03C06:  RCALL  37C4
03C08:  MOVFF  02,C5A
03C0C:  MOVFF  01,C59
03C10:  MOVLW  05
03C12:  MOVLB  C
03C14:  ADDWF  01,W
03C16:  MOVWF  01
03C18:  MOVLW  00
03C1A:  ADDWFC 02,W
03C1C:  MOVWF  03
03C1E:  MOVF   01,W
03C20:  ADDLW  70
03C22:  MOVWF  FE9
03C24:  MOVLW  06
03C26:  ADDWFC 03,W
03C28:  MOVWF  FEA
03C2A:  MOVLB  4
03C2C:  MOVF   xA9,W
03C2E:  SUBWF  FEF,W
03C30:  BTFSS  FD8.2
03C32:  BRA    3D2A
....................                      if (log_array_SFward[rawLoop][4]==senderCallsign[3]) 
03C34:  MOVLB  C
03C36:  CLRF   x6C
03C38:  MOVFF  C55,C6B
03C3C:  CLRF   x6E
03C3E:  MOVLW  0A
03C40:  MOVWF  x6D
03C42:  MOVLB  0
03C44:  RCALL  37C4
03C46:  MOVFF  02,C5A
03C4A:  MOVFF  01,C59
03C4E:  MOVLW  04
03C50:  MOVLB  C
03C52:  ADDWF  01,W
03C54:  MOVWF  01
03C56:  MOVLW  00
03C58:  ADDWFC 02,W
03C5A:  MOVWF  03
03C5C:  MOVF   01,W
03C5E:  ADDLW  70
03C60:  MOVWF  FE9
03C62:  MOVLW  06
03C64:  ADDWFC 03,W
03C66:  MOVWF  FEA
03C68:  MOVLB  4
03C6A:  MOVF   xA8,W
03C6C:  SUBWF  FEF,W
03C6E:  BNZ   3D2A
....................                         if (log_array_SFward[rawLoop][3]==senderCallsign[2]) 
03C70:  MOVLB  C
03C72:  CLRF   x6C
03C74:  MOVFF  C55,C6B
03C78:  CLRF   x6E
03C7A:  MOVLW  0A
03C7C:  MOVWF  x6D
03C7E:  MOVLB  0
03C80:  RCALL  37C4
03C82:  MOVFF  02,C5A
03C86:  MOVFF  01,C59
03C8A:  MOVLW  03
03C8C:  MOVLB  C
03C8E:  ADDWF  01,W
03C90:  MOVWF  01
03C92:  MOVLW  00
03C94:  ADDWFC 02,W
03C96:  MOVWF  03
03C98:  MOVF   01,W
03C9A:  ADDLW  70
03C9C:  MOVWF  FE9
03C9E:  MOVLW  06
03CA0:  ADDWFC 03,W
03CA2:  MOVWF  FEA
03CA4:  MOVLB  4
03CA6:  MOVF   xA7,W
03CA8:  SUBWF  FEF,W
03CAA:  BNZ   3D2A
....................                            if (log_array_SFward[rawLoop][2]==senderCallsign[1]) 
03CAC:  MOVLB  C
03CAE:  CLRF   x6C
03CB0:  MOVFF  C55,C6B
03CB4:  CLRF   x6E
03CB6:  MOVLW  0A
03CB8:  MOVWF  x6D
03CBA:  MOVLB  0
03CBC:  RCALL  37C4
03CBE:  MOVFF  02,C5A
03CC2:  MOVFF  01,C59
03CC6:  MOVLW  02
03CC8:  MOVLB  C
03CCA:  ADDWF  01,W
03CCC:  MOVWF  01
03CCE:  MOVLW  00
03CD0:  ADDWFC 02,W
03CD2:  MOVWF  03
03CD4:  MOVF   01,W
03CD6:  ADDLW  70
03CD8:  MOVWF  FE9
03CDA:  MOVLW  06
03CDC:  ADDWFC 03,W
03CDE:  MOVWF  FEA
03CE0:  MOVLB  4
03CE2:  MOVF   xA6,W
03CE4:  SUBWF  FEF,W
03CE6:  BNZ   3D2A
....................                               if (log_array_SFward[rawLoop][1]==senderCallsign[0]) 
03CE8:  MOVLB  C
03CEA:  CLRF   x6C
03CEC:  MOVFF  C55,C6B
03CF0:  CLRF   x6E
03CF2:  MOVLW  0A
03CF4:  MOVWF  x6D
03CF6:  MOVLB  0
03CF8:  RCALL  37C4
03CFA:  MOVFF  02,C5A
03CFE:  MOVFF  01,C59
03D02:  MOVLW  01
03D04:  MOVLB  C
03D06:  ADDWF  01,W
03D08:  MOVWF  01
03D0A:  MOVLW  00
03D0C:  ADDWFC 02,W
03D0E:  MOVWF  03
03D10:  MOVF   01,W
03D12:  ADDLW  70
03D14:  MOVWF  FE9
03D16:  MOVLW  06
03D18:  ADDWFC 03,W
03D1A:  MOVWF  FEA
03D1C:  MOVLB  4
03D1E:  MOVF   xA5,W
03D20:  SUBWF  FEF,W
03D22:  BNZ   3D2A
....................                                  //{new_entery=0;}                                                 //change made here 
....................                                  {new_entery=1;} 
03D24:  MOVLB  C
03D26:  BSF    x57.0
03D28:  MOVLB  4
....................          } 
03D2A:  MOVLB  C
03D2C:  INCF   x55,F
03D2E:  BRA    3B32
03D30:  MOVLB  6
....................       } 
....................  
....................       if (new_entery==0) 
03D32:  MOVLB  C
03D34:  BTFSC  x57.0
03D36:  BRA    3DC0
....................       { 
....................           
....................          fprintf(debugPort,"\r\nDuplicated,,, \r\n");  
03D38:  MOVLW  42
03D3A:  MOVWF  FF6
03D3C:  MOVLW  09
03D3E:  MOVWF  FF7
03D40:  MOVLW  00
03D42:  MOVWF  FF8
03D44:  CLRF   1B
03D46:  BTFSC  FF2.7
03D48:  BSF    1B.7
03D4A:  BCF    FF2.7
03D4C:  MOVLB  0
03D4E:  CALL   0590
03D52:  BTFSC  1B.7
03D54:  BSF    FF2.7
....................          fprintf(debugPort,"no_of_SFward_log_enteries: %u\r\n\r\n",no_of_SFward_callsigns); 
03D56:  MOVLW  56
03D58:  MOVWF  FF6
03D5A:  MOVLW  09
03D5C:  MOVWF  FF7
03D5E:  MOVLW  00
03D60:  MOVWF  FF8
03D62:  CLRF   1B
03D64:  BTFSC  FF2.7
03D66:  BSF    1B.7
03D68:  BCF    FF2.7
03D6A:  MOVLW  1B
03D6C:  MOVLB  C
03D6E:  MOVWF  x9A
03D70:  MOVLB  0
03D72:  CALL   05B8
03D76:  BTFSC  1B.7
03D78:  BSF    FF2.7
03D7A:  CLRF   1B
03D7C:  BTFSC  FF2.7
03D7E:  BSF    1B.7
03D80:  BCF    FF2.7
03D82:  MOVFF  66F,C9A
03D86:  MOVLW  1B
03D88:  MOVLB  C
03D8A:  MOVWF  x9B
03D8C:  MOVLB  0
03D8E:  CALL   065A
03D92:  BTFSC  1B.7
03D94:  BSF    FF2.7
03D96:  MOVLW  73
03D98:  MOVWF  FF6
03D9A:  MOVLW  09
03D9C:  MOVWF  FF7
03D9E:  MOVLW  00
03DA0:  MOVWF  FF8
03DA2:  CLRF   1B
03DA4:  BTFSC  FF2.7
03DA6:  BSF    1B.7
03DA8:  BCF    FF2.7
03DAA:  MOVLW  04
03DAC:  MOVLB  C
03DAE:  MOVWF  x9A
03DB0:  MOVLB  0
03DB2:  CALL   05B8
03DB6:  BTFSC  1B.7
03DB8:  BSF    FF2.7
....................          isDuplicatedData=1; 
03DBA:  BSF    1E.4
....................        } 
03DBC:  BRA    3F16
03DBE:  MOVLB  C
....................        
....................       else //if (new_entery==1) 
....................       { 
....................          fprintf(debugPort,"\r\nAdding NEW entery in SFward packet array in the RAM\r\n"); 
03DC0:  MOVLW  78
03DC2:  MOVWF  FF6
03DC4:  MOVLW  09
03DC6:  MOVWF  FF7
03DC8:  MOVLW  00
03DCA:  MOVWF  FF8
03DCC:  CLRF   1B
03DCE:  BTFSC  FF2.7
03DD0:  BSF    1B.7
03DD2:  BCF    FF2.7
03DD4:  MOVLB  0
03DD6:  CALL   0590
03DDA:  BTFSC  1B.7
03DDC:  BSF    FF2.7
....................          if (no_of_SFward_callsigns>=max_no_of_SFward_callsigns) {no_of_SFward_callsigns=0;} 
03DDE:  MOVLB  6
03DE0:  MOVF   x6F,W
03DE2:  SUBLW  63
03DE4:  BC    3DE8
03DE6:  CLRF   x6F
....................          no_of_SFward_callsigns++; 
03DE8:  INCF   x6F,F
....................          raw_index=no_of_SFward_callsigns-1; 
03DEA:  MOVLW  01
03DEC:  SUBWF  x6F,W
03DEE:  MOVLB  C
03DF0:  MOVWF  x58
....................          isDuplicatedData=0; 
03DF2:  BCF    1E.4
....................           
....................             log_array_SFward[raw_index][0]=no_of_SFward_callsigns; 
03DF4:  CLRF   x6C
03DF6:  MOVFF  C58,C6B
03DFA:  CLRF   x6E
03DFC:  MOVLW  0A
03DFE:  MOVWF  x6D
03E00:  MOVLB  0
03E02:  RCALL  37C4
03E04:  MOVLW  70
03E06:  MOVLB  C
03E08:  ADDWF  01,W
03E0A:  MOVWF  FE9
03E0C:  MOVLW  06
03E0E:  ADDWFC 02,W
03E10:  MOVWF  FEA
03E12:  MOVFF  66F,FEF
....................             for (columnLoop=1;columnLoop<=6;columnLoop++) {log_array_SFward[raw_index][columnLoop]=senderCallsign[columnLoop-1];} 
03E16:  MOVLW  01
03E18:  MOVWF  x56
03E1A:  MOVF   x56,W
03E1C:  SUBLW  06
03E1E:  BNC   3E78
03E20:  CLRF   x6C
03E22:  MOVFF  C58,C6B
03E26:  CLRF   x6E
03E28:  MOVLW  0A
03E2A:  MOVWF  x6D
03E2C:  MOVLB  0
03E2E:  RCALL  37C4
03E30:  MOVFF  01,C59
03E34:  MOVLB  C
03E36:  MOVF   x56,W
03E38:  ADDWF  01,W
03E3A:  MOVWF  01
03E3C:  MOVLW  00
03E3E:  ADDWFC 02,W
03E40:  MOVWF  03
03E42:  MOVF   01,W
03E44:  ADDLW  70
03E46:  MOVWF  01
03E48:  MOVLW  06
03E4A:  ADDWFC 03,F
03E4C:  MOVFF  01,C59
03E50:  MOVFF  03,C5A
03E54:  MOVLW  01
03E56:  SUBWF  x56,W
03E58:  CLRF   03
03E5A:  ADDLW  A5
03E5C:  MOVWF  FE9
03E5E:  MOVLW  04
03E60:  ADDWFC 03,W
03E62:  MOVWF  FEA
03E64:  MOVFF  FEF,C5B
03E68:  MOVFF  C5A,FEA
03E6C:  MOVFF  01,FE9
03E70:  MOVFF  C5B,FEF
03E74:  INCF   x56,F
03E76:  BRA    3E1A
....................             log_array_SFward[raw_index][7]=0; 
03E78:  CLRF   x6C
03E7A:  MOVFF  C58,C6B
03E7E:  CLRF   x6E
03E80:  MOVLW  0A
03E82:  MOVWF  x6D
03E84:  MOVLB  0
03E86:  RCALL  37C4
03E88:  MOVFF  01,C59
03E8C:  MOVLW  07
03E8E:  MOVLB  C
03E90:  ADDWF  01,W
03E92:  MOVWF  01
03E94:  MOVLW  00
03E96:  ADDWFC 02,W
03E98:  MOVWF  03
03E9A:  MOVF   01,W
03E9C:  ADDLW  70
03E9E:  MOVWF  FE9
03EA0:  MOVLW  06
03EA2:  ADDWFC 03,W
03EA4:  MOVWF  FEA
03EA6:  CLRF   FEF
....................             log_array_SFward[raw_index][8]=info_size_SFward; 
03EA8:  CLRF   x6C
03EAA:  MOVFF  C58,C6B
03EAE:  CLRF   x6E
03EB0:  MOVLW  0A
03EB2:  MOVWF  x6D
03EB4:  MOVLB  0
03EB6:  RCALL  37C4
03EB8:  MOVFF  01,C59
03EBC:  MOVLW  08
03EBE:  MOVLB  C
03EC0:  ADDWF  01,W
03EC2:  MOVWF  01
03EC4:  MOVLW  00
03EC6:  ADDWFC 02,W
03EC8:  MOVWF  03
03ECA:  MOVF   01,W
03ECC:  ADDLW  70
03ECE:  MOVWF  FE9
03ED0:  MOVLW  06
03ED2:  ADDWFC 03,W
03ED4:  MOVWF  FEA
03ED6:  MOVFF  4AD,FEF
....................             log_array_SFward[raw_index][9]=Packet_no_APRS; 
03EDA:  CLRF   x6C
03EDC:  MOVFF  C58,C6B
03EE0:  CLRF   x6E
03EE2:  MOVLW  0A
03EE4:  MOVWF  x6D
03EE6:  MOVLB  0
03EE8:  RCALL  37C4
03EEA:  MOVFF  01,C59
03EEE:  MOVLW  09
03EF0:  MOVLB  C
03EF2:  ADDWF  01,W
03EF4:  MOVWF  01
03EF6:  MOVLW  00
03EF8:  ADDWFC 02,W
03EFA:  MOVWF  03
03EFC:  MOVF   01,W
03EFE:  ADDLW  70
03F00:  MOVWF  FE9
03F02:  MOVLW  06
03F04:  ADDWFC 03,W
03F06:  MOVWF  FEA
03F08:  MOVFF  4AE,FEF
....................              
....................             write_log_entery_FM(raw_index); 
03F0C:  MOVFF  C58,C59
03F10:  MOVLB  0
03F12:  BRA    37E6
....................             show_SFward_info_array(); 
03F14:  BRA    39AC
....................       } //if new_entery end  
03F16:  GOTO   42EC (RETURN)
.................... } 
....................  
.................... void prepare_SFwardData(int8 *SF_data) 
.................... { 
....................  //fprintf(debugPort,"Sender Callsign: "); 
.................... // for (i=0;i<=5;++i) {putc(senderCallsing[i]=SF_data[i],debugPort);} 
....................     i=0;  
03F1A:  MOVLB  4
03F1C:  CLRF   x83
03F1E:  CLRF   x82
03F20:  CLRF   x81
03F22:  CLRF   x80
....................    //fprintf(debugPort,"\r\nCALLSIGN\r\n"); 
....................    while (SF_data[i]!=0x3E)  
03F24:  MOVLB  C
03F26:  MOVF   x4F,W
03F28:  MOVLB  4
03F2A:  ADDWF  x80,W
03F2C:  MOVWF  FE9
03F2E:  MOVLB  C
03F30:  MOVF   x50,W
03F32:  MOVLB  4
03F34:  ADDWFC x81,W
03F36:  MOVWF  FEA
03F38:  MOVF   FEF,W
03F3A:  SUBLW  3E
03F3C:  BZ    3F84
....................    { 
....................       senderCallsign[i]=SF_data[i];  
03F3E:  MOVLW  A5
03F40:  ADDWF  x80,W
03F42:  MOVWF  01
03F44:  MOVLW  04
03F46:  ADDWFC x81,W
03F48:  MOVWF  03
03F4A:  MOVLB  C
03F4C:  MOVF   x4F,W
03F4E:  MOVLB  4
03F50:  ADDWF  x80,W
03F52:  MOVWF  FE9
03F54:  MOVLB  C
03F56:  MOVF   x50,W
03F58:  MOVLB  4
03F5A:  ADDWFC x81,W
03F5C:  MOVWF  FEA
03F5E:  MOVFF  FEF,C57
03F62:  MOVLB  C
03F64:  MOVFF  03,FEA
03F68:  MOVFF  01,FE9
03F6C:  MOVFF  C57,FEF
....................        
....................       //putc(senderCallsign[i],debugPort);  
....................       i++; 
03F70:  MOVLW  01
03F72:  MOVLB  4
03F74:  ADDWF  x80,F
03F76:  BTFSC  FD8.0
03F78:  INCF   x81,F
03F7A:  BTFSC  FD8.2
03F7C:  INCF   x82,F
03F7E:  BTFSC  FD8.2
03F80:  INCF   x83,F
03F82:  BRA    3F24
....................    } //0x3E='>' 
....................    //fprintf(debugPort,"\r\n"); 
....................    callsign_size_SFward=i; 
03F84:  MOVFF  480,48B
....................    //fprintf(debugPort,"Callsign size = %d\r\n",callsign_size_SFward); 
....................     
....................    
....................  if ( memcmp(senderCallsign, paraguayCallsign_GS01, 6)==0 )  
03F88:  MOVLW  04
03F8A:  MOVLB  C
03F8C:  MOVWF  x56
03F8E:  MOVLW  A5
03F90:  MOVWF  x55
03F92:  MOVLW  04
03F94:  MOVWF  x58
03F96:  MOVLW  8C
03F98:  MOVWF  x57
03F9A:  CLRF   x5A
03F9C:  MOVLW  06
03F9E:  MOVWF  x59
03FA0:  MOVLB  0
03FA2:  CALL   21A4
03FA6:  MOVF   01,F
03FA8:  BNZ   3FB0
....................  { 
....................  //fprintf(debugPort,"A packet is received from paraguay GS01 \r\n"); 
....................  GS_ID_SFward=paraguayGS01_ID; 
03FAA:  MOVFF  493,4A4
....................  } 
03FAE:  BRA    401C
....................  else if ( memcmp(senderCallsign, philippineCallsign_GS01, 6)==0 ) 
03FB0:  MOVLW  04
03FB2:  MOVLB  C
03FB4:  MOVWF  x56
03FB6:  MOVLW  A5
03FB8:  MOVWF  x55
03FBA:  MOVLW  04
03FBC:  MOVWF  x58
03FBE:  MOVLW  94
03FC0:  MOVWF  x57
03FC2:  CLRF   x5A
03FC4:  MOVLW  06
03FC6:  MOVWF  x59
03FC8:  MOVLB  0
03FCA:  CALL   21A4
03FCE:  MOVF   01,F
03FD0:  BNZ   3FD8
....................  { 
....................  //fprintf(debugPort,"A packet is received from philippine GS01 \r\n"); 
....................  GS_ID_SFward=philippineGS01_ID; 
03FD2:  MOVFF  49B,4A4
....................  } 
03FD6:  BRA    401C
....................   else if ( memcmp(senderCallsign, japanCallsign_GS01, 6)==0 ) 
03FD8:  MOVLW  04
03FDA:  MOVLB  C
03FDC:  MOVWF  x56
03FDE:  MOVLW  A5
03FE0:  MOVWF  x55
03FE2:  MOVLW  04
03FE4:  MOVWF  x58
03FE6:  MOVLW  9C
03FE8:  MOVWF  x57
03FEA:  CLRF   x5A
03FEC:  MOVLW  06
03FEE:  MOVWF  x59
03FF0:  MOVLB  0
03FF2:  CALL   21A4
03FF6:  MOVF   01,F
03FF8:  BNZ   4000
....................  { 
....................  //fprintf(debugPort,"A packet is received from Japan GS01 \r\n"); 
....................  GS_ID_SFward=japanGS01_ID; 
03FFA:  MOVFF  4A3,4A4
....................  } 
03FFE:  BRA    401C
....................  else 
....................  fprintf(debugPort,"A packet is received from new GS \r\n"); 
04000:  MOVLW  B0
04002:  MOVWF  FF6
04004:  MOVLW  09
04006:  MOVWF  FF7
04008:  MOVLW  00
0400A:  MOVWF  FF8
0400C:  CLRF   1B
0400E:  BTFSC  FF2.7
04010:  BSF    1B.7
04012:  BCF    FF2.7
04014:  CALL   0590
04018:  BTFSC  1B.7
0401A:  BSF    FF2.7
....................   
....................    int8 msgStart=0; 
....................    int8 msgEnd=0; 
....................    int8 counterFF=0; 
0401C:  MOVLB  C
0401E:  CLRF   x51
04020:  CLRF   x52
04022:  CLRF   x53
....................    i=0; 
04024:  MOVLB  4
04026:  CLRF   x83
04028:  CLRF   x82
0402A:  CLRF   x81
0402C:  CLRF   x80
....................    while (SF_data[i]!=0x7B) {msgEnd=i++;} //7B='{' 
0402E:  MOVLB  C
04030:  MOVF   x4F,W
04032:  MOVLB  4
04034:  ADDWF  x80,W
04036:  MOVWF  FE9
04038:  MOVLB  C
0403A:  MOVF   x50,W
0403C:  MOVLB  4
0403E:  ADDWFC x81,W
04040:  MOVWF  FEA
04042:  MOVF   FEF,W
04044:  SUBLW  7B
04046:  BZ    406A
04048:  MOVFF  483,03
0404C:  MOVFF  482,02
04050:  MOVFF  481,01
04054:  MOVFF  480,C52
04058:  MOVLW  01
0405A:  ADDWF  x80,F
0405C:  BTFSC  FD8.0
0405E:  INCF   x81,F
04060:  BTFSC  FD8.2
04062:  INCF   x82,F
04064:  BTFSC  FD8.2
04066:  INCF   x83,F
04068:  BRA    402E
....................    //while (SF_data[i]!='a') {msgStart=i--; }                            //need to be changed    
....................    while (SF_data[i]!='G') {msgStart=i--; }                              //changed to this 
0406A:  MOVLB  C
0406C:  MOVF   x4F,W
0406E:  MOVLB  4
04070:  ADDWF  x80,W
04072:  MOVWF  FE9
04074:  MOVLB  C
04076:  MOVF   x50,W
04078:  MOVLB  4
0407A:  ADDWFC x81,W
0407C:  MOVWF  FEA
0407E:  MOVF   FEF,W
04080:  SUBLW  47
04082:  BZ    40A6
04084:  MOVFF  483,03
04088:  MOVFF  482,02
0408C:  MOVFF  481,01
04090:  MOVFF  480,C51
04094:  MOVLW  FF
04096:  ADDWF  x80,F
04098:  BTFSS  FD8.0
0409A:  ADDWF  x81,F
0409C:  BTFSS  FD8.0
0409E:  ADDWF  x82,F
040A0:  BTFSS  FD8.0
040A2:  ADDWF  x83,F
040A4:  BRA    406A
.................... //!    
.................... //!   fprintf(debugPort,"msgStart=%X \r\n",SF_data[msgStart]); 
.................... //!   fprintf(debugPort,"msgEnd=%X \r\n",SF_data[msgEnd]); 
.................... //!   fprintf(debugPort,"value=%X \r\n",msgEnd-msgStart); 
....................    fprintf(debugPort,"SF DATA: "); 
040A6:  MOVLW  D4
040A8:  MOVWF  FF6
040AA:  MOVLW  09
040AC:  MOVWF  FF7
040AE:  MOVLW  00
040B0:  MOVWF  FF8
040B2:  CLRF   1B
040B4:  BTFSC  FF2.7
040B6:  BSF    1B.7
040B8:  BCF    FF2.7
040BA:  MOVLB  0
040BC:  CALL   0590
040C0:  BTFSC  1B.7
040C2:  BSF    FF2.7
....................     
....................     
....................    for (i=0;i<=(msgEnd-msgStart);i++)                                            //changed this to remove callsign from SFward data 
040C4:  MOVLB  4
040C6:  CLRF   x83
040C8:  CLRF   x82
040CA:  CLRF   x81
040CC:  CLRF   x80
040CE:  MOVLB  C
040D0:  MOVF   x51,W
040D2:  SUBWF  x52,W
040D4:  MOVLB  4
040D6:  MOVF   x83,F
040D8:  BNZ   4148
040DA:  MOVF   x82,F
040DC:  BNZ   4148
040DE:  MOVF   x81,F
040E0:  BNZ   4148
040E2:  SUBWF  x80,W
040E4:  BZ    40E8
040E6:  BC    4148
....................    { 
....................       //putc(info_APRS[i]=SF_data[msgStart+i],debugPort); 
....................       putc(SF_data[msgStart+i],debugPort); 
040E8:  MOVLB  C
040EA:  MOVF   x51,W
040EC:  MOVLB  4
040EE:  ADDWF  x80,W
040F0:  MOVLB  C
040F2:  MOVWF  x55
040F4:  MOVLW  00
040F6:  MOVLB  4
040F8:  ADDWFC x81,W
040FA:  MOVLB  C
040FC:  MOVWF  x56
040FE:  MOVLW  00
04100:  MOVLB  4
04102:  ADDWFC x82,W
04104:  MOVLB  C
04106:  MOVWF  x57
04108:  MOVLW  00
0410A:  MOVLB  4
0410C:  ADDWFC x83,W
0410E:  MOVLB  C
04110:  MOVWF  x58
04112:  MOVF   x4F,W
04114:  ADDWF  x55,W
04116:  MOVWF  FE9
04118:  MOVF   x50,W
0411A:  ADDWFC x56,W
0411C:  MOVWF  FEA
0411E:  MOVFF  FEF,C9E
04122:  CLRF   1B
04124:  BTFSC  FF2.7
04126:  BSF    1B.7
04128:  BCF    FF2.7
0412A:  MOVLB  0
0412C:  CALL   054A
04130:  BTFSC  1B.7
04132:  BSF    FF2.7
04134:  MOVLW  01
04136:  MOVLB  4
04138:  ADDWF  x80,F
0413A:  BTFSC  FD8.0
0413C:  INCF   x81,F
0413E:  BTFSC  FD8.2
04140:  INCF   x82,F
04142:  BTFSC  FD8.2
04144:  INCF   x83,F
04146:  BRA    40CE
04148:  CLRF   1B
0414A:  BTFSC  FF2.7
0414C:  BSF    1B.7
0414E:  BCF    FF2.7
....................       //fprintf(debugPort, SF_data[msgStart+i]); 
....................    } 
....................    fprintf(debugPort,"\r\n"); 
04150:  MOVLW  0D
04152:  MOVLB  C
04154:  MOVWF  x9E
04156:  MOVLB  0
04158:  CALL   054A
0415C:  BTFSC  1B.7
0415E:  BSF    FF2.7
04160:  CLRF   1B
04162:  BTFSC  FF2.7
04164:  BSF    1B.7
04166:  BCF    FF2.7
04168:  MOVLW  0A
0416A:  MOVLB  C
0416C:  MOVWF  x9E
0416E:  MOVLB  0
04170:  CALL   054A
04174:  BTFSC  1B.7
04176:  BSF    FF2.7
....................    info_size_SFward=i++; 
04178:  MOVLB  4
0417A:  MOVFF  483,03
0417E:  MOVFF  482,02
04182:  MOVFF  481,01
04186:  MOVFF  480,4AD
0418A:  MOVLW  01
0418C:  ADDWF  x80,F
0418E:  BTFSC  FD8.0
04190:  INCF   x81,F
04192:  BTFSC  FD8.2
04194:  INCF   x82,F
04196:  BTFSC  FD8.2
04198:  INCF   x83,F
....................    //fprintf(debugPort,"SF data size = %d\r\n",info_size_SFward); 
....................     
....................       
....................    //fprintf(debugPort,"first packet_no_APRS = %C\r\n",SF_data[msgEnd+2]); // +2 to go to the packet number first byte 
....................    //fprintf(debugPort,"last  packet_no_APRS = %C\r\n",SF_data[rec_bytes_number_APRS-3]); //-3 to go to the packet number first byte 
....................     
....................    Packet_no_APRS=0; 
0419A:  CLRF   xAE
....................    int8 power=0; 
0419C:  MOVLB  C
0419E:  CLRF   x54
....................    for (i=rec_bytes_number_APRS-3;i>=msgEnd+2;i--) 
041A0:  MOVLW  03
041A2:  MOVLB  4
041A4:  SUBWF  xF6,W
041A6:  MOVWF  x80
041A8:  CLRF   x81
041AA:  CLRF   x82
041AC:  CLRF   x83
041AE:  MOVLW  02
041B0:  MOVLB  C
041B2:  ADDWF  x52,W
041B4:  MOVLB  4
041B6:  MOVF   x83,F
041B8:  BNZ   41C8
041BA:  MOVF   x82,F
041BC:  BNZ   41C8
041BE:  MOVF   x81,F
041C0:  BNZ   41C8
041C2:  SUBWF  x80,W
041C4:  BTFSS  FD8.0
041C6:  BRA    42E8
....................    Packet_no_APRS=Packet_no_APRS+(SF_data[i]-'0')*pow(10,power++); 
041C8:  MOVLB  C
041CA:  MOVF   x4F,W
041CC:  MOVLB  4
041CE:  ADDWF  x80,W
041D0:  MOVWF  FE9
041D2:  MOVLB  C
041D4:  MOVF   x50,W
041D6:  MOVLB  4
041D8:  ADDWFC x81,W
041DA:  MOVWF  FEA
041DC:  MOVLW  30
041DE:  SUBWF  FEF,W
041E0:  MOVLB  C
041E2:  MOVWF  x55
041E4:  MOVF   x54,W
041E6:  INCF   x54,F
041E8:  CLRF   x8B
041EA:  MOVWF  x8A
041EC:  MOVLB  0
041EE:  CALL   2228
041F2:  MOVFF  03,C59
041F6:  MOVFF  02,C58
041FA:  MOVFF  01,C57
041FE:  MOVFF  00,C56
04202:  MOVLB  C
04204:  CLRF   x5D
04206:  CLRF   x5C
04208:  MOVLW  20
0420A:  MOVWF  x5B
0420C:  MOVLW  82
0420E:  MOVWF  x5A
04210:  MOVFF  03,C61
04214:  MOVFF  02,C60
04218:  MOVFF  01,C5F
0421C:  MOVFF  00,C5E
04220:  MOVLB  0
04222:  GOTO   34B8
04226:  MOVFF  03,C59
0422A:  MOVFF  02,C58
0422E:  MOVFF  01,C57
04232:  MOVFF  00,C56
04236:  MOVLB  C
04238:  CLRF   x8B
0423A:  MOVFF  C55,C8A
0423E:  MOVLB  0
04240:  CALL   2228
04244:  MOVFF  03,C89
04248:  MOVFF  02,C88
0424C:  MOVFF  01,C87
04250:  MOVFF  00,C86
04254:  MOVFF  C59,C8D
04258:  MOVFF  C58,C8C
0425C:  MOVFF  C57,C8B
04260:  MOVFF  C56,C8A
04264:  CALL   2472
04268:  MOVFF  03,C5D
0426C:  MOVFF  02,C5C
04270:  MOVFF  01,C5B
04274:  MOVFF  00,C5A
04278:  MOVLB  C
0427A:  CLRF   x8B
0427C:  MOVFF  4AE,C8A
04280:  MOVLB  0
04282:  CALL   2228
04286:  MOVFF  FEA,C5F
0428A:  MOVFF  FE9,C5E
0428E:  BCF    FD8.1
04290:  MOVFF  03,C8D
04294:  MOVFF  02,C8C
04298:  MOVFF  01,C8B
0429C:  MOVFF  00,C8A
042A0:  MOVFF  C5D,C91
042A4:  MOVFF  C5C,C90
042A8:  MOVFF  C5B,C8F
042AC:  MOVFF  C5A,C8E
042B0:  CALL   2568
042B4:  MOVFF  C5F,FEA
042B8:  MOVFF  C5E,FE9
042BC:  MOVFF  03,C89
042C0:  MOVFF  02,C88
042C4:  MOVFF  01,C87
042C8:  MOVFF  00,C86
042CC:  CALL   2436
042D0:  MOVFF  01,4AE
042D4:  MOVLW  FF
042D6:  MOVLB  4
042D8:  ADDWF  x80,F
042DA:  BTFSS  FD8.0
042DC:  ADDWF  x81,F
042DE:  BTFSS  FD8.0
042E0:  ADDWF  x82,F
042E2:  BTFSS  FD8.0
042E4:  ADDWF  x83,F
042E6:  BRA    41AE
....................     
....................    //fprintf(debugPort,"Packet_no = %d (%X hex)\r\n",Packet_no_APRS,Packet_no_APRS); 
....................     
.................... //!    
.................... //!    
.................... //!  
.................... //! fprintf(debugPort,"SF Data: "); 
.................... //! i=0; 
.................... //! while (SF_data[32+i]!=0x7B)  {putc(info_APRS[i]=SF_data[32+i],debugPort); i++;}  //0x7B='{' 
.................... //! //34 is the first byte of the msg 
.................... //! fprintf(debugPort,"\r\n"); 
.................... //!   
.................... //! fprintf(debugPort,"SF data size = %d\r\n",info_size_SFward=i); 
....................     
....................    update_SFward_info_array_RAM(); 
042E8:  MOVLB  0
042EA:  BRA    3B26
042EC:  GOTO   6A0A (RETURN)
....................  
.................... } 
....................  
.................... void sendAckVHF(void) 
.................... { 
*
0214A:  GOTO   218A (RETURN)
....................     
.................... } 
....................  
.................... int1 is_sent_to_me (int8 *SF_data) 
.................... { 
....................    i=0; 
*
01E96:  MOVLB  4
01E98:  CLRF   x83
01E9A:  CLRF   x82
01E9C:  CLRF   x81
01E9E:  CLRF   x80
....................    while (i < rec_bytes_number_APRS) 
01EA0:  MOVF   x83,F
01EA2:  BTFSS  FD8.2
01EA4:  BRA    213E
01EA6:  MOVF   x82,F
01EA8:  BTFSS  FD8.2
01EAA:  BRA    213E
01EAC:  MOVF   x81,F
01EAE:  BTFSS  FD8.2
01EB0:  BRA    213E
01EB2:  MOVF   xF6,W
01EB4:  SUBWF  x80,W
01EB6:  BTFSC  FD8.0
01EB8:  BRA    213E
....................    { 
....................       if (SF_data[i]==0x3A && SF_data[i+1]==0x3A) 
01EBA:  MOVLB  C
01EBC:  MOVF   x4F,W
01EBE:  MOVLB  4
01EC0:  ADDWF  x80,W
01EC2:  MOVWF  FE9
01EC4:  MOVLB  C
01EC6:  MOVF   x50,W
01EC8:  MOVLB  4
01ECA:  ADDWFC x81,W
01ECC:  MOVWF  FEA
01ECE:  MOVF   FEF,W
01ED0:  SUBLW  3A
01ED2:  BTFSS  FD8.2
01ED4:  BRA    212C
01ED6:  MOVLW  01
01ED8:  ADDWF  x80,W
01EDA:  MOVLB  C
01EDC:  MOVWF  x51
01EDE:  MOVLW  00
01EE0:  MOVLB  4
01EE2:  ADDWFC x81,W
01EE4:  MOVLB  C
01EE6:  MOVWF  x52
01EE8:  MOVLW  00
01EEA:  MOVLB  4
01EEC:  ADDWFC x82,W
01EEE:  MOVLB  C
01EF0:  MOVWF  x53
01EF2:  MOVLW  00
01EF4:  MOVLB  4
01EF6:  ADDWFC x83,W
01EF8:  MOVLB  C
01EFA:  MOVWF  x54
01EFC:  MOVF   x4F,W
01EFE:  ADDWF  x51,W
01F00:  MOVWF  FE9
01F02:  MOVF   x50,W
01F04:  ADDWFC x52,W
01F06:  MOVWF  FEA
01F08:  MOVF   FEF,W
01F0A:  SUBLW  3A
01F0C:  BTFSC  FD8.2
01F0E:  BRA    1F14
01F10:  MOVLB  4
01F12:  BRA    212C
....................       { 
....................          if (SF_data[i+2]=='B') 
01F14:  MOVLW  02
01F16:  MOVLB  4
01F18:  ADDWF  x80,W
01F1A:  MOVLB  C
01F1C:  MOVWF  x51
01F1E:  MOVLW  00
01F20:  MOVLB  4
01F22:  ADDWFC x81,W
01F24:  MOVLB  C
01F26:  MOVWF  x52
01F28:  MOVLW  00
01F2A:  MOVLB  4
01F2C:  ADDWFC x82,W
01F2E:  MOVLB  C
01F30:  MOVWF  x53
01F32:  MOVLW  00
01F34:  MOVLB  4
01F36:  ADDWFC x83,W
01F38:  MOVLB  C
01F3A:  MOVWF  x54
01F3C:  MOVF   x4F,W
01F3E:  ADDWF  x51,W
01F40:  MOVWF  FE9
01F42:  MOVF   x50,W
01F44:  ADDWFC x52,W
01F46:  MOVWF  FEA
01F48:  MOVF   FEF,W
01F4A:  SUBLW  42
01F4C:  BTFSS  FD8.2
01F4E:  BRA    212A
....................             if (SF_data[i+3]=='I') 
01F50:  MOVLW  03
01F52:  MOVLB  4
01F54:  ADDWF  x80,W
01F56:  MOVLB  C
01F58:  MOVWF  x51
01F5A:  MOVLW  00
01F5C:  MOVLB  4
01F5E:  ADDWFC x81,W
01F60:  MOVLB  C
01F62:  MOVWF  x52
01F64:  MOVLW  00
01F66:  MOVLB  4
01F68:  ADDWFC x82,W
01F6A:  MOVLB  C
01F6C:  MOVWF  x53
01F6E:  MOVLW  00
01F70:  MOVLB  4
01F72:  ADDWFC x83,W
01F74:  MOVLB  C
01F76:  MOVWF  x54
01F78:  MOVF   x4F,W
01F7A:  ADDWF  x51,W
01F7C:  MOVWF  FE9
01F7E:  MOVF   x50,W
01F80:  ADDWFC x52,W
01F82:  MOVWF  FEA
01F84:  MOVF   FEF,W
01F86:  SUBLW  49
01F88:  BTFSS  FD8.2
01F8A:  BRA    212A
....................                if (SF_data[i+4]=='R') 
01F8C:  MOVLW  04
01F8E:  MOVLB  4
01F90:  ADDWF  x80,W
01F92:  MOVLB  C
01F94:  MOVWF  x51
01F96:  MOVLW  00
01F98:  MOVLB  4
01F9A:  ADDWFC x81,W
01F9C:  MOVLB  C
01F9E:  MOVWF  x52
01FA0:  MOVLW  00
01FA2:  MOVLB  4
01FA4:  ADDWFC x82,W
01FA6:  MOVLB  C
01FA8:  MOVWF  x53
01FAA:  MOVLW  00
01FAC:  MOVLB  4
01FAE:  ADDWFC x83,W
01FB0:  MOVLB  C
01FB2:  MOVWF  x54
01FB4:  MOVF   x4F,W
01FB6:  ADDWF  x51,W
01FB8:  MOVWF  FE9
01FBA:  MOVF   x50,W
01FBC:  ADDWFC x52,W
01FBE:  MOVWF  FEA
01FC0:  MOVF   FEF,W
01FC2:  SUBLW  52
01FC4:  BTFSS  FD8.2
01FC6:  BRA    212A
....................                   if (SF_data[i+5]=='D') 
01FC8:  MOVLW  05
01FCA:  MOVLB  4
01FCC:  ADDWF  x80,W
01FCE:  MOVLB  C
01FD0:  MOVWF  x51
01FD2:  MOVLW  00
01FD4:  MOVLB  4
01FD6:  ADDWFC x81,W
01FD8:  MOVLB  C
01FDA:  MOVWF  x52
01FDC:  MOVLW  00
01FDE:  MOVLB  4
01FE0:  ADDWFC x82,W
01FE2:  MOVLB  C
01FE4:  MOVWF  x53
01FE6:  MOVLW  00
01FE8:  MOVLB  4
01FEA:  ADDWFC x83,W
01FEC:  MOVLB  C
01FEE:  MOVWF  x54
01FF0:  MOVF   x4F,W
01FF2:  ADDWF  x51,W
01FF4:  MOVWF  FE9
01FF6:  MOVF   x50,W
01FF8:  ADDWFC x52,W
01FFA:  MOVWF  FEA
01FFC:  MOVF   FEF,W
01FFE:  SUBLW  44
02000:  BTFSS  FD8.2
02002:  BRA    212A
....................                      //if ((SF_data[i+6]=='J')||(SF_data[i+6]=='S')) 
....................                      if ((SF_data[i+6]==READ_DATA_BYTE4(0x2004))||(SF_data[i+6]=='S')) 
02004:  MOVLW  06
02006:  MOVLB  4
02008:  ADDWF  x80,W
0200A:  MOVLB  C
0200C:  MOVWF  x51
0200E:  MOVLW  00
02010:  MOVLB  4
02012:  ADDWFC x81,W
02014:  MOVLB  C
02016:  MOVWF  x52
02018:  MOVLW  00
0201A:  MOVLB  4
0201C:  ADDWFC x82,W
0201E:  MOVLB  C
02020:  MOVWF  x53
02022:  MOVLW  00
02024:  MOVLB  4
02026:  ADDWFC x83,W
02028:  MOVLB  C
0202A:  MOVWF  x54
0202C:  MOVF   x4F,W
0202E:  ADDWF  x51,W
02030:  MOVWF  FE9
02032:  MOVF   x50,W
02034:  ADDWFC x52,W
02036:  MOVWF  FEA
02038:  MOVFF  FEF,C55
0203C:  CLRF   x6D
0203E:  CLRF   x6C
02040:  MOVLW  20
02042:  MOVWF  x6B
02044:  MOVLW  04
02046:  MOVWF  x6A
02048:  MOVLB  0
0204A:  CALL   0E60
0204E:  MOVF   01,W
02050:  MOVLB  C
02052:  SUBWF  x55,W
02054:  BZ    2090
02056:  MOVLW  06
02058:  MOVLB  4
0205A:  ADDWF  x80,W
0205C:  MOVLB  C
0205E:  MOVWF  x55
02060:  MOVLW  00
02062:  MOVLB  4
02064:  ADDWFC x81,W
02066:  MOVLB  C
02068:  MOVWF  x56
0206A:  MOVLW  00
0206C:  MOVLB  4
0206E:  ADDWFC x82,W
02070:  MOVLB  C
02072:  MOVWF  x57
02074:  MOVLW  00
02076:  MOVLB  4
02078:  ADDWFC x83,W
0207A:  MOVLB  C
0207C:  MOVWF  x58
0207E:  MOVF   x4F,W
02080:  ADDWF  x55,W
02082:  MOVWF  FE9
02084:  MOVF   x50,W
02086:  ADDWFC x56,W
02088:  MOVWF  FEA
0208A:  MOVF   FEF,W
0208C:  SUBLW  53
0208E:  BNZ   212A
....................                         //if ((SF_data[i+7]=='P')||(SF_data[i+7]=='4')) 
....................                         if ((SF_data[i+7]==READ_DATA_BYTE4(0x2005))||(SF_data[i+7]=='5')) 
02090:  MOVLW  07
02092:  MOVLB  4
02094:  ADDWF  x80,W
02096:  MOVLB  C
02098:  MOVWF  x51
0209A:  MOVLW  00
0209C:  MOVLB  4
0209E:  ADDWFC x81,W
020A0:  MOVLB  C
020A2:  MOVWF  x52
020A4:  MOVLW  00
020A6:  MOVLB  4
020A8:  ADDWFC x82,W
020AA:  MOVLB  C
020AC:  MOVWF  x53
020AE:  MOVLW  00
020B0:  MOVLB  4
020B2:  ADDWFC x83,W
020B4:  MOVLB  C
020B6:  MOVWF  x54
020B8:  MOVF   x4F,W
020BA:  ADDWF  x51,W
020BC:  MOVWF  FE9
020BE:  MOVF   x50,W
020C0:  ADDWFC x52,W
020C2:  MOVWF  FEA
020C4:  MOVFF  FEF,C55
020C8:  CLRF   x6D
020CA:  CLRF   x6C
020CC:  MOVLW  20
020CE:  MOVWF  x6B
020D0:  MOVLW  05
020D2:  MOVWF  x6A
020D4:  MOVLB  0
020D6:  CALL   0E60
020DA:  MOVF   01,W
020DC:  MOVLB  C
020DE:  SUBWF  x55,W
020E0:  BZ    211C
020E2:  MOVLW  07
020E4:  MOVLB  4
020E6:  ADDWF  x80,W
020E8:  MOVLB  C
020EA:  MOVWF  x55
020EC:  MOVLW  00
020EE:  MOVLB  4
020F0:  ADDWFC x81,W
020F2:  MOVLB  C
020F4:  MOVWF  x56
020F6:  MOVLW  00
020F8:  MOVLB  4
020FA:  ADDWFC x82,W
020FC:  MOVLB  C
020FE:  MOVWF  x57
02100:  MOVLW  00
02102:  MOVLB  4
02104:  ADDWFC x83,W
02106:  MOVLB  C
02108:  MOVWF  x58
0210A:  MOVF   x4F,W
0210C:  ADDWF  x55,W
0210E:  MOVWF  FE9
02110:  MOVF   x50,W
02112:  ADDWFC x56,W
02114:  MOVWF  FEA
02116:  MOVF   FEF,W
02118:  SUBLW  35
0211A:  BNZ   2124
....................                         { 
....................                            //fprintf(debugPort,"Received data is sent to THIS satellite \r\n"); 
....................                            return 1; 
0211C:  MOVLW  01
0211E:  MOVWF  01
02120:  BRA    2144
....................                         } 
02122:  BRA    212A
....................                         else return 0; 
02124:  MOVLW  00
02126:  MOVWF  01
02128:  BRA    2144
0212A:  MOVLB  4
....................       } 
....................       i++; 
0212C:  MOVLW  01
0212E:  ADDWF  x80,F
02130:  BTFSC  FD8.0
02132:  INCF   x81,F
02134:  BTFSC  FD8.2
02136:  INCF   x82,F
02138:  BTFSC  FD8.2
0213A:  INCF   x83,F
0213C:  BRA    1EA0
....................     } 
....................     return 0; 
0213E:  MOVLW  00
02140:  MOVWF  01
02142:  MOVLB  C
02144:  MOVLB  0
02146:  GOTO   69E2 (RETURN)
.................... } 
....................  
.................... int1 is_valid_SFward (int8 *SF_data) 
.................... { 
....................    if (SF_data[32]=='S') 
*
0214E:  MOVLW  20
02150:  MOVLB  C
02152:  ADDWF  x4F,W
02154:  MOVWF  FE9
02156:  MOVLW  00
02158:  ADDWFC x50,W
0215A:  MOVWF  FEA
0215C:  MOVF   FEF,W
0215E:  SUBLW  53
02160:  BNZ   219A
....................       if (SF_data[33]=='F') 
02162:  MOVLW  21
02164:  ADDWF  x4F,W
02166:  MOVWF  FE9
02168:  MOVLW  00
0216A:  ADDWFC x50,W
0216C:  MOVWF  FEA
0216E:  MOVF   FEF,W
02170:  SUBLW  46
02172:  BNZ   2194
....................       { 
....................          if(SF_data[34]=='V') {sendAckVHF();} 
02174:  MOVLW  22
02176:  ADDWF  x4F,W
02178:  MOVWF  FE9
0217A:  MOVLW  00
0217C:  ADDWFC x50,W
0217E:  MOVWF  FEA
02180:  MOVF   FEF,W
02182:  SUBLW  56
02184:  BNZ   218C
02186:  MOVLB  0
02188:  BRA    214A
0218A:  MOVLB  C
....................          return 1; 
0218C:  MOVLW  01
0218E:  MOVWF  01
02190:  BRA    219E
....................       } 
02192:  BRA    219A
....................   else return 1; //should be return 0  
02194:  MOVLW  01
02196:  MOVWF  01
02198:  BRA    219E
....................   return 1; 
0219A:  MOVLW  01
0219C:  MOVWF  01
0219E:  MOVLB  0
021A0:  GOTO   69F6 (RETURN)
.................... } 
....................  
.................... void write_SFwad_data_toFM(int8 *SF_data) 
.................... { 
....................    int32 subsector4kbNo; 
....................     
....................    first_adsress[0]=READ_DATA_BYTE4(SF_Data_Addres_pointer  ); 
*
0432A:  MOVLB  C
0432C:  CLRF   x6D
0432E:  MOVLW  01
04330:  MOVWF  x6C
04332:  CLRF   x6B
04334:  CLRF   x6A
04336:  MOVLB  0
04338:  CALL   0E60
0433C:  MOVFF  01,667
....................    first_adsress[1]=READ_DATA_BYTE4(SF_Data_Addres_pointer+1); 
04340:  MOVLB  C
04342:  CLRF   x6D
04344:  MOVLW  01
04346:  MOVWF  x6C
04348:  CLRF   x6B
0434A:  MOVWF  x6A
0434C:  MOVLB  0
0434E:  CALL   0E60
04352:  MOVFF  01,668
....................    first_adsress[2]=READ_DATA_BYTE4(SF_Data_Addres_pointer+2); 
04356:  MOVLB  C
04358:  CLRF   x6D
0435A:  MOVLW  01
0435C:  MOVWF  x6C
0435E:  CLRF   x6B
04360:  MOVLW  02
04362:  MOVWF  x6A
04364:  MOVLB  0
04366:  CALL   0E60
0436A:  MOVFF  01,669
....................    first_adsress[3]=READ_DATA_BYTE4(SF_Data_Addres_pointer+3); 
0436E:  MOVLB  C
04370:  CLRF   x6D
04372:  MOVLW  01
04374:  MOVWF  x6C
04376:  CLRF   x6B
04378:  MOVLW  03
0437A:  MOVWF  x6A
0437C:  MOVLB  0
0437E:  CALL   0E60
04382:  MOVFF  01,66A
....................  
....................    SF_Data_Addres=make32(first_adsress[0],first_adsress[1],first_adsress[2],first_adsress[3]); 
04386:  MOVFF  667,666
0438A:  MOVFF  668,665
0438E:  MOVFF  669,664
04392:  MOVFF  66A,663
....................     
....................    if ((SF_Data_Addres >= 0x05FEE000 )||(SF_Data_Addres <= SF_Data_start_Adrs-1 )) 
04396:  MOVLB  6
04398:  MOVF   x66,W
0439A:  SUBLW  04
0439C:  BC    43B2
0439E:  XORLW  FF
043A0:  BNZ   43C4
043A2:  MOVF   x65,W
043A4:  SUBLW  FD
043A6:  BC    43B2
043A8:  XORLW  FF
043AA:  BNZ   43C4
043AC:  MOVF   x64,W
043AE:  SUBLW  DF
043B0:  BNC   43C4
043B2:  MOVF   x66,F
043B4:  BNZ   447A
043B6:  MOVF   x65,W
043B8:  SUBLW  01
043BA:  BNC   447A
043BC:  BNZ   43C4
043BE:  MOVF   x64,W
043C0:  SUBLW  0F
043C2:  BNC   447A
....................    { 
....................       SUBSECTOR_4KB_ERASE4(SF_Data_start_Adrs); 
043C4:  MOVLB  C
043C6:  CLRF   x6C
043C8:  MOVLW  01
043CA:  MOVWF  x6B
043CC:  MOVLW  10
043CE:  MOVWF  x6A
043D0:  CLRF   x69
043D2:  MOVLB  0
043D4:  CALL   0FF4
....................       SUBSECTOR_4KB_ERASE4(SF_Data_Addres_pointer); // we need to erase all sectors not the first one only,  
043D8:  MOVLB  C
043DA:  CLRF   x6C
043DC:  MOVLW  01
043DE:  MOVWF  x6B
043E0:  CLRF   x6A
043E2:  CLRF   x69
043E4:  MOVLB  0
043E6:  CALL   0FF4
....................       SF_Data_Addres=SF_Data_start_Adrs; 
043EA:  MOVLB  6
043EC:  CLRF   x66
043EE:  MOVLW  01
043F0:  MOVWF  x65
043F2:  MOVLW  10
043F4:  MOVWF  x64
043F6:  CLRF   x63
....................       WRITE_DATA_BYTE4(SF_Data_Addres_pointer  ,SF_Data_Addres>>24); 
043F8:  MOVFF  666,C56
043FC:  MOVLB  C
043FE:  CLRF   x57
04400:  CLRF   x58
04402:  CLRF   x59
04404:  CLRF   x71
04406:  MOVLW  01
04408:  MOVWF  x70
0440A:  CLRF   x6F
0440C:  CLRF   x6E
0440E:  MOVFF  666,C72
04412:  MOVLB  0
04414:  CALL   16DC
....................       WRITE_DATA_BYTE4(SF_Data_Addres_pointer+1,SF_Data_Addres>>16); 
04418:  MOVFF  665,C56
0441C:  MOVFF  666,C57
04420:  MOVLB  C
04422:  CLRF   x58
04424:  CLRF   x59
04426:  CLRF   x71
04428:  MOVLW  01
0442A:  MOVWF  x70
0442C:  CLRF   x6F
0442E:  MOVWF  x6E
04430:  MOVFF  665,C72
04434:  MOVLB  0
04436:  CALL   16DC
....................       WRITE_DATA_BYTE4(SF_Data_Addres_pointer+2,SF_Data_Addres>>8); 
0443A:  MOVFF  664,C56
0443E:  MOVFF  665,C57
04442:  MOVFF  666,C58
04446:  MOVLB  C
04448:  CLRF   x59
0444A:  CLRF   x71
0444C:  MOVLW  01
0444E:  MOVWF  x70
04450:  CLRF   x6F
04452:  MOVLW  02
04454:  MOVWF  x6E
04456:  MOVFF  664,C72
0445A:  MOVLB  0
0445C:  CALL   16DC
....................       WRITE_DATA_BYTE4(SF_Data_Addres_pointer+3,SF_Data_Addres); 
04460:  MOVLB  C
04462:  CLRF   x71
04464:  MOVLW  01
04466:  MOVWF  x70
04468:  CLRF   x6F
0446A:  MOVLW  03
0446C:  MOVWF  x6E
0446E:  MOVFF  663,C72
04472:  MOVLB  0
04474:  CALL   16DC
04478:  MOVLB  6
....................    } 
....................     
....................    for (subsector4kbNo=adrs2subsector4kb(SF_Data_Addres)+1; subsector4kbNo<=adrs2subsector4kb(SF_Data_Addres+rec_bytes_number_APRS);subsector4kbNo++) 
0447A:  MOVFF  666,C5E
0447E:  MOVFF  665,C5D
04482:  MOVFF  664,C5C
04486:  MOVFF  663,C5B
0448A:  MOVLB  0
0448C:  RCALL  42F0
0448E:  MOVFF  03,C58
04492:  MOVFF  02,C57
04496:  MOVFF  01,C56
0449A:  MOVFF  00,C55
0449E:  MOVLW  01
044A0:  MOVLB  C
044A2:  ADDWF  00,W
044A4:  MOVWF  x51
044A6:  MOVLW  00
044A8:  ADDWFC 01,W
044AA:  MOVWF  x52
044AC:  MOVLW  00
044AE:  ADDWFC 02,W
044B0:  MOVWF  x53
044B2:  MOVLW  00
044B4:  ADDWFC 03,W
044B6:  MOVWF  x54
044B8:  MOVLB  4
044BA:  MOVF   xF6,W
044BC:  MOVLB  6
044BE:  ADDWF  x63,W
044C0:  MOVLB  C
044C2:  MOVWF  x55
044C4:  MOVLW  00
044C6:  MOVLB  6
044C8:  ADDWFC x64,W
044CA:  MOVLB  C
044CC:  MOVWF  x56
044CE:  MOVLW  00
044D0:  MOVLB  6
044D2:  ADDWFC x65,W
044D4:  MOVLB  C
044D6:  MOVWF  x57
044D8:  MOVLW  00
044DA:  MOVLB  6
044DC:  ADDWFC x66,W
044DE:  MOVLB  C
044E0:  MOVWF  x58
044E2:  MOVWF  x5E
044E4:  MOVFF  C57,C5D
044E8:  MOVFF  C56,C5C
044EC:  MOVFF  C55,C5B
044F0:  MOVLB  0
044F2:  RCALL  42F0
044F4:  MOVLB  C
044F6:  MOVF   x54,W
044F8:  SUBWF  03,W
044FA:  BNC   4562
044FC:  BNZ   4514
044FE:  MOVF   x53,W
04500:  SUBWF  02,W
04502:  BNC   4562
04504:  BNZ   4514
04506:  MOVF   x52,W
04508:  SUBWF  01,W
0450A:  BNC   4562
0450C:  BNZ   4514
0450E:  MOVF   x51,W
04510:  SUBWF  00,W
04512:  BNC   4562
....................    { 
....................       SUBSECTOR_4KB_ERASE4(subsector4kbNo*0x1000); 
04514:  CLRF   x55
04516:  RLCF   x51,W
04518:  MOVWF  x56
0451A:  RLCF   x52,W
0451C:  MOVWF  x57
0451E:  RLCF   x53,W
04520:  MOVWF  x58
04522:  RLCF   x56,F
04524:  RLCF   x57,F
04526:  RLCF   x58,F
04528:  RLCF   x56,F
0452A:  RLCF   x57,F
0452C:  RLCF   x58,F
0452E:  RLCF   x56,F
04530:  RLCF   x57,F
04532:  RLCF   x58,F
04534:  MOVLW  F0
04536:  ANDWF  x56,F
04538:  MOVFF  C58,C6C
0453C:  MOVFF  C57,C6B
04540:  MOVFF  C56,C6A
04544:  MOVFF  C55,C69
04548:  MOVLB  0
0454A:  CALL   0FF4
0454E:  MOVLW  01
04550:  MOVLB  C
04552:  ADDWF  x51,F
04554:  BTFSC  FD8.0
04556:  INCF   x52,F
04558:  BTFSC  FD8.2
0455A:  INCF   x53,F
0455C:  BTFSC  FD8.2
0455E:  INCF   x54,F
04560:  BRA    44B8
....................    } 
....................  
....................    WRITE_DATA_BYTE4(SF_Data_Addres++,GS_ID_SFward);delay_ms(delayTX); 
04562:  MOVLB  6
04564:  MOVFF  666,03
04568:  MOVFF  665,02
0456C:  MOVFF  664,01
04570:  MOVFF  663,00
04574:  MOVLW  01
04576:  ADDWF  x63,F
04578:  BTFSC  FD8.0
0457A:  INCF   x64,F
0457C:  BTFSC  FD8.2
0457E:  INCF   x65,F
04580:  BTFSC  FD8.2
04582:  INCF   x66,F
04584:  MOVFF  03,C58
04588:  MOVFF  02,C57
0458C:  MOVFF  01,C56
04590:  MOVFF  00,C55
04594:  MOVFF  03,C71
04598:  MOVFF  02,C70
0459C:  MOVFF  01,C6F
045A0:  MOVFF  00,C6E
045A4:  MOVFF  4A4,C72
045A8:  MOVLB  0
045AA:  CALL   16DC
045AE:  MOVLW  0A
045B0:  MOVLB  C
045B2:  MOVWF  x86
045B4:  MOVLB  0
045B6:  CALL   0EE2
....................    WRITE_DATA_BYTE4(SF_Data_Addres++,GS_ID_SFward);delay_ms(delayTX);   //change this to use multible bytes write functoin 
045BA:  MOVLB  6
045BC:  MOVFF  666,03
045C0:  MOVFF  665,02
045C4:  MOVFF  664,01
045C8:  MOVFF  663,00
045CC:  MOVLW  01
045CE:  ADDWF  x63,F
045D0:  BTFSC  FD8.0
045D2:  INCF   x64,F
045D4:  BTFSC  FD8.2
045D6:  INCF   x65,F
045D8:  BTFSC  FD8.2
045DA:  INCF   x66,F
045DC:  MOVFF  03,C58
045E0:  MOVFF  02,C57
045E4:  MOVFF  01,C56
045E8:  MOVFF  00,C55
045EC:  MOVFF  03,C71
045F0:  MOVFF  02,C70
045F4:  MOVFF  01,C6F
045F8:  MOVFF  00,C6E
045FC:  MOVFF  4A4,C72
04600:  MOVLB  0
04602:  CALL   16DC
04606:  MOVLW  0A
04608:  MOVLB  C
0460A:  MOVWF  x86
0460C:  MOVLB  0
0460E:  CALL   0EE2
....................    if (1==0)//(GS_ID_SFward==0)  
....................    { 
....................       WRITE_DATA_BYTE4(SF_Data_Addres++,callsign_size_SFward);delay_ms(delayTX); 
....................       for (i=0;i>callsign_size_SFward;i++) 
....................       { 
....................          WRITE_DATA_BYTE4(SF_Data_Addres++,senderCallsign[i]); 
....................          delay_ms(10); 
....................       } 
....................    } 
....................    SF_Data_Addres=WRITE_DATA_N_BYTE4(SF_Data_Addres,callsign_size_SFward,senderCallsign); // Check that the callsign_size_SFward is the correct value 
04612:  MOVFF  666,C6C
04616:  MOVFF  665,C6B
0461A:  MOVFF  664,C6A
0461E:  MOVFF  663,C69
04622:  MOVLB  C
04624:  CLRF   x70
04626:  CLRF   x6F
04628:  CLRF   x6E
0462A:  MOVFF  48B,C6D
0462E:  MOVLW  04
04630:  MOVWF  x72
04632:  MOVLW  A5
04634:  MOVWF  x71
04636:  MOVLB  0
04638:  CALL   1158
0463C:  MOVFF  03,666
04640:  MOVFF  02,665
04644:  MOVFF  01,664
04648:  MOVFF  00,663
....................     
....................    WRITE_DATA_BYTE4(SF_Data_Addres++,0xFF);delay_ms(delayTX); 
0464C:  MOVLB  6
0464E:  MOVFF  666,03
04652:  MOVFF  665,02
04656:  MOVFF  664,01
0465A:  MOVFF  663,00
0465E:  MOVLW  01
04660:  ADDWF  x63,F
04662:  BTFSC  FD8.0
04664:  INCF   x64,F
04666:  BTFSC  FD8.2
04668:  INCF   x65,F
0466A:  BTFSC  FD8.2
0466C:  INCF   x66,F
0466E:  MOVFF  03,C58
04672:  MOVFF  02,C57
04676:  MOVFF  01,C56
0467A:  MOVFF  00,C55
0467E:  MOVFF  03,C71
04682:  MOVFF  02,C70
04686:  MOVFF  01,C6F
0468A:  MOVFF  00,C6E
0468E:  MOVLB  C
04690:  SETF   x72
04692:  MOVLB  0
04694:  CALL   16DC
04698:  MOVLW  0A
0469A:  MOVLB  C
0469C:  MOVWF  x86
0469E:  MOVLB  0
046A0:  CALL   0EE2
....................    WRITE_DATA_BYTE4(SF_Data_Addres++,info_size_SFward);delay_ms(delayTX); 
046A4:  MOVLB  6
046A6:  MOVFF  666,03
046AA:  MOVFF  665,02
046AE:  MOVFF  664,01
046B2:  MOVFF  663,00
046B6:  MOVLW  01
046B8:  ADDWF  x63,F
046BA:  BTFSC  FD8.0
046BC:  INCF   x64,F
046BE:  BTFSC  FD8.2
046C0:  INCF   x65,F
046C2:  BTFSC  FD8.2
046C4:  INCF   x66,F
046C6:  MOVFF  03,C58
046CA:  MOVFF  02,C57
046CE:  MOVFF  01,C56
046D2:  MOVFF  00,C55
046D6:  MOVFF  03,C71
046DA:  MOVFF  02,C70
046DE:  MOVFF  01,C6F
046E2:  MOVFF  00,C6E
046E6:  MOVFF  4AD,C72
046EA:  MOVLB  0
046EC:  CALL   16DC
046F0:  MOVLW  0A
046F2:  MOVLB  C
046F4:  MOVWF  x86
046F6:  MOVLB  0
046F8:  CALL   0EE2
....................  
....................    i=0; 
046FC:  MOVLB  4
046FE:  CLRF   x83
04700:  CLRF   x82
04702:  CLRF   x81
04704:  CLRF   x80
....................    while (SF_data[32+i]!=0x7B)  //0x7B='{'   
04706:  MOVLW  20
04708:  ADDWF  x80,W
0470A:  MOVLB  C
0470C:  MOVWF  x55
0470E:  MOVLW  00
04710:  MOVLB  4
04712:  ADDWFC x81,W
04714:  MOVLB  C
04716:  MOVWF  x56
04718:  MOVLW  00
0471A:  MOVLB  4
0471C:  ADDWFC x82,W
0471E:  MOVLB  C
04720:  MOVWF  x57
04722:  MOVLW  00
04724:  MOVLB  4
04726:  ADDWFC x83,W
04728:  MOVLB  C
0472A:  MOVWF  x58
0472C:  MOVF   x4F,W
0472E:  ADDWF  x55,W
04730:  MOVWF  FE9
04732:  MOVF   x50,W
04734:  ADDWFC x56,W
04736:  MOVWF  FEA
04738:  MOVF   FEF,W
0473A:  SUBLW  7B
0473C:  BZ    47BA
....................    { 
....................       //WRITE_DATA_BYTE4(SF_Data_Addres++,SF_data[32+i]); 
....................       WRITE_DATA_BYTE4(SF_Data_Addres++,info_APRS[i]); 
0473E:  MOVLB  6
04740:  MOVFF  666,03
04744:  MOVFF  665,02
04748:  MOVFF  664,01
0474C:  MOVFF  663,00
04750:  MOVLW  01
04752:  ADDWF  x63,F
04754:  BTFSC  FD8.0
04756:  INCF   x64,F
04758:  BTFSC  FD8.2
0475A:  INCF   x65,F
0475C:  BTFSC  FD8.2
0475E:  INCF   x66,F
04760:  MOVFF  03,C58
04764:  MOVFF  02,C57
04768:  MOVFF  01,C56
0476C:  MOVFF  00,C55
04770:  MOVLW  AF
04772:  MOVLB  4
04774:  ADDWF  x80,W
04776:  MOVWF  FE9
04778:  MOVLW  04
0477A:  ADDWFC x81,W
0477C:  MOVWF  FEA
0477E:  MOVFF  FEF,C72
04782:  MOVFF  03,C71
04786:  MOVFF  02,C70
0478A:  MOVFF  01,C6F
0478E:  MOVFF  00,C6E
04792:  MOVLB  0
04794:  CALL   16DC
....................  
....................       //SF_Data_Addres++; 
....................       delay_ms(10); 
04798:  MOVLW  0A
0479A:  MOVLB  C
0479C:  MOVWF  x86
0479E:  MOVLB  0
047A0:  CALL   0EE2
....................       i++; 
047A4:  MOVLW  01
047A6:  MOVLB  4
047A8:  ADDWF  x80,F
047AA:  BTFSC  FD8.0
047AC:  INCF   x81,F
047AE:  BTFSC  FD8.2
047B0:  INCF   x82,F
047B2:  BTFSC  FD8.2
047B4:  INCF   x83,F
047B6:  BRA    4706
047B8:  MOVLB  C
....................    } 
....................    WRITE_DATA_BYTE4(SF_Data_Addres++,info_end_SFward[0]);delay_ms(10); 
047BA:  MOVLB  6
047BC:  MOVFF  666,03
047C0:  MOVFF  665,02
047C4:  MOVFF  664,01
047C8:  MOVFF  663,00
047CC:  MOVLW  01
047CE:  ADDWF  x63,F
047D0:  BTFSC  FD8.0
047D2:  INCF   x64,F
047D4:  BTFSC  FD8.2
047D6:  INCF   x65,F
047D8:  BTFSC  FD8.2
047DA:  INCF   x66,F
047DC:  MOVFF  03,C58
047E0:  MOVFF  02,C57
047E4:  MOVFF  01,C56
047E8:  MOVFF  00,C55
047EC:  MOVFF  03,C71
047F0:  MOVFF  02,C70
047F4:  MOVFF  01,C6F
047F8:  MOVFF  00,C6E
047FC:  MOVFF  4F2,C72
04800:  MOVLB  0
04802:  CALL   16DC
04806:  MOVLW  0A
04808:  MOVLB  C
0480A:  MOVWF  x86
0480C:  MOVLB  0
0480E:  CALL   0EE2
....................    WRITE_DATA_BYTE4(SF_Data_Addres++,info_end_SFward[1]);delay_ms(10); 
04812:  MOVLB  6
04814:  MOVFF  666,03
04818:  MOVFF  665,02
0481C:  MOVFF  664,01
04820:  MOVFF  663,00
04824:  MOVLW  01
04826:  ADDWF  x63,F
04828:  BTFSC  FD8.0
0482A:  INCF   x64,F
0482C:  BTFSC  FD8.2
0482E:  INCF   x65,F
04830:  BTFSC  FD8.2
04832:  INCF   x66,F
04834:  MOVFF  03,C58
04838:  MOVFF  02,C57
0483C:  MOVFF  01,C56
04840:  MOVFF  00,C55
04844:  MOVFF  03,C71
04848:  MOVFF  02,C70
0484C:  MOVFF  01,C6F
04850:  MOVFF  00,C6E
04854:  MOVFF  4F3,C72
04858:  MOVLB  0
0485A:  CALL   16DC
0485E:  MOVLW  0A
04860:  MOVLB  C
04862:  MOVWF  x86
04864:  MOVLB  0
04866:  CALL   0EE2
....................    fprintf(debugPort,"Done writing SF_Data from address %X%X%X%X \r\n ",first_adsress[0],first_adsress[1],first_adsress[2],first_adsress[3]); 
0486A:  MOVLW  DE
0486C:  MOVWF  FF6
0486E:  MOVLW  09
04870:  MOVWF  FF7
04872:  MOVLW  00
04874:  MOVWF  FF8
04876:  CLRF   1B
04878:  BTFSC  FF2.7
0487A:  BSF    1B.7
0487C:  BCF    FF2.7
0487E:  MOVLW  22
04880:  MOVLB  C
04882:  MOVWF  x9A
04884:  MOVLB  0
04886:  CALL   05B8
0488A:  BTFSC  1B.7
0488C:  BSF    FF2.7
0488E:  CLRF   1B
04890:  BTFSC  FF2.7
04892:  BSF    1B.7
04894:  BCF    FF2.7
04896:  MOVFF  667,C9A
0489A:  MOVLW  37
0489C:  MOVLB  C
0489E:  MOVWF  x9B
048A0:  MOVLB  0
048A2:  CALL   05E8
048A6:  BTFSC  1B.7
048A8:  BSF    FF2.7
048AA:  CLRF   1B
048AC:  BTFSC  FF2.7
048AE:  BSF    1B.7
048B0:  BCF    FF2.7
048B2:  MOVFF  668,C9A
048B6:  MOVLW  37
048B8:  MOVLB  C
048BA:  MOVWF  x9B
048BC:  MOVLB  0
048BE:  CALL   05E8
048C2:  BTFSC  1B.7
048C4:  BSF    FF2.7
048C6:  CLRF   1B
048C8:  BTFSC  FF2.7
048CA:  BSF    1B.7
048CC:  BCF    FF2.7
048CE:  MOVFF  669,C9A
048D2:  MOVLW  37
048D4:  MOVLB  C
048D6:  MOVWF  x9B
048D8:  MOVLB  0
048DA:  CALL   05E8
048DE:  BTFSC  1B.7
048E0:  BSF    FF2.7
048E2:  CLRF   1B
048E4:  BTFSC  FF2.7
048E6:  BSF    1B.7
048E8:  BCF    FF2.7
048EA:  MOVFF  66A,C9A
048EE:  MOVLW  37
048F0:  MOVLB  C
048F2:  MOVWF  x9B
048F4:  MOVLB  0
048F6:  CALL   05E8
048FA:  BTFSC  1B.7
048FC:  BSF    FF2.7
048FE:  MOVLW  08
04900:  MOVWF  FF6
04902:  MOVLW  0A
04904:  MOVWF  FF7
04906:  MOVLW  00
04908:  MOVWF  FF8
0490A:  CLRF   1B
0490C:  BTFSC  FF2.7
0490E:  BSF    1B.7
04910:  BCF    FF2.7
04912:  MOVLW  04
04914:  MOVLB  C
04916:  MOVWF  x9A
04918:  MOVLB  0
0491A:  CALL   05B8
0491E:  BTFSC  1B.7
04920:  BSF    FF2.7
....................  
....................    SUBSECTOR_4KB_ERASE4(SF_Data_Addres_pointer); 
04922:  MOVLB  C
04924:  CLRF   x6C
04926:  MOVLW  01
04928:  MOVWF  x6B
0492A:  CLRF   x6A
0492C:  CLRF   x69
0492E:  MOVLB  0
04930:  CALL   0FF4
....................    after_last_adsress[0]  = (unsigned int8)((SF_Data_Addres>>24) & 0xFF); 
04934:  MOVLB  C
04936:  MOVFF  666,66B
....................    after_last_adsress[1]  = (unsigned int8)((SF_Data_Addres>>16) & 0xFF); 
0493A:  MOVFF  665,66C
....................    after_last_adsress[2]  = (unsigned int8)((SF_Data_Addres>>8 ) & 0xFF); 
0493E:  MOVFF  664,66D
....................    after_last_adsress[3]  = (unsigned int8)((SF_Data_Addres    ) & 0xFF);  
04942:  MOVLB  6
04944:  MOVFF  663,66E
....................    //fprintf(debugPort,"Untill address %X%X%X%X -1 \r\n\r\n ",after_last_adsress[0],after_last_adsress[1],after_last_adsress[2],after_last_adsress[3]); 
....................    fprintf(debugPort,"Untill address %lX \r\n\r\n ",SF_Data_Addres-1); 
04948:  MOVLW  01
0494A:  SUBWF  x63,W
0494C:  MOVLB  C
0494E:  MOVWF  x55
04950:  MOVLW  00
04952:  MOVLB  6
04954:  SUBWFB x64,W
04956:  MOVLB  C
04958:  MOVWF  x56
0495A:  MOVLW  00
0495C:  MOVLB  6
0495E:  SUBWFB x65,W
04960:  MOVLB  C
04962:  MOVWF  x57
04964:  MOVLW  00
04966:  MOVLB  6
04968:  SUBWFB x66,W
0496A:  MOVLB  C
0496C:  MOVWF  x58
0496E:  MOVLW  0E
04970:  MOVWF  FF6
04972:  MOVLW  0A
04974:  MOVWF  FF7
04976:  MOVLW  00
04978:  MOVWF  FF8
0497A:  CLRF   1B
0497C:  BTFSC  FF2.7
0497E:  BSF    1B.7
04980:  BCF    FF2.7
04982:  MOVLW  0F
04984:  MOVWF  x9A
04986:  MOVLB  0
04988:  CALL   05B8
0498C:  BTFSC  1B.7
0498E:  BSF    FF2.7
04990:  CLRF   1B
04992:  BTFSC  FF2.7
04994:  BSF    1B.7
04996:  BCF    FF2.7
04998:  MOVFF  C58,C9A
0499C:  MOVLW  37
0499E:  MOVLB  C
049A0:  MOVWF  x9B
049A2:  MOVLB  0
049A4:  CALL   05E8
049A8:  BTFSC  1B.7
049AA:  BSF    FF2.7
049AC:  CLRF   1B
049AE:  BTFSC  FF2.7
049B0:  BSF    1B.7
049B2:  BCF    FF2.7
049B4:  MOVFF  C57,C9A
049B8:  MOVLW  37
049BA:  MOVLB  C
049BC:  MOVWF  x9B
049BE:  MOVLB  0
049C0:  CALL   05E8
049C4:  BTFSC  1B.7
049C6:  BSF    FF2.7
049C8:  CLRF   1B
049CA:  BTFSC  FF2.7
049CC:  BSF    1B.7
049CE:  BCF    FF2.7
049D0:  MOVFF  C56,C9A
049D4:  MOVLW  37
049D6:  MOVLB  C
049D8:  MOVWF  x9B
049DA:  MOVLB  0
049DC:  CALL   05E8
049E0:  BTFSC  1B.7
049E2:  BSF    FF2.7
049E4:  CLRF   1B
049E6:  BTFSC  FF2.7
049E8:  BSF    1B.7
049EA:  BCF    FF2.7
049EC:  MOVFF  C55,C9A
049F0:  MOVLW  37
049F2:  MOVLB  C
049F4:  MOVWF  x9B
049F6:  MOVLB  0
049F8:  CALL   05E8
049FC:  BTFSC  1B.7
049FE:  BSF    FF2.7
04A00:  MOVLW  20
04A02:  MOVWF  FF6
04A04:  MOVLW  0A
04A06:  MOVWF  FF7
04A08:  MOVLW  00
04A0A:  MOVWF  FF8
04A0C:  CLRF   1B
04A0E:  BTFSC  FF2.7
04A10:  BSF    1B.7
04A12:  BCF    FF2.7
04A14:  MOVLW  06
04A16:  MOVLB  C
04A18:  MOVWF  x9A
04A1A:  MOVLB  0
04A1C:  CALL   05B8
04A20:  BTFSC  1B.7
04A22:  BSF    FF2.7
....................  
....................  
....................    WRITE_DATA_BYTE4(SF_Data_Addres_pointer  ,after_last_adsress[0]); 
04A24:  MOVLB  C
04A26:  CLRF   x71
04A28:  MOVLW  01
04A2A:  MOVWF  x70
04A2C:  CLRF   x6F
04A2E:  CLRF   x6E
04A30:  MOVFF  66B,C72
04A34:  MOVLB  0
04A36:  CALL   16DC
....................    WRITE_DATA_BYTE4(SF_Data_Addres_pointer+1,after_last_adsress[1]); 
04A3A:  MOVLB  C
04A3C:  CLRF   x71
04A3E:  MOVLW  01
04A40:  MOVWF  x70
04A42:  CLRF   x6F
04A44:  MOVWF  x6E
04A46:  MOVFF  66C,C72
04A4A:  MOVLB  0
04A4C:  CALL   16DC
....................    WRITE_DATA_BYTE4(SF_Data_Addres_pointer+2,after_last_adsress[2]); 
04A50:  MOVLB  C
04A52:  CLRF   x71
04A54:  MOVLW  01
04A56:  MOVWF  x70
04A58:  CLRF   x6F
04A5A:  MOVLW  02
04A5C:  MOVWF  x6E
04A5E:  MOVFF  66D,C72
04A62:  MOVLB  0
04A64:  CALL   16DC
....................    WRITE_DATA_BYTE4(SF_Data_Addres_pointer+3,after_last_adsress[3]); 
04A68:  MOVLB  C
04A6A:  CLRF   x71
04A6C:  MOVLW  01
04A6E:  MOVWF  x70
04A70:  CLRF   x6F
04A72:  MOVLW  03
04A74:  MOVWF  x6E
04A76:  MOVFF  66E,C72
04A7A:  MOVLB  0
04A7C:  CALL   16DC
....................     
....................    fprintf(debugPort,"FINISHED WRITING\r\n "); 
04A80:  MOVLW  28
04A82:  MOVWF  FF6
04A84:  MOVLW  0A
04A86:  MOVWF  FF7
04A88:  MOVLW  00
04A8A:  MOVWF  FF8
04A8C:  CLRF   1B
04A8E:  BTFSC  FF2.7
04A90:  BSF    1B.7
04A92:  BCF    FF2.7
04A94:  CALL   0590
04A98:  BTFSC  1B.7
04A9A:  BSF    FF2.7
04A9C:  GOTO   6A1E (RETURN)
....................  
.................... } 
....................  
.................... void save_rcved_data_in_FM(int8 *SF_data, int16 size) 
.................... { 
....................    fprintf(debugPort,"\r\nSaving APRS data\r\n"); 
04AA0:  MOVLW  3C
04AA2:  MOVWF  FF6
04AA4:  MOVLW  0A
04AA6:  MOVWF  FF7
04AA8:  MOVLW  00
04AAA:  MOVWF  FF8
04AAC:  CLRF   1B
04AAE:  BTFSC  FF2.7
04AB0:  BSF    1B.7
04AB2:  BCF    FF2.7
04AB4:  CALL   0590
04AB8:  BTFSC  1B.7
04ABA:  BSF    FF2.7
....................    //SUBSECTOR_4KB_ERASE4(rcved_data_adrs_pointer); 
....................    //SUBSECTOR_4KB_ERASE4(rcved_data_in_FM); 
....................    rcved_data_adrs=make32(READ_DATA_BYTE4(rcved_data_adrs_pointer),READ_DATA_BYTE4(rcved_data_adrs_pointer+1),READ_DATA_BYTE4(rcved_data_adrs_pointer+2),READ_DATA_BYTE4(rcved_data_adrs_pointer+3)); 
04ABC:  MOVLW  05
04ABE:  MOVLB  C
04AC0:  MOVWF  x6D
04AC2:  MOVLW  FE
04AC4:  MOVWF  x6C
04AC6:  MOVLW  F0
04AC8:  MOVWF  x6B
04ACA:  CLRF   x6A
04ACC:  MOVLB  0
04ACE:  CALL   0E60
04AD2:  MOVFF  01,C57
04AD6:  MOVLW  05
04AD8:  MOVLB  C
04ADA:  MOVWF  x6D
04ADC:  MOVLW  FE
04ADE:  MOVWF  x6C
04AE0:  MOVLW  F0
04AE2:  MOVWF  x6B
04AE4:  MOVLW  01
04AE6:  MOVWF  x6A
04AE8:  MOVLB  0
04AEA:  CALL   0E60
04AEE:  MOVFF  01,C58
04AF2:  MOVLW  05
04AF4:  MOVLB  C
04AF6:  MOVWF  x6D
04AF8:  MOVLW  FE
04AFA:  MOVWF  x6C
04AFC:  MOVLW  F0
04AFE:  MOVWF  x6B
04B00:  MOVLW  02
04B02:  MOVWF  x6A
04B04:  MOVLB  0
04B06:  CALL   0E60
04B0A:  MOVFF  01,C59
04B0E:  MOVLW  05
04B10:  MOVLB  C
04B12:  MOVWF  x6D
04B14:  MOVLW  FE
04B16:  MOVWF  x6C
04B18:  MOVLW  F0
04B1A:  MOVWF  x6B
04B1C:  MOVLW  03
04B1E:  MOVWF  x6A
04B20:  MOVLB  0
04B22:  CALL   0E60
04B26:  MOVFF  C57,47B
04B2A:  MOVFF  C58,47A
04B2E:  MOVFF  C59,479
04B32:  MOVFF  01,478
....................    int32 subsector4kbNo; 
....................     
....................    if ((rcved_data_adrs >= 0x07FFF000 )||(rcved_data_adrs <= rcved_data_in_FM-1 )) 
04B36:  MOVLB  4
04B38:  MOVF   x7B,W
04B3A:  SUBLW  06
04B3C:  BC    4B52
04B3E:  XORLW  FF
04B40:  BNZ   4B60
04B42:  MOVF   x7A,W
04B44:  SUBLW  FE
04B46:  BC    4B52
04B48:  XORLW  FF
04B4A:  BNZ   4B60
04B4C:  MOVF   x79,W
04B4E:  SUBLW  EF
04B50:  BNC   4B60
04B52:  MOVF   x7B,W
04B54:  SUBLW  05
04B56:  BNC   4C44
04B58:  BNZ   4B60
04B5A:  MOVF   x7A,W
04B5C:  SUBLW  FE
04B5E:  BNC   4C44
....................    { 
....................         
....................        fprintf(debugport,"\r\nMemory is full, Erasing now & writing Afresh\r\n"); 
04B60:  MOVLW  52
04B62:  MOVWF  FF6
04B64:  MOVLW  0A
04B66:  MOVWF  FF7
04B68:  MOVLW  00
04B6A:  MOVWF  FF8
04B6C:  CLRF   1B
04B6E:  BTFSC  FF2.7
04B70:  BSF    1B.7
04B72:  BCF    FF2.7
04B74:  MOVLB  0
04B76:  CALL   0590
04B7A:  BTFSC  1B.7
04B7C:  BSF    FF2.7
....................         
....................       SUBSECTOR_4KB_ERASE4(rcved_data_adrs_pointer); 
04B7E:  MOVLW  05
04B80:  MOVLB  C
04B82:  MOVWF  x6C
04B84:  MOVLW  FE
04B86:  MOVWF  x6B
04B88:  MOVLW  F0
04B8A:  MOVWF  x6A
04B8C:  CLRF   x69
04B8E:  MOVLB  0
04B90:  CALL   0FF4
....................       SUBSECTOR_4KB_ERASE4(rcved_data_in_FM); // we need to erase all sectors not the first one only,  
04B94:  MOVLW  05
04B96:  MOVLB  C
04B98:  MOVWF  x6C
04B9A:  SETF   x6B
04B9C:  CLRF   x6A
04B9E:  CLRF   x69
04BA0:  MOVLB  0
04BA2:  CALL   0FF4
....................       rcved_data_adrs=rcved_data_in_FM; 
04BA6:  MOVLW  05
04BA8:  MOVLB  4
04BAA:  MOVWF  x7B
04BAC:  SETF   x7A
04BAE:  CLRF   x79
04BB0:  CLRF   x78
....................       WRITE_DATA_BYTE4(rcved_data_adrs_pointer, rcved_data_adrs>>24); 
04BB2:  MOVFF  47B,C58
04BB6:  MOVLB  C
04BB8:  CLRF   x59
04BBA:  CLRF   x5A
04BBC:  CLRF   x5B
04BBE:  MOVWF  x71
04BC0:  MOVLW  FE
04BC2:  MOVWF  x70
04BC4:  MOVLW  F0
04BC6:  MOVWF  x6F
04BC8:  CLRF   x6E
04BCA:  MOVFF  47B,C72
04BCE:  MOVLB  0
04BD0:  CALL   16DC
....................       WRITE_DATA_BYTE4(rcved_data_adrs_pointer+1,rcved_data_adrs>>16); 
04BD4:  MOVFF  47A,C58
04BD8:  MOVFF  47B,C59
04BDC:  MOVLB  C
04BDE:  CLRF   x5A
04BE0:  CLRF   x5B
04BE2:  MOVLW  05
04BE4:  MOVWF  x71
04BE6:  MOVLW  FE
04BE8:  MOVWF  x70
04BEA:  MOVLW  F0
04BEC:  MOVWF  x6F
04BEE:  MOVLW  01
04BF0:  MOVWF  x6E
04BF2:  MOVFF  47A,C72
04BF6:  MOVLB  0
04BF8:  CALL   16DC
....................       WRITE_DATA_BYTE4(rcved_data_adrs_pointer+2,rcved_data_adrs>>8); 
04BFC:  MOVFF  479,C58
04C00:  MOVFF  47A,C59
04C04:  MOVFF  47B,C5A
04C08:  MOVLB  C
04C0A:  CLRF   x5B
04C0C:  MOVLW  05
04C0E:  MOVWF  x71
04C10:  MOVLW  FE
04C12:  MOVWF  x70
04C14:  MOVLW  F0
04C16:  MOVWF  x6F
04C18:  MOVLW  02
04C1A:  MOVWF  x6E
04C1C:  MOVFF  479,C72
04C20:  MOVLB  0
04C22:  CALL   16DC
....................       WRITE_DATA_BYTE4(rcved_data_adrs_pointer+3,rcved_data_adrs); 
04C26:  MOVLW  05
04C28:  MOVLB  C
04C2A:  MOVWF  x71
04C2C:  MOVLW  FE
04C2E:  MOVWF  x70
04C30:  MOVLW  F0
04C32:  MOVWF  x6F
04C34:  MOVLW  03
04C36:  MOVWF  x6E
04C38:  MOVFF  478,C72
04C3C:  MOVLB  0
04C3E:  CALL   16DC
04C42:  MOVLB  4
....................    } 
....................     
....................    //fprintf(debugport,"data will be written from subsector4kb %lu to subsector4kb %lu\r\n",adrs2subsector4kb(rcved_data_adrs),adrs2subsector4kb(rcved_data_adrs+size)); 
....................    for (subsector4kbNo=adrs2subsector4kb(rcved_data_adrs)+1; subsector4kbNo<=adrs2subsector4kb(rcved_data_adrs+size);subsector4kbNo++) 
04C44:  MOVFF  47B,C5E
04C48:  MOVFF  47A,C5D
04C4C:  MOVFF  479,C5C
04C50:  MOVFF  478,C5B
04C54:  MOVLB  0
04C56:  CALL   42F0
04C5A:  MOVFF  03,C5A
04C5E:  MOVFF  02,C59
04C62:  MOVFF  01,C58
04C66:  MOVFF  00,C57
04C6A:  MOVLW  01
04C6C:  MOVLB  C
04C6E:  ADDWF  00,W
04C70:  MOVWF  x53
04C72:  MOVLW  00
04C74:  ADDWFC 01,W
04C76:  MOVWF  x54
04C78:  MOVLW  00
04C7A:  ADDWFC 02,W
04C7C:  MOVWF  x55
04C7E:  MOVLW  00
04C80:  ADDWFC 03,W
04C82:  MOVWF  x56
04C84:  MOVF   x51,W
04C86:  MOVLB  4
04C88:  ADDWF  x78,W
04C8A:  MOVLB  C
04C8C:  MOVWF  x57
04C8E:  MOVF   x52,W
04C90:  MOVLB  4
04C92:  ADDWFC x79,W
04C94:  MOVLB  C
04C96:  MOVWF  x58
04C98:  MOVLW  00
04C9A:  MOVLB  4
04C9C:  ADDWFC x7A,W
04C9E:  MOVLB  C
04CA0:  MOVWF  x59
04CA2:  MOVLW  00
04CA4:  MOVLB  4
04CA6:  ADDWFC x7B,W
04CA8:  MOVLB  C
04CAA:  MOVWF  x5A
04CAC:  MOVWF  x5E
04CAE:  MOVFF  C59,C5D
04CB2:  MOVFF  C58,C5C
04CB6:  MOVFF  C57,C5B
04CBA:  MOVLB  0
04CBC:  CALL   42F0
04CC0:  MOVLB  C
04CC2:  MOVF   x56,W
04CC4:  SUBWF  03,W
04CC6:  BNC   4D2E
04CC8:  BNZ   4CE0
04CCA:  MOVF   x55,W
04CCC:  SUBWF  02,W
04CCE:  BNC   4D2E
04CD0:  BNZ   4CE0
04CD2:  MOVF   x54,W
04CD4:  SUBWF  01,W
04CD6:  BNC   4D2E
04CD8:  BNZ   4CE0
04CDA:  MOVF   x53,W
04CDC:  SUBWF  00,W
04CDE:  BNC   4D2E
....................    { 
....................       SUBSECTOR_4KB_ERASE4(subsector4kbNo*0x1000); 
04CE0:  CLRF   x57
04CE2:  RLCF   x53,W
04CE4:  MOVWF  x58
04CE6:  RLCF   x54,W
04CE8:  MOVWF  x59
04CEA:  RLCF   x55,W
04CEC:  MOVWF  x5A
04CEE:  RLCF   x58,F
04CF0:  RLCF   x59,F
04CF2:  RLCF   x5A,F
04CF4:  RLCF   x58,F
04CF6:  RLCF   x59,F
04CF8:  RLCF   x5A,F
04CFA:  RLCF   x58,F
04CFC:  RLCF   x59,F
04CFE:  RLCF   x5A,F
04D00:  MOVLW  F0
04D02:  ANDWF  x58,F
04D04:  MOVFF  C5A,C6C
04D08:  MOVFF  C59,C6B
04D0C:  MOVFF  C58,C6A
04D10:  MOVFF  C57,C69
04D14:  MOVLB  0
04D16:  CALL   0FF4
04D1A:  MOVLW  01
04D1C:  MOVLB  C
04D1E:  ADDWF  x53,F
04D20:  BTFSC  FD8.0
04D22:  INCF   x54,F
04D24:  BTFSC  FD8.2
04D26:  INCF   x55,F
04D28:  BTFSC  FD8.2
04D2A:  INCF   x56,F
04D2C:  BRA    4C84
....................    } 
....................     
....................    fprintf(debugport,"\r\nAppending Memory\r\n"); 
04D2E:  MOVLW  84
04D30:  MOVWF  FF6
04D32:  MOVLW  0A
04D34:  MOVWF  FF7
04D36:  MOVLW  00
04D38:  MOVWF  FF8
04D3A:  CLRF   1B
04D3C:  BTFSC  FF2.7
04D3E:  BSF    1B.7
04D40:  BCF    FF2.7
04D42:  MOVLB  0
04D44:  CALL   0590
04D48:  BTFSC  1B.7
04D4A:  BSF    FF2.7
04D4C:  CLRF   1B
04D4E:  BTFSC  FF2.7
04D50:  BSF    1B.7
04D52:  BCF    FF2.7
....................    fprintf(debugPort, "%lX", rcved_data_adrs); 
04D54:  MOVFF  47B,C9A
04D58:  MOVLW  37
04D5A:  MOVLB  C
04D5C:  MOVWF  x9B
04D5E:  MOVLB  0
04D60:  CALL   05E8
04D64:  BTFSC  1B.7
04D66:  BSF    FF2.7
04D68:  CLRF   1B
04D6A:  BTFSC  FF2.7
04D6C:  BSF    1B.7
04D6E:  BCF    FF2.7
04D70:  MOVFF  47A,C9A
04D74:  MOVLW  37
04D76:  MOVLB  C
04D78:  MOVWF  x9B
04D7A:  MOVLB  0
04D7C:  CALL   05E8
04D80:  BTFSC  1B.7
04D82:  BSF    FF2.7
04D84:  CLRF   1B
04D86:  BTFSC  FF2.7
04D88:  BSF    1B.7
04D8A:  BCF    FF2.7
04D8C:  MOVFF  479,C9A
04D90:  MOVLW  37
04D92:  MOVLB  C
04D94:  MOVWF  x9B
04D96:  MOVLB  0
04D98:  CALL   05E8
04D9C:  BTFSC  1B.7
04D9E:  BSF    FF2.7
04DA0:  CLRF   1B
04DA2:  BTFSC  FF2.7
04DA4:  BSF    1B.7
04DA6:  BCF    FF2.7
04DA8:  MOVFF  478,C9A
04DAC:  MOVLW  37
04DAE:  MOVLB  C
04DB0:  MOVWF  x9B
04DB2:  MOVLB  0
04DB4:  CALL   05E8
04DB8:  BTFSC  1B.7
04DBA:  BSF    FF2.7
04DBC:  CLRF   1B
04DBE:  BTFSC  FF2.7
04DC0:  BSF    1B.7
04DC2:  BCF    FF2.7
....................    fprintf(debugport,"\r\n"); 
04DC4:  MOVLW  0D
04DC6:  MOVLB  C
04DC8:  MOVWF  x9E
04DCA:  MOVLB  0
04DCC:  CALL   054A
04DD0:  BTFSC  1B.7
04DD2:  BSF    FF2.7
04DD4:  CLRF   1B
04DD6:  BTFSC  FF2.7
04DD8:  BSF    1B.7
04DDA:  BCF    FF2.7
04DDC:  MOVLW  0A
04DDE:  MOVLB  C
04DE0:  MOVWF  x9E
04DE2:  MOVLB  0
04DE4:  CALL   054A
04DE8:  BTFSC  1B.7
04DEA:  BSF    FF2.7
....................    MyAdress = rcved_data_adrs; 
04DEC:  MOVFF  47B,47F
04DF0:  MOVFF  47A,47E
04DF4:  MOVFF  479,47D
04DF8:  MOVFF  478,47C
....................     
....................     
....................    rcved_data_adrs=WRITE_DATA_N_BYTE4(rcved_data_adrs,size,SF_data); 
04DFC:  MOVFF  47B,C6C
04E00:  MOVFF  47A,C6B
04E04:  MOVFF  479,C6A
04E08:  MOVFF  478,C69
04E0C:  MOVLB  C
04E0E:  CLRF   x70
04E10:  CLRF   x6F
04E12:  MOVFF  C52,C6E
04E16:  MOVFF  C51,C6D
04E1A:  MOVFF  C50,C72
04E1E:  MOVFF  C4F,C71
04E22:  MOVLB  0
04E24:  CALL   1158
04E28:  MOVFF  03,47B
04E2C:  MOVFF  02,47A
04E30:  MOVFF  01,479
04E34:  MOVFF  00,478
....................     
....................    SUBSECTOR_4KB_ERASE4(rcved_data_adrs_pointer); 
04E38:  MOVLW  05
04E3A:  MOVLB  C
04E3C:  MOVWF  x6C
04E3E:  MOVLW  FE
04E40:  MOVWF  x6B
04E42:  MOVLW  F0
04E44:  MOVWF  x6A
04E46:  CLRF   x69
04E48:  MOVLB  0
04E4A:  CALL   0FF4
....................    WRITE_DATA_BYTE4(rcved_data_adrs_pointer,  rcved_data_adrs>>24); 
04E4E:  MOVFF  47B,C58
04E52:  MOVLB  C
04E54:  CLRF   x59
04E56:  CLRF   x5A
04E58:  CLRF   x5B
04E5A:  MOVLW  05
04E5C:  MOVWF  x71
04E5E:  MOVLW  FE
04E60:  MOVWF  x70
04E62:  MOVLW  F0
04E64:  MOVWF  x6F
04E66:  CLRF   x6E
04E68:  MOVFF  47B,C72
04E6C:  MOVLB  0
04E6E:  CALL   16DC
....................    WRITE_DATA_BYTE4(rcved_data_adrs_pointer+1,rcved_data_adrs>>16); 
04E72:  MOVFF  47A,C58
04E76:  MOVFF  47B,C59
04E7A:  MOVLB  C
04E7C:  CLRF   x5A
04E7E:  CLRF   x5B
04E80:  MOVLW  05
04E82:  MOVWF  x71
04E84:  MOVLW  FE
04E86:  MOVWF  x70
04E88:  MOVLW  F0
04E8A:  MOVWF  x6F
04E8C:  MOVLW  01
04E8E:  MOVWF  x6E
04E90:  MOVFF  47A,C72
04E94:  MOVLB  0
04E96:  CALL   16DC
....................    WRITE_DATA_BYTE4(rcved_data_adrs_pointer+2,rcved_data_adrs>>8); 
04E9A:  MOVFF  479,C58
04E9E:  MOVFF  47A,C59
04EA2:  MOVFF  47B,C5A
04EA6:  MOVLB  C
04EA8:  CLRF   x5B
04EAA:  MOVLW  05
04EAC:  MOVWF  x71
04EAE:  MOVLW  FE
04EB0:  MOVWF  x70
04EB2:  MOVLW  F0
04EB4:  MOVWF  x6F
04EB6:  MOVLW  02
04EB8:  MOVWF  x6E
04EBA:  MOVFF  479,C72
04EBE:  MOVLB  0
04EC0:  CALL   16DC
....................    WRITE_DATA_BYTE4(rcved_data_adrs_pointer+3,rcved_data_adrs); 
04EC4:  MOVLW  05
04EC6:  MOVLB  C
04EC8:  MOVWF  x71
04ECA:  MOVLW  FE
04ECC:  MOVWF  x70
04ECE:  MOVLW  F0
04ED0:  MOVWF  x6F
04ED2:  MOVLW  03
04ED4:  MOVWF  x6E
04ED6:  MOVFF  478,C72
04EDA:  MOVLB  0
04EDC:  CALL   16DC
04EE0:  GOTO   6A56 (RETURN)
.................... } 
....................  
.................... void reset_SFward_FM_data(void) 
.................... { 
....................       SUBSECTOR_4KB_ERASE4(SF_Data_Addres_pointer); 
*
01A5C:  MOVLB  C
01A5E:  CLRF   x6C
01A60:  MOVLW  01
01A62:  MOVWF  x6B
01A64:  CLRF   x6A
01A66:  CLRF   x69
01A68:  MOVLB  0
01A6A:  CALL   0FF4
....................       SUBSECTOR_4KB_ERASE4(SF_Data_start_Adrs); 
01A6E:  MOVLB  C
01A70:  CLRF   x6C
01A72:  MOVLW  01
01A74:  MOVWF  x6B
01A76:  MOVLW  10
01A78:  MOVWF  x6A
01A7A:  CLRF   x69
01A7C:  MOVLB  0
01A7E:  CALL   0FF4
....................        
....................       WRITE_DATA_BYTE4(SF_Data_Addres_pointer  ,SF_Data_start_Adrs>>24); 
01A82:  MOVLB  C
01A84:  CLRF   x71
01A86:  MOVLW  01
01A88:  MOVWF  x70
01A8A:  CLRF   x6F
01A8C:  CLRF   x6E
01A8E:  CLRF   x72
01A90:  MOVLB  0
01A92:  RCALL  16DC
....................       WRITE_DATA_BYTE4(SF_Data_Addres_pointer+1,SF_Data_start_Adrs>>16); 
01A94:  MOVLB  C
01A96:  CLRF   x71
01A98:  MOVLW  01
01A9A:  MOVWF  x70
01A9C:  CLRF   x6F
01A9E:  MOVWF  x6E
01AA0:  MOVWF  x72
01AA2:  MOVLB  0
01AA4:  RCALL  16DC
....................       WRITE_DATA_BYTE4(SF_Data_Addres_pointer+2,SF_Data_start_Adrs>>8); 
01AA6:  MOVLB  C
01AA8:  CLRF   x71
01AAA:  MOVLW  01
01AAC:  MOVWF  x70
01AAE:  CLRF   x6F
01AB0:  MOVLW  02
01AB2:  MOVWF  x6E
01AB4:  MOVLW  10
01AB6:  MOVWF  x72
01AB8:  MOVLB  0
01ABA:  RCALL  16DC
....................       WRITE_DATA_BYTE4(SF_Data_Addres_pointer+3,SF_Data_start_Adrs); 
01ABC:  MOVLB  C
01ABE:  CLRF   x71
01AC0:  MOVLW  01
01AC2:  MOVWF  x70
01AC4:  CLRF   x6F
01AC6:  MOVLW  03
01AC8:  MOVWF  x6E
01ACA:  CLRF   x72
01ACC:  MOVLB  0
01ACE:  RCALL  16DC
....................       fprintf(debugPort,"saving address and memory for SFward data are reset \r\n"); 
01AD0:  MOVLW  9A
01AD2:  MOVWF  FF6
01AD4:  MOVLW  0A
01AD6:  MOVWF  FF7
01AD8:  MOVLW  00
01ADA:  MOVWF  FF8
01ADC:  CLRF   1B
01ADE:  BTFSC  FF2.7
01AE0:  BSF    1B.7
01AE2:  BCF    FF2.7
01AE4:  CALL   0590
01AE8:  BTFSC  1B.7
01AEA:  BSF    FF2.7
....................       show_FM_data(); 
01AEC:  RCALL  1802
01AEE:  RETURN 0
.................... } 
....................  
.................... void reset_all(void) 
.................... { 
....................       fprintf(debugPort,"Major reset is \r\n"); 
*
0577A:  MOVLW  D2
0577C:  MOVWF  FF6
0577E:  MOVLW  0A
05780:  MOVWF  FF7
05782:  MOVLW  00
05784:  MOVWF  FF8
05786:  CLRF   1B
05788:  BTFSC  FF2.7
0578A:  BSF    1B.7
0578C:  BCF    FF2.7
0578E:  CALL   0590
05792:  BTFSC  1B.7
05794:  BSF    FF2.7
....................       //die_erase_command(); 
....................       //erase_sectors(1535,2017); 
....................       //erase_sectors(0,4); 
....................  
....................       SUBSECTOR_4KB_ERASE4(0); 
05796:  MOVLB  C
05798:  CLRF   x6C
0579A:  CLRF   x6B
0579C:  CLRF   x6A
0579E:  CLRF   x69
057A0:  MOVLB  0
057A2:  CALL   0FF4
....................       prepare_DummyData(3); 
057A6:  MOVLB  C
057A8:  CLRF   x52
057AA:  CLRF   x51
057AC:  CLRF   x50
057AE:  MOVLW  03
057B0:  MOVWF  x4F
057B2:  MOVLB  0
057B4:  BRA    56BA
....................        
....................       SUBSECTOR_4KB_ERASE4(satellite_info_pointer); 
057B6:  MOVLB  C
057B8:  CLRF   x6C
057BA:  CLRF   x6B
057BC:  MOVLW  20
057BE:  MOVWF  x6A
057C0:  CLRF   x69
057C2:  MOVLB  0
057C4:  CALL   0FF4
....................       write_satellite_info(); 
057C8:  CALL   168C
....................  
....................       SUBSECTOR_4KB_ERASE4(log_array_SFward_in_FM); 
057CC:  MOVLB  C
057CE:  CLRF   x6C
057D0:  CLRF   x6B
057D2:  MOVLW  60
057D4:  MOVWF  x6A
057D6:  CLRF   x69
057D8:  MOVLB  0
057DA:  CALL   0FF4
....................       SUBSECTOR_4KB_ERASE4(log_array_SFward_adrs_pointer); 
057DE:  MOVLB  C
057E0:  CLRF   x6C
057E2:  CLRF   x6B
057E4:  MOVLW  70
057E6:  MOVWF  x6A
057E8:  CLRF   x69
057EA:  MOVLB  0
057EC:  CALL   0FF4
....................       WRITE_DATA_BYTE4(log_array_SFward_adrs_pointer  ,log_array_SFward_in_FM>>24); 
057F0:  MOVLB  C
057F2:  CLRF   x71
057F4:  CLRF   x70
057F6:  MOVLW  70
057F8:  MOVWF  x6F
057FA:  CLRF   x6E
057FC:  CLRF   x72
057FE:  MOVLB  0
05800:  CALL   16DC
....................       WRITE_DATA_BYTE4(log_array_SFward_adrs_pointer+1,log_array_SFward_in_FM>>16); 
05804:  MOVLB  C
05806:  CLRF   x71
05808:  CLRF   x70
0580A:  MOVLW  70
0580C:  MOVWF  x6F
0580E:  MOVLW  01
05810:  MOVWF  x6E
05812:  CLRF   x72
05814:  MOVLB  0
05816:  CALL   16DC
....................       WRITE_DATA_BYTE4(log_array_SFward_adrs_pointer+2,log_array_SFward_in_FM>>8); 
0581A:  MOVLB  C
0581C:  CLRF   x71
0581E:  CLRF   x70
05820:  MOVLW  70
05822:  MOVWF  x6F
05824:  MOVLW  02
05826:  MOVWF  x6E
05828:  MOVLW  60
0582A:  MOVWF  x72
0582C:  MOVLB  0
0582E:  CALL   16DC
....................       WRITE_DATA_BYTE4(log_array_SFward_adrs_pointer+3,log_array_SFward_in_FM); 
05832:  MOVLB  C
05834:  CLRF   x71
05836:  CLRF   x70
05838:  MOVLW  70
0583A:  MOVWF  x6F
0583C:  MOVLW  03
0583E:  MOVWF  x6E
05840:  CLRF   x72
05842:  MOVLB  0
05844:  CALL   16DC
....................  
....................       SUBSECTOR_4KB_ERASE4(SF_Data_start_Adrs); 
05848:  MOVLB  C
0584A:  CLRF   x6C
0584C:  MOVLW  01
0584E:  MOVWF  x6B
05850:  MOVLW  10
05852:  MOVWF  x6A
05854:  CLRF   x69
05856:  MOVLB  0
05858:  CALL   0FF4
....................       SUBSECTOR_4KB_ERASE4(SF_Data_Addres_pointer); 
0585C:  MOVLB  C
0585E:  CLRF   x6C
05860:  MOVLW  01
05862:  MOVWF  x6B
05864:  CLRF   x6A
05866:  CLRF   x69
05868:  MOVLB  0
0586A:  CALL   0FF4
....................       WRITE_DATA_BYTE4(SF_Data_Addres_pointer  ,SF_Data_start_Adrs>>24); 
0586E:  MOVLB  C
05870:  CLRF   x71
05872:  MOVLW  01
05874:  MOVWF  x70
05876:  CLRF   x6F
05878:  CLRF   x6E
0587A:  CLRF   x72
0587C:  MOVLB  0
0587E:  CALL   16DC
....................       WRITE_DATA_BYTE4(SF_Data_Addres_pointer+1,SF_Data_start_Adrs>>16); 
05882:  MOVLB  C
05884:  CLRF   x71
05886:  MOVLW  01
05888:  MOVWF  x70
0588A:  CLRF   x6F
0588C:  MOVWF  x6E
0588E:  MOVWF  x72
05890:  MOVLB  0
05892:  CALL   16DC
....................       WRITE_DATA_BYTE4(SF_Data_Addres_pointer+2,SF_Data_start_Adrs>>8); 
05896:  MOVLB  C
05898:  CLRF   x71
0589A:  MOVLW  01
0589C:  MOVWF  x70
0589E:  CLRF   x6F
058A0:  MOVLW  02
058A2:  MOVWF  x6E
058A4:  MOVLW  10
058A6:  MOVWF  x72
058A8:  MOVLB  0
058AA:  CALL   16DC
....................       WRITE_DATA_BYTE4(SF_Data_Addres_pointer+3,SF_Data_start_Adrs); 
058AE:  MOVLB  C
058B0:  CLRF   x71
058B2:  MOVLW  01
058B4:  MOVWF  x70
058B6:  CLRF   x6F
058B8:  MOVLW  03
058BA:  MOVWF  x6E
058BC:  CLRF   x72
058BE:  MOVLB  0
058C0:  CALL   16DC
....................        
....................       SUBSECTOR_4KB_ERASE4(rcved_data_in_FM); 
058C4:  MOVLW  05
058C6:  MOVLB  C
058C8:  MOVWF  x6C
058CA:  SETF   x6B
058CC:  CLRF   x6A
058CE:  CLRF   x69
058D0:  MOVLB  0
058D2:  CALL   0FF4
....................       SUBSECTOR_4KB_ERASE4(rcved_data_adrs_pointer); 
058D6:  MOVLW  05
058D8:  MOVLB  C
058DA:  MOVWF  x6C
058DC:  MOVLW  FE
058DE:  MOVWF  x6B
058E0:  MOVLW  F0
058E2:  MOVWF  x6A
058E4:  CLRF   x69
058E6:  MOVLB  0
058E8:  CALL   0FF4
....................       WRITE_DATA_BYTE4(rcved_data_adrs_pointer, rcved_data_in_FM>>24); 
058EC:  MOVLW  05
058EE:  MOVLB  C
058F0:  MOVWF  x71
058F2:  MOVLW  FE
058F4:  MOVWF  x70
058F6:  MOVLW  F0
058F8:  MOVWF  x6F
058FA:  CLRF   x6E
058FC:  MOVLW  05
058FE:  MOVWF  x72
05900:  MOVLB  0
05902:  CALL   16DC
....................       WRITE_DATA_BYTE4(rcved_data_adrs_pointer+1,rcved_data_in_FM>>16); 
05906:  MOVLW  05
05908:  MOVLB  C
0590A:  MOVWF  x71
0590C:  MOVLW  FE
0590E:  MOVWF  x70
05910:  MOVLW  F0
05912:  MOVWF  x6F
05914:  MOVLW  01
05916:  MOVWF  x6E
05918:  SETF   x72
0591A:  MOVLB  0
0591C:  CALL   16DC
....................       WRITE_DATA_BYTE4(rcved_data_adrs_pointer+2,rcved_data_in_FM>>8); 
05920:  MOVLW  05
05922:  MOVLB  C
05924:  MOVWF  x71
05926:  MOVLW  FE
05928:  MOVWF  x70
0592A:  MOVLW  F0
0592C:  MOVWF  x6F
0592E:  MOVLW  02
05930:  MOVWF  x6E
05932:  CLRF   x72
05934:  MOVLB  0
05936:  CALL   16DC
....................       WRITE_DATA_BYTE4(rcved_data_adrs_pointer+3,rcved_data_in_FM); 
0593A:  MOVLW  05
0593C:  MOVLB  C
0593E:  MOVWF  x71
05940:  MOVLW  FE
05942:  MOVWF  x70
05944:  MOVLW  F0
05946:  MOVWF  x6F
05948:  MOVLW  03
0594A:  MOVWF  x6E
0594C:  CLRF   x72
0594E:  MOVLB  0
05950:  CALL   16DC
....................        
....................       fprintf(debugPort,"Major reset is finished \r\n"); 
05954:  MOVLW  E4
05956:  MOVWF  FF6
05958:  MOVLW  0A
0595A:  MOVWF  FF7
0595C:  MOVLW  00
0595E:  MOVWF  FF8
05960:  CLRF   1B
05962:  BTFSC  FF2.7
05964:  BSF    1B.7
05966:  BCF    FF2.7
05968:  CALL   0590
0596C:  BTFSC  1B.7
0596E:  BSF    FF2.7
05970:  GOTO   6E20 (RETURN)
.................... } 
....................  
.................... void settings(void){ 
....................  
.................... fprintf(debugPort,"\r\n\r\n"); 
*
01AF0:  MOVLW  00
01AF2:  MOVWF  FF6
01AF4:  MOVLW  0B
01AF6:  MOVWF  FF7
01AF8:  MOVLW  00
01AFA:  MOVWF  FF8
01AFC:  CLRF   1B
01AFE:  BTFSC  FF2.7
01B00:  BSF    1B.7
01B02:  BCF    FF2.7
01B04:  CALL   0590
01B08:  BTFSC  1B.7
01B0A:  BSF    FF2.7
.................... fprintf(debugPort," Birds5 SFward Program Started v2\r\n"); 
01B0C:  MOVLW  06
01B0E:  MOVWF  FF6
01B10:  MOVLW  0B
01B12:  MOVWF  FF7
01B14:  MOVLW  00
01B16:  MOVWF  FF8
01B18:  CLRF   1B
01B1A:  BTFSC  FF2.7
01B1C:  BSF    1B.7
01B1E:  BCF    FF2.7
01B20:  CALL   0590
01B24:  BTFSC  1B.7
01B26:  BSF    FF2.7
.................... output_high(PIN_B2); // enable APRS 
01B28:  BCF    F93.2
01B2A:  BSF    F8A.2
.................... fprintf(debugPort,"APRS_DP Enabled\r\n"); 
01B2C:  MOVLW  2A
01B2E:  MOVWF  FF6
01B30:  MOVLW  0B
01B32:  MOVWF  FF7
01B34:  MOVLW  00
01B36:  MOVWF  FF8
01B38:  CLRF   1B
01B3A:  BTFSC  FF2.7
01B3C:  BSF    1B.7
01B3E:  BCF    FF2.7
01B40:  CALL   0590
01B44:  BTFSC  1B.7
01B46:  BSF    FF2.7
.................... ENABLE_4BYTES_ADDRESS(); 
01B48:  GOTO   0E3A
.................... //MyAdress = rcved_data_adrs; 
.................... fprintf(debugPort,"Writing to SFwardFM will start from address %X%X%X%X\r\n",READ_DATA_BYTE4(SF_Data_Addres_pointer),READ_DATA_BYTE4(SF_Data_Addres_pointer+1),READ_DATA_BYTE4(SF_Data_Addres_pointer+2),READ_DATA_BYTE4(SF_Data_Addres_pointer+3)); 
01B4C:  MOVLB  C
01B4E:  CLRF   x6D
01B50:  MOVLW  01
01B52:  MOVWF  x6C
01B54:  CLRF   x6B
01B56:  CLRF   x6A
01B58:  MOVLB  0
01B5A:  CALL   0E60
01B5E:  MOVFF  01,C4F
01B62:  MOVLB  C
01B64:  CLRF   x6D
01B66:  MOVLW  01
01B68:  MOVWF  x6C
01B6A:  CLRF   x6B
01B6C:  MOVWF  x6A
01B6E:  MOVLB  0
01B70:  CALL   0E60
01B74:  MOVFF  01,C50
01B78:  MOVLB  C
01B7A:  CLRF   x6D
01B7C:  MOVLW  01
01B7E:  MOVWF  x6C
01B80:  CLRF   x6B
01B82:  MOVLW  02
01B84:  MOVWF  x6A
01B86:  MOVLB  0
01B88:  CALL   0E60
01B8C:  MOVFF  01,C51
01B90:  MOVLB  C
01B92:  CLRF   x6D
01B94:  MOVLW  01
01B96:  MOVWF  x6C
01B98:  CLRF   x6B
01B9A:  MOVLW  03
01B9C:  MOVWF  x6A
01B9E:  MOVLB  0
01BA0:  CALL   0E60
01BA4:  MOVFF  01,C52
01BA8:  MOVLW  3C
01BAA:  MOVWF  FF6
01BAC:  MOVLW  0B
01BAE:  MOVWF  FF7
01BB0:  MOVLW  00
01BB2:  MOVWF  FF8
01BB4:  CLRF   1B
01BB6:  BTFSC  FF2.7
01BB8:  BSF    1B.7
01BBA:  BCF    FF2.7
01BBC:  MOVLW  2C
01BBE:  MOVLB  C
01BC0:  MOVWF  x9A
01BC2:  MOVLB  0
01BC4:  CALL   05B8
01BC8:  BTFSC  1B.7
01BCA:  BSF    FF2.7
01BCC:  CLRF   1B
01BCE:  BTFSC  FF2.7
01BD0:  BSF    1B.7
01BD2:  BCF    FF2.7
01BD4:  MOVFF  C4F,C9A
01BD8:  MOVLW  37
01BDA:  MOVLB  C
01BDC:  MOVWF  x9B
01BDE:  MOVLB  0
01BE0:  CALL   05E8
01BE4:  BTFSC  1B.7
01BE6:  BSF    FF2.7
01BE8:  CLRF   1B
01BEA:  BTFSC  FF2.7
01BEC:  BSF    1B.7
01BEE:  BCF    FF2.7
01BF0:  MOVFF  C50,C9A
01BF4:  MOVLW  37
01BF6:  MOVLB  C
01BF8:  MOVWF  x9B
01BFA:  MOVLB  0
01BFC:  CALL   05E8
01C00:  BTFSC  1B.7
01C02:  BSF    FF2.7
01C04:  CLRF   1B
01C06:  BTFSC  FF2.7
01C08:  BSF    1B.7
01C0A:  BCF    FF2.7
01C0C:  MOVFF  C51,C9A
01C10:  MOVLW  37
01C12:  MOVLB  C
01C14:  MOVWF  x9B
01C16:  MOVLB  0
01C18:  CALL   05E8
01C1C:  BTFSC  1B.7
01C1E:  BSF    FF2.7
01C20:  CLRF   1B
01C22:  BTFSC  FF2.7
01C24:  BSF    1B.7
01C26:  BCF    FF2.7
01C28:  MOVFF  C52,C9A
01C2C:  MOVLW  37
01C2E:  MOVLB  C
01C30:  MOVWF  x9B
01C32:  MOVLB  0
01C34:  CALL   05E8
01C38:  BTFSC  1B.7
01C3A:  BSF    FF2.7
01C3C:  CLRF   1B
01C3E:  BTFSC  FF2.7
01C40:  BSF    1B.7
01C42:  BCF    FF2.7
01C44:  MOVLW  0D
01C46:  MOVLB  C
01C48:  MOVWF  x9E
01C4A:  MOVLB  0
01C4C:  CALL   054A
01C50:  BTFSC  1B.7
01C52:  BSF    FF2.7
01C54:  CLRF   1B
01C56:  BTFSC  FF2.7
01C58:  BSF    1B.7
01C5A:  BCF    FF2.7
01C5C:  MOVLW  0A
01C5E:  MOVLB  C
01C60:  MOVWF  x9E
01C62:  MOVLB  0
01C64:  CALL   054A
01C68:  BTFSC  1B.7
01C6A:  BSF    FF2.7
.................... fprintf(debugPort,"address pointer %X%X%X%X\r\n",READ_DATA_BYTE4(rcved_data_adrs_pointer),READ_DATA_BYTE4(rcved_data_adrs_pointer+1),READ_DATA_BYTE4(rcved_data_adrs_pointer+2),READ_DATA_BYTE4(rcved_data_adrs_pointer+3)); 
01C6C:  MOVLW  05
01C6E:  MOVLB  C
01C70:  MOVWF  x6D
01C72:  MOVLW  FE
01C74:  MOVWF  x6C
01C76:  MOVLW  F0
01C78:  MOVWF  x6B
01C7A:  CLRF   x6A
01C7C:  MOVLB  0
01C7E:  CALL   0E60
01C82:  MOVFF  01,C4F
01C86:  MOVLW  05
01C88:  MOVLB  C
01C8A:  MOVWF  x6D
01C8C:  MOVLW  FE
01C8E:  MOVWF  x6C
01C90:  MOVLW  F0
01C92:  MOVWF  x6B
01C94:  MOVLW  01
01C96:  MOVWF  x6A
01C98:  MOVLB  0
01C9A:  CALL   0E60
01C9E:  MOVFF  01,C50
01CA2:  MOVLW  05
01CA4:  MOVLB  C
01CA6:  MOVWF  x6D
01CA8:  MOVLW  FE
01CAA:  MOVWF  x6C
01CAC:  MOVLW  F0
01CAE:  MOVWF  x6B
01CB0:  MOVLW  02
01CB2:  MOVWF  x6A
01CB4:  MOVLB  0
01CB6:  CALL   0E60
01CBA:  MOVFF  01,C51
01CBE:  MOVLW  05
01CC0:  MOVLB  C
01CC2:  MOVWF  x6D
01CC4:  MOVLW  FE
01CC6:  MOVWF  x6C
01CC8:  MOVLW  F0
01CCA:  MOVWF  x6B
01CCC:  MOVLW  03
01CCE:  MOVWF  x6A
01CD0:  MOVLB  0
01CD2:  CALL   0E60
01CD6:  MOVFF  01,C52
01CDA:  MOVLW  74
01CDC:  MOVWF  FF6
01CDE:  MOVLW  0B
01CE0:  MOVWF  FF7
01CE2:  MOVLW  00
01CE4:  MOVWF  FF8
01CE6:  CLRF   1B
01CE8:  BTFSC  FF2.7
01CEA:  BSF    1B.7
01CEC:  BCF    FF2.7
01CEE:  MOVLW  10
01CF0:  MOVLB  C
01CF2:  MOVWF  x9A
01CF4:  MOVLB  0
01CF6:  CALL   05B8
01CFA:  BTFSC  1B.7
01CFC:  BSF    FF2.7
01CFE:  CLRF   1B
01D00:  BTFSC  FF2.7
01D02:  BSF    1B.7
01D04:  BCF    FF2.7
01D06:  MOVFF  C4F,C9A
01D0A:  MOVLW  37
01D0C:  MOVLB  C
01D0E:  MOVWF  x9B
01D10:  MOVLB  0
01D12:  CALL   05E8
01D16:  BTFSC  1B.7
01D18:  BSF    FF2.7
01D1A:  CLRF   1B
01D1C:  BTFSC  FF2.7
01D1E:  BSF    1B.7
01D20:  BCF    FF2.7
01D22:  MOVFF  C50,C9A
01D26:  MOVLW  37
01D28:  MOVLB  C
01D2A:  MOVWF  x9B
01D2C:  MOVLB  0
01D2E:  CALL   05E8
01D32:  BTFSC  1B.7
01D34:  BSF    FF2.7
01D36:  CLRF   1B
01D38:  BTFSC  FF2.7
01D3A:  BSF    1B.7
01D3C:  BCF    FF2.7
01D3E:  MOVFF  C51,C9A
01D42:  MOVLW  37
01D44:  MOVLB  C
01D46:  MOVWF  x9B
01D48:  MOVLB  0
01D4A:  CALL   05E8
01D4E:  BTFSC  1B.7
01D50:  BSF    FF2.7
01D52:  CLRF   1B
01D54:  BTFSC  FF2.7
01D56:  BSF    1B.7
01D58:  BCF    FF2.7
01D5A:  MOVFF  C52,C9A
01D5E:  MOVLW  37
01D60:  MOVLB  C
01D62:  MOVWF  x9B
01D64:  MOVLB  0
01D66:  CALL   05E8
01D6A:  BTFSC  1B.7
01D6C:  BSF    FF2.7
01D6E:  CLRF   1B
01D70:  BTFSC  FF2.7
01D72:  BSF    1B.7
01D74:  BCF    FF2.7
01D76:  MOVLW  0D
01D78:  MOVLB  C
01D7A:  MOVWF  x9E
01D7C:  MOVLB  0
01D7E:  CALL   054A
01D82:  BTFSC  1B.7
01D84:  BSF    FF2.7
01D86:  CLRF   1B
01D88:  BTFSC  FF2.7
01D8A:  BSF    1B.7
01D8C:  BCF    FF2.7
01D8E:  MOVLW  0A
01D90:  MOVLB  C
01D92:  MOVWF  x9E
01D94:  MOVLB  0
01D96:  CALL   054A
01D9A:  BTFSC  1B.7
01D9C:  BSF    FF2.7
....................  
....................  
.................... while(isBusy())  
01D9E:  CALL   0E02
01DA2:  MOVF   01,F
01DA4:  BZ    1E40
.................... { 
.................... fprintf(debugPort,"Cannot access the Flash Memory, SR=%X\r\n",ReadSR()); 
01DA6:  GOTO   0F0A
01DAA:  MOVFF  01,C4F
01DAE:  MOVLW  90
01DB0:  MOVWF  FF6
01DB2:  MOVLW  0B
01DB4:  MOVWF  FF7
01DB6:  MOVLW  00
01DB8:  MOVWF  FF8
01DBA:  CLRF   1B
01DBC:  BTFSC  FF2.7
01DBE:  BSF    1B.7
01DC0:  BCF    FF2.7
01DC2:  MOVLW  23
01DC4:  MOVLB  C
01DC6:  MOVWF  x9A
01DC8:  MOVLB  0
01DCA:  CALL   05B8
01DCE:  BTFSC  1B.7
01DD0:  BSF    FF2.7
01DD2:  CLRF   1B
01DD4:  BTFSC  FF2.7
01DD6:  BSF    1B.7
01DD8:  BCF    FF2.7
01DDA:  MOVFF  C4F,C9A
01DDE:  MOVLW  37
01DE0:  MOVLB  C
01DE2:  MOVWF  x9B
01DE4:  MOVLB  0
01DE6:  CALL   05E8
01DEA:  BTFSC  1B.7
01DEC:  BSF    FF2.7
01DEE:  CLRF   1B
01DF0:  BTFSC  FF2.7
01DF2:  BSF    1B.7
01DF4:  BCF    FF2.7
01DF6:  MOVLW  0D
01DF8:  MOVLB  C
01DFA:  MOVWF  x9E
01DFC:  MOVLB  0
01DFE:  CALL   054A
01E02:  BTFSC  1B.7
01E04:  BSF    FF2.7
01E06:  CLRF   1B
01E08:  BTFSC  FF2.7
01E0A:  BSF    1B.7
01E0C:  BCF    FF2.7
01E0E:  MOVLW  0A
01E10:  MOVLB  C
01E12:  MOVWF  x9E
01E14:  MOVLB  0
01E16:  CALL   054A
01E1A:  BTFSC  1B.7
01E1C:  BSF    FF2.7
.................... delay_ms(1000);  
01E1E:  MOVLW  04
01E20:  MOVLB  C
01E22:  MOVWF  x4F
01E24:  MOVLW  FA
01E26:  MOVWF  x86
01E28:  MOVLB  0
01E2A:  CALL   0EE2
01E2E:  MOVLB  C
01E30:  DECFSZ x4F,F
01E32:  BRA    1E24
.................... sendACKtoMB(need_restart_ackMB); 
01E34:  MOVFF  662,C4F
01E38:  MOVLB  0
01E3A:  CALL   0F62
01E3E:  BRA    1D9E
.................... }; 
....................  
.................... //reset_all(); 
....................  
....................  
.................... if ((READ_DATA_BYTE4(satellite_info_pointer+6)!=0x00)||(READ_DATA_BYTE4(satellite_info_pointer)!='B') ){write_satellite_info();} 
01E40:  MOVLB  C
01E42:  CLRF   x6D
01E44:  CLRF   x6C
01E46:  MOVLW  20
01E48:  MOVWF  x6B
01E4A:  MOVLW  06
01E4C:  MOVWF  x6A
01E4E:  MOVLB  0
01E50:  CALL   0E60
01E54:  MOVF   01,F
01E56:  BNZ   1E70
01E58:  MOVLB  C
01E5A:  CLRF   x6D
01E5C:  CLRF   x6C
01E5E:  MOVLW  20
01E60:  MOVWF  x6B
01E62:  CLRF   x6A
01E64:  MOVLB  0
01E66:  CALL   0E60
01E6A:  MOVF   01,W
01E6C:  SUBLW  42
01E6E:  BTFSS  FD8.2
01E70:  RCALL  168C
....................  
.................... if (READ_DATA_BYTE4(SF_Data_Addres_pointer)==0xFF) 
01E72:  MOVLB  C
01E74:  CLRF   x6D
01E76:  MOVLW  01
01E78:  MOVWF  x6C
01E7A:  CLRF   x6B
01E7C:  CLRF   x6A
01E7E:  MOVLB  0
01E80:  CALL   0E60
01E84:  INCFSZ 01,W
01E86:  BRA    1E8A
....................    { 
....................       reset_SFward_FM_data(); 
01E88:  RCALL  1A5C
....................    } 
....................  
.................... //fprintf(debugPort,"Writing to SFwardFM will start from address %X%X%X%X\r\n",READ_DATA_BYTE4(SF_Data_Addres_pointer),READ_DATA_BYTE4(SF_Data_Addres_pointer+1),READ_DATA_BYTE4(SF_Data_Addres_pointer+2),READ_DATA_BYTE4(SF_Data_Addres_pointer+3)); 
....................  
.................... enable_interrupts(GLOBAL); 
01E8A:  MOVLW  C0
01E8C:  IORWF  FF2,F
.................... enable_interrupts(INT_RDA2); 
01E8E:  BSF    FA3.5
.................... enable_interrupts(INT_RDA3); 
01E90:  BSF    F61.5
01E92:  GOTO   68B2 (RETURN)
....................  
.................... } 
....................  
.................... void main() 
*
06656:  CLRF   FF8
06658:  BCF    FD0.7
0665A:  BSF    07.7
0665C:  MOVLB  E
0665E:  MOVLW  55
06660:  MOVWF  F7E
06662:  MOVLW  AA
06664:  MOVWF  F7E
06666:  BCF    F66.6
06668:  MOVLW  F4
0666A:  MOVWF  x2B
0666C:  MOVLW  F7
0666E:  MOVWF  x2C
06670:  MOVLW  20
06672:  MOVWF  x1B
06674:  MOVWF  x20
06676:  MOVLW  55
06678:  MOVWF  F7E
0667A:  MOVLW  AA
0667C:  MOVWF  F7E
0667E:  BSF    F66.6
06680:  CLRF   F9B
06682:  CLRF   F64
06684:  CLRF   F65
06686:  CLRF   F66
06688:  MOVLW  03
0668A:  MOVWF  FD3
0668C:  BSF    F92.1
0668E:  BCF    F92.0
06690:  BCF    F92.3
06692:  BCF    F89.3
06694:  CLRF   1C
06696:  MOVLB  F
06698:  BSF    x31.3
0669A:  MOVLW  A0
0669C:  MOVWF  x1F
0669E:  MOVLW  01
066A0:  MOVWF  x20
066A2:  MOVLW  A6
066A4:  MOVWF  x32
066A6:  MOVLW  90
066A8:  MOVWF  x33
066AA:  BSF    x2D.3
066AC:  MOVLW  40
066AE:  MOVWF  x2B
066B0:  MOVLW  03
066B2:  MOVWF  x2C
066B4:  MOVLW  A6
066B6:  MOVWF  x2E
066B8:  MOVLW  90
066BA:  MOVWF  x2F
066BC:  BCF    F96.6
066BE:  BSF    F8D.6
066C0:  MOVLW  14
066C2:  MOVWF  1D
066C4:  BCF    1E.0
066C6:  CLRF   20
066C8:  CLRF   1F
066CA:  CLRF   25
066CC:  MOVLB  0
066CE:  CLRF   xA6
066D0:  MOVLW  30
066D2:  MOVLB  1
066D4:  MOVWF  x27
066D6:  MOVWF  x28
066D8:  MOVLW  3E
066DA:  MOVWF  x29
066DC:  MOVLW  F0
066DE:  MOVWF  x2A
066E0:  CLRF   x2C
066E2:  CLRF   x2B
066E4:  CLRF   x61
066E6:  CLRF   x60
066E8:  MOVLW  30
066EA:  MOVLB  3
066EC:  MOVWF  x69
066EE:  MOVWF  x71
066F0:  MOVLW  3E
066F2:  MOVWF  x72
066F4:  MOVLW  F0
066F6:  MOVWF  x73
066F8:  MOVLB  4
066FA:  CLRF   x83
066FC:  CLRF   x82
066FE:  CLRF   x81
06700:  CLRF   x80
06702:  BCF    1E.1
06704:  BCF    1E.2
06706:  CLRF   x8B
06708:  MOVLW  11
0670A:  MOVWF  x93
0670C:  MOVLW  22
0670E:  MOVWF  x9B
06710:  MOVLW  33
06712:  MOVWF  xA3
06714:  CLRF   xA4
06716:  CLRF   xAD
06718:  MOVLW  99
0671A:  MOVWF  xAE
0671C:  CLRF   xF4
0671E:  CLRF   xF5
06720:  CLRF   xF6
06722:  CLRF   xF7
06724:  MOVLB  6
06726:  CLRF   x35
06728:  CLRF   x34
0672A:  CLRF   x33
0672C:  CLRF   x32
0672E:  CLRF   x37
06730:  MOVLW  51
06732:  MOVWF  x36
06734:  CLRF   x5F
06736:  MOVLW  77
06738:  MOVWF  x60
0673A:  MOVLW  33
0673C:  MOVWF  x61
0673E:  MOVLW  44
06740:  MOVWF  x62
06742:  BCF    1E.3
06744:  BCF    1E.4
06746:  CLRF   x66
06748:  MOVLW  01
0674A:  MOVWF  x65
0674C:  MOVLW  10
0674E:  MOVWF  x64
06750:  CLRF   x63
06752:  CLRF   x6F
06754:  MOVLB  E
06756:  CLRF   xD9
06758:  CLRF   xDA
0675A:  CLRF   x45
0675C:  CLRF   x46
0675E:  CLRF   x47
06760:  BCF    x8D.7
06762:  BCF    x8D.6
06764:  BCF    x8D.5
06766:  MOVLB  1
06768:  CLRF   x88
0676A:  MOVLB  F
0676C:  CLRF   x53
0676E:  CLRF   x38
06770:  CLRF   x37
06772:  MOVLW  0C
06774:  MOVWF  24
06776:  MOVLW  A1
06778:  MOVWF  23
0677A:  MOVLW  01
0677C:  MOVLB  C
0677E:  MOVWF  xA2
06780:  MOVLW  55
06782:  MOVWF  xA1
06784:  CLRF   xA4
06786:  CLRF   xA3
06788:  MOVLB  0
0678A:  BRA    6870
0678C:  DATA 02,00
0678E:  DATA 21,00
06790:  DATA 00,80
06792:  DATA 40,26
06794:  DATA 00,80
06796:  DATA 40,A7
06798:  DATA 00,33
0679A:  DATA 01,2D
0679C:  DATA C0,00
0679E:  DATA 4A,47
067A0:  DATA 36,59
067A2:  DATA 4B,4D
067A4:  DATA 30,53
067A6:  DATA 26,46
067A8:  DATA 47,53
067AA:  DATA 54,31
067AC:  DATA 3E,F0
067AE:  DATA 53,46
067B0:  DATA 00,00
067B2:  DATA 51,31
067B4:  DATA 38,30
067B6:  DATA 37,30
067B8:  DATA 31,33
067BA:  DATA 31,35
067BC:  DATA 30,35
067BE:  DATA 31,38
067C0:  DATA 55,37
067C2:  DATA 31,30
067C4:  DATA 31,33
067C6:  DATA 31,35
067C8:  DATA 32,30
067CA:  DATA 32,32
067CC:  DATA 35,53
067CE:  DATA C0,FF
067D0:  DATA 41,62
067D2:  DATA 00,FF
067D4:  DATA C0,00
067D6:  DATA 09,C0
067D8:  DATA 00,07
067DA:  DATA 43,6A
067DC:  DATA 00,04
067DE:  DATA 04,74
067E0:  DATA 53,46
067E2:  DATA 53,46
067E4:  DATA 07,04
067E6:  DATA 84,42
067E8:  DATA 49,52
067EA:  DATA 44,4A
067EC:  DATA 50,00
067EE:  DATA 07,04
067F0:  DATA 8C,4A
067F2:  DATA 47,36
067F4:  DATA 59,42
067F6:  DATA 57,00
067F8:  DATA 07,04
067FA:  DATA 94,4A
067FC:  DATA 47,36
067FE:  DATA 59,42
06800:  DATA 41,00
06802:  DATA 07,04
06804:  DATA 9C,4A
06806:  DATA 47,36
06808:  DATA 59,42
0680A:  DATA 43,00
0680C:  DATA 02,04
0680E:  DATA F2,88
06810:  DATA 88,27
06812:  DATA 06,38
06814:  DATA 01,02
06816:  DATA 03,04
06818:  DATA 05,06
0681A:  DATA 07,01
0681C:  DATA 02,03
0681E:  DATA 04,05
06820:  DATA 06,07
06822:  DATA 01,02
06824:  DATA 03,04
06826:  DATA 05,06
06828:  DATA 07,01
0682A:  DATA 02,03
0682C:  DATA 04,05
0682E:  DATA 06,07
06830:  DATA 01,02
06832:  DATA 03,04
06834:  DATA 05,06
06836:  DATA 07,54
06838:  DATA 4C,45
0683A:  DATA 00,04
0683C:  DATA 06,67
0683E:  DATA 00,01
06840:  DATA 10,00
06842:  DATA 07,06
06844:  DATA 70,00
06846:  DATA 42,49
06848:  DATA 52,44
0684A:  DATA 53,35
0684C:  DATA 04,C0
0684E:  DATA 00,06
06850:  DATA 80,4A
06852:  DATA 47,36
06854:  DATA 59,42
06856:  DATA 41,04
06858:  DATA C0,00
0685A:  DATA 06,80
0685C:  DATA 4A,47
0685E:  DATA 36,59
06860:  DATA 42,43
06862:  DATA FF,C0
06864:  DATA 00,FF
06866:  DATA C0,00
06868:  DATA FF,C0
0686A:  DATA 00,D0
0686C:  DATA C0,00
0686E:  DATA 00,00
06870:  MOVLW  00
06872:  MOVWF  FF8
06874:  MOVLW  67
06876:  MOVWF  FF7
06878:  MOVLW  8C
0687A:  MOVWF  FF6
0687C:  TBLRD*+
0687E:  MOVF   FF5,W
06880:  MOVWF  00
06882:  XORLW  00
06884:  BZ    68AC
06886:  TBLRD*+
06888:  MOVF   FF5,W
0688A:  MOVWF  01
0688C:  BTFSC  FE8.7
0688E:  BRA    689A
06890:  ANDLW  0F
06892:  MOVWF  FEA
06894:  TBLRD*+
06896:  MOVF   FF5,W
06898:  MOVWF  FE9
0689A:  BTFSC  01.6
0689C:  TBLRD*+
0689E:  BTFSS  01.6
068A0:  TBLRD*+
068A2:  MOVF   FF5,W
068A4:  MOVWF  FEE
068A6:  DCFSNZ 00,F
068A8:  BRA    687C
068AA:  BRA    689E
068AC:  CLRF   FF8
....................  
.................... { 
....................    settings(); 
068AE:  GOTO   1AF0
....................  
....................    int8 SF_data[APRS_packet_max_length]; 
....................    int8 APRS_packet_no=0; 
....................    int8 APRS_info[67]="HelloWorld my name is Edgar"; 
068B2:  MOVLB  B
068B4:  CLRF   x84
068B6:  MOVLW  48
068B8:  MOVWF  x85
068BA:  MOVLW  65
068BC:  MOVWF  x86
068BE:  MOVLW  6C
068C0:  MOVWF  x87
068C2:  MOVWF  x88
068C4:  MOVLW  6F
068C6:  MOVWF  x89
068C8:  MOVLW  57
068CA:  MOVWF  x8A
068CC:  MOVLW  6F
068CE:  MOVWF  x8B
068D0:  MOVLW  72
068D2:  MOVWF  x8C
068D4:  MOVLW  6C
068D6:  MOVWF  x8D
068D8:  MOVLW  64
068DA:  MOVWF  x8E
068DC:  MOVLW  20
068DE:  MOVWF  x8F
068E0:  MOVLW  6D
068E2:  MOVWF  x90
068E4:  MOVLW  79
068E6:  MOVWF  x91
068E8:  MOVLW  20
068EA:  MOVWF  x92
068EC:  MOVLW  6E
068EE:  MOVWF  x93
068F0:  MOVLW  61
068F2:  MOVWF  x94
068F4:  MOVLW  6D
068F6:  MOVWF  x95
068F8:  MOVLW  65
068FA:  MOVWF  x96
068FC:  MOVLW  20
068FE:  MOVWF  x97
06900:  MOVLW  69
06902:  MOVWF  x98
06904:  MOVLW  73
06906:  MOVWF  x99
06908:  MOVLW  20
0690A:  MOVWF  x9A
0690C:  MOVLW  45
0690E:  MOVWF  x9B
06910:  MOVLW  64
06912:  MOVWF  x9C
06914:  MOVLW  67
06916:  MOVWF  x9D
06918:  MOVLW  61
0691A:  MOVWF  x9E
0691C:  MOVLW  72
0691E:  MOVWF  x9F
06920:  CLRF   xA0
....................        
.................... //int16 *SF_data; 
.................... //!int * iptr; 
.................... //!iptr=malloc(1); 
.................... //!int *ptr = (int8*) calloc(10 ,sizeof (int8)); 
.................... //!if (ptr == NULL)  
.................... //!{ 
.................... //!  printf("Could not allocate memory\n"); 
.................... //!}  
.................... //!else 
.................... //!  printf("Memory allocated successfully.\n"); 
....................  
....................  
....................    while(TRUE) 
....................    { 
....................     //if (kbhit(serial2APRS))  //check if a character has been received 
....................     //c = getc(serial2APRS);   
....................  
....................  
.................... //******************************************************************************    
....................    //if (byteNumAPRS>=45){fprintf(debugPort,"DataSize= %u\r\n",sizeof(dataAPRS));} 
....................    //if (kbhit(serial2APRS)==1) {} 
....................     
....................    if (actionAPRS==1){ 
06922:  BTFSS  1E.2
06924:  BRA    6A5E
....................    //fprintf(debugPort,"\r\nThe number of received bytes =%u\r\n",(rec_bytes_number_APRS)); 
....................    fprintf(debugPort,"\r\n***********************************************\r\n"); 
06926:  MOVLW  B8
06928:  MOVWF  FF6
0692A:  MOVLW  0B
0692C:  MOVWF  FF7
0692E:  MOVLW  00
06930:  MOVWF  FF8
06932:  CLRF   1B
06934:  BTFSC  FF2.7
06936:  BSF    1B.7
06938:  BCF    FF2.7
0693A:  MOVLB  0
0693C:  CALL   0590
06940:  BTFSC  1B.7
06942:  BSF    FF2.7
....................    for (i=0;i<=rec_bytes_number_APRS;++i) {SF_data[i]=dataAPRS[i]; putc(SF_data[i],debugPort);} 
06944:  MOVLB  4
06946:  CLRF   x83
06948:  CLRF   x82
0694A:  CLRF   x81
0694C:  CLRF   x80
0694E:  MOVF   x83,F
06950:  BNZ   69C6
06952:  MOVF   x82,F
06954:  BNZ   69C6
06956:  MOVF   x81,F
06958:  BNZ   69C6
0695A:  MOVF   x80,W
0695C:  SUBWF  xF6,W
0695E:  BNC   69C6
06960:  MOVLW  58
06962:  ADDWF  x80,W
06964:  MOVWF  01
06966:  MOVLW  0A
06968:  ADDWFC x81,W
0696A:  MOVWF  03
0696C:  MOVLB  C
0696E:  MOVWF  x50
06970:  MOVLW  F8
06972:  MOVLB  4
06974:  ADDWF  x80,W
06976:  MOVWF  FE9
06978:  MOVLW  04
0697A:  ADDWFC x81,W
0697C:  MOVWF  FEA
0697E:  MOVFF  FEF,C51
06982:  MOVFF  03,FEA
06986:  MOVFF  01,FE9
0698A:  MOVFF  C51,FEF
0698E:  MOVLW  58
06990:  MOVLB  4
06992:  ADDWF  x80,W
06994:  MOVWF  FE9
06996:  MOVLW  0A
06998:  ADDWFC x81,W
0699A:  MOVWF  FEA
0699C:  MOVFF  FEF,C9E
069A0:  CLRF   1B
069A2:  BTFSC  FF2.7
069A4:  BSF    1B.7
069A6:  BCF    FF2.7
069A8:  MOVLB  0
069AA:  CALL   054A
069AE:  BTFSC  1B.7
069B0:  BSF    FF2.7
069B2:  MOVLW  01
069B4:  MOVLB  4
069B6:  ADDWF  x80,F
069B8:  BTFSC  FD8.0
069BA:  INCF   x81,F
069BC:  BTFSC  FD8.2
069BE:  INCF   x82,F
069C0:  BTFSC  FD8.2
069C2:  INCF   x83,F
069C4:  BRA    694E
....................  
....................   delay_ms(5); 
069C6:  MOVLW  05
069C8:  MOVLB  C
069CA:  MOVWF  x86
069CC:  MOVLB  0
069CE:  CALL   0EE2
....................  
....................    if (is_sent_to_me(SF_data)) //if the messege is sent to BIRDS4 
069D2:  MOVLW  0A
069D4:  MOVLB  C
069D6:  MOVWF  x50
069D8:  MOVLW  58
069DA:  MOVWF  x4F
069DC:  MOVLB  0
069DE:  GOTO   1E96
069E2:  MOVF   01,F
069E4:  BZ    6A3C
....................       if (is_valid_SFward(SF_data)) 
069E6:  MOVLW  0A
069E8:  MOVLB  C
069EA:  MOVWF  x50
069EC:  MOVLW  58
069EE:  MOVWF  x4F
069F0:  MOVLB  0
069F2:  GOTO   214E
069F6:  MOVF   01,F
069F8:  BZ    6A20
....................          { 
....................             prepare_SFwardData(SF_data); 
069FA:  MOVLW  0A
069FC:  MOVLB  C
069FE:  MOVWF  x50
06A00:  MOVLW  58
06A02:  MOVWF  x4F
06A04:  MOVLB  0
06A06:  GOTO   3F1A
....................             if (!isDuplicatedData)  
06A0A:  BTFSC  1E.4
06A0C:  BRA    6A1E
....................                write_SFwad_data_toFM(SF_data); 
06A0E:  MOVLW  0A
06A10:  MOVLB  C
06A12:  MOVWF  x50
06A14:  MOVLW  58
06A16:  MOVWF  x4F
06A18:  MOVLB  0
06A1A:  GOTO   432A
....................                //show_FM_data(); 
....................          } 
06A1E:  BRA    6A3C
....................       else fprintf(debugPort,"Non SFward msg was received, it was not saved to FM\r\n"); 
06A20:  MOVLW  EC
06A22:  MOVWF  FF6
06A24:  MOVLW  0B
06A26:  MOVWF  FF7
06A28:  MOVLW  00
06A2A:  MOVWF  FF8
06A2C:  CLRF   1B
06A2E:  BTFSC  FF2.7
06A30:  BSF    1B.7
06A32:  BCF    FF2.7
06A34:  CALL   0590
06A38:  BTFSC  1B.7
06A3A:  BSF    FF2.7
....................    
....................   if (!isDuplicatedData)  
06A3C:  BTFSC  1E.4
06A3E:  BRA    6A56
....................   save_rcved_data_in_FM(SF_data,rec_bytes_number_APRS); 
06A40:  MOVLW  0A
06A42:  MOVLB  C
06A44:  MOVWF  x50
06A46:  MOVLW  58
06A48:  MOVWF  x4F
06A4A:  CLRF   x52
06A4C:  MOVFF  4F6,C51
06A50:  MOVLB  0
06A52:  GOTO   4AA0
....................   //for (i=0;i<=rec_bytes_number_APRS;++i) {fprintf(debugPort,"%X ",SF_data[i]);} 
....................    actionAPRS=0; 
06A56:  BCF    1E.2
....................    byteNumAPRS=0; 
06A58:  MOVLB  4
06A5A:  CLRF   xF4
06A5C:  MOVLB  B
....................    } 
....................     
.................... //****************************************************************************** 
....................    if (actionMB==1) 
06A5E:  BTFSS  1E.1
06A60:  GOTO   76AA
....................    { 
....................       fprintf(debugPort," This command is received from MB "); 
06A64:  MOVLW  22
06A66:  MOVWF  FF6
06A68:  MOVLW  0C
06A6A:  MOVWF  FF7
06A6C:  MOVLW  00
06A6E:  MOVWF  FF8
06A70:  CLRF   1B
06A72:  BTFSC  FF2.7
06A74:  BSF    1B.7
06A76:  BCF    FF2.7
06A78:  MOVLB  0
06A7A:  CALL   0590
06A7E:  BTFSC  1B.7
06A80:  BSF    FF2.7
06A82:  CLRF   1B
06A84:  BTFSC  FF2.7
06A86:  BSF    1B.7
06A88:  BCF    FF2.7
....................       fprintf(debugPort,"%X",commandLine[0]); 
06A8A:  MOVFF  624,C9A
06A8E:  MOVLW  37
06A90:  MOVLB  C
06A92:  MOVWF  x9B
06A94:  MOVLB  0
06A96:  CALL   05E8
06A9A:  BTFSC  1B.7
06A9C:  BSF    FF2.7
06A9E:  CLRF   1B
06AA0:  BTFSC  FF2.7
06AA2:  BSF    1B.7
06AA4:  BCF    FF2.7
....................       fprintf(debugPort,"%X",commandLine[1]); 
06AA6:  MOVFF  625,C9A
06AAA:  MOVLW  37
06AAC:  MOVLB  C
06AAE:  MOVWF  x9B
06AB0:  MOVLB  0
06AB2:  CALL   05E8
06AB6:  BTFSC  1B.7
06AB8:  BSF    FF2.7
06ABA:  CLRF   1B
06ABC:  BTFSC  FF2.7
06ABE:  BSF    1B.7
06AC0:  BCF    FF2.7
....................       fprintf(debugPort,"%X",commandLine[2]); 
06AC2:  MOVFF  626,C9A
06AC6:  MOVLW  37
06AC8:  MOVLB  C
06ACA:  MOVWF  x9B
06ACC:  MOVLB  0
06ACE:  CALL   05E8
06AD2:  BTFSC  1B.7
06AD4:  BSF    FF2.7
06AD6:  CLRF   1B
06AD8:  BTFSC  FF2.7
06ADA:  BSF    1B.7
06ADC:  BCF    FF2.7
....................       fprintf(debugPort,"%X",commandLine[3]); 
06ADE:  MOVFF  627,C9A
06AE2:  MOVLW  37
06AE4:  MOVLB  C
06AE6:  MOVWF  x9B
06AE8:  MOVLB  0
06AEA:  CALL   05E8
06AEE:  BTFSC  1B.7
06AF0:  BSF    FF2.7
06AF2:  CLRF   1B
06AF4:  BTFSC  FF2.7
06AF6:  BSF    1B.7
06AF8:  BCF    FF2.7
....................       fprintf(debugPort,"%X",commandLine[4]); 
06AFA:  MOVFF  628,C9A
06AFE:  MOVLW  37
06B00:  MOVLB  C
06B02:  MOVWF  x9B
06B04:  MOVLB  0
06B06:  CALL   05E8
06B0A:  BTFSC  1B.7
06B0C:  BSF    FF2.7
06B0E:  CLRF   1B
06B10:  BTFSC  FF2.7
06B12:  BSF    1B.7
06B14:  BCF    FF2.7
....................       fprintf(debugPort,"%X",commandLine[5]); 
06B16:  MOVFF  629,C9A
06B1A:  MOVLW  37
06B1C:  MOVLB  C
06B1E:  MOVWF  x9B
06B20:  MOVLB  0
06B22:  CALL   05E8
06B26:  BTFSC  1B.7
06B28:  BSF    FF2.7
06B2A:  CLRF   1B
06B2C:  BTFSC  FF2.7
06B2E:  BSF    1B.7
06B30:  BCF    FF2.7
....................       fprintf(debugPort,"%X",commandLine[6]); 
06B32:  MOVFF  62A,C9A
06B36:  MOVLW  37
06B38:  MOVLB  C
06B3A:  MOVWF  x9B
06B3C:  MOVLB  0
06B3E:  CALL   05E8
06B42:  BTFSC  1B.7
06B44:  BSF    FF2.7
06B46:  CLRF   1B
06B48:  BTFSC  FF2.7
06B4A:  BSF    1B.7
06B4C:  BCF    FF2.7
....................       fprintf(debugPort,"\r\n"); 
06B4E:  MOVLW  0D
06B50:  MOVLB  C
06B52:  MOVWF  x9E
06B54:  MOVLB  0
06B56:  CALL   054A
06B5A:  BTFSC  1B.7
06B5C:  BSF    FF2.7
06B5E:  CLRF   1B
06B60:  BTFSC  FF2.7
06B62:  BSF    1B.7
06B64:  BCF    FF2.7
06B66:  MOVLW  0A
06B68:  MOVLB  C
06B6A:  MOVWF  x9E
06B6C:  MOVLB  0
06B6E:  CALL   054A
06B72:  BTFSC  1B.7
06B74:  BSF    FF2.7
....................        
....................       if (commandLine[1]!=0xAA) 
06B76:  MOVLB  6
06B78:  MOVF   x25,W
06B7A:  SUBLW  AA
06B7C:  BTFSC  FD8.2
06B7E:  GOTO   76A6
....................       { 
....................          if ((commandLine[5]==0x00)||(commandLine[5]==0xA2)) 
06B82:  MOVF   x29,F
06B84:  BZ    6B8E
06B86:  MOVF   x29,W
06B88:  SUBLW  A2
06B8A:  BTFSS  FD8.2
06B8C:  BRA    6E0A
....................          { 
....................             memcpy(lastCommandLine,commandLine,sizeof(commandLine)); 
06B8E:  MOVLW  06
06B90:  MOVWF  FEA
06B92:  MOVLW  2B
06B94:  MOVWF  FE9
06B96:  MOVLW  06
06B98:  MOVWF  FE2
06B9A:  MOVLW  24
06B9C:  MOVWF  FE1
06B9E:  MOVLW  07
06BA0:  MOVWF  01
06BA2:  MOVFF  FE6,FEE
06BA6:  DECFSZ 01,F
06BA8:  BRA    6BA2
....................             addressInTheCommand=  make32(lastCommandLine[commandSizeMB-6],lastCommandLine[commandSizeMB-5],lastCommandLine[commandSizeMB-4],lastCommandLine[commandSizeMB-3]); 
06BAA:  MOVFF  62C,635
06BAE:  MOVFF  62D,634
06BB2:  MOVFF  62E,633
06BB6:  MOVFF  62F,632
....................             packetsNoInTheCommand=lastCommandLine[commandSizeMB-1]; 
06BBA:  MOVFF  631,65F
....................        
....................             fprintf(debugPort,"addressInTheCommand  = %lX \r\n",addressInTheCommand); 
06BBE:  MOVLW  46
06BC0:  MOVWF  FF6
06BC2:  MOVLW  0C
06BC4:  MOVWF  FF7
06BC6:  MOVLW  00
06BC8:  MOVWF  FF8
06BCA:  CLRF   1B
06BCC:  BTFSC  FF2.7
06BCE:  BSF    1B.7
06BD0:  BCF    FF2.7
06BD2:  MOVLW  17
06BD4:  MOVLB  C
06BD6:  MOVWF  x9A
06BD8:  MOVLB  0
06BDA:  CALL   05B8
06BDE:  BTFSC  1B.7
06BE0:  BSF    FF2.7
06BE2:  CLRF   1B
06BE4:  BTFSC  FF2.7
06BE6:  BSF    1B.7
06BE8:  BCF    FF2.7
06BEA:  MOVFF  635,C9A
06BEE:  MOVLW  37
06BF0:  MOVLB  C
06BF2:  MOVWF  x9B
06BF4:  MOVLB  0
06BF6:  CALL   05E8
06BFA:  BTFSC  1B.7
06BFC:  BSF    FF2.7
06BFE:  CLRF   1B
06C00:  BTFSC  FF2.7
06C02:  BSF    1B.7
06C04:  BCF    FF2.7
06C06:  MOVFF  634,C9A
06C0A:  MOVLW  37
06C0C:  MOVLB  C
06C0E:  MOVWF  x9B
06C10:  MOVLB  0
06C12:  CALL   05E8
06C16:  BTFSC  1B.7
06C18:  BSF    FF2.7
06C1A:  CLRF   1B
06C1C:  BTFSC  FF2.7
06C1E:  BSF    1B.7
06C20:  BCF    FF2.7
06C22:  MOVFF  633,C9A
06C26:  MOVLW  37
06C28:  MOVLB  C
06C2A:  MOVWF  x9B
06C2C:  MOVLB  0
06C2E:  CALL   05E8
06C32:  BTFSC  1B.7
06C34:  BSF    FF2.7
06C36:  CLRF   1B
06C38:  BTFSC  FF2.7
06C3A:  BSF    1B.7
06C3C:  BCF    FF2.7
06C3E:  MOVFF  632,C9A
06C42:  MOVLW  37
06C44:  MOVLB  C
06C46:  MOVWF  x9B
06C48:  MOVLB  0
06C4A:  CALL   05E8
06C4E:  BTFSC  1B.7
06C50:  BSF    FF2.7
06C52:  MOVLW  60
06C54:  MOVWF  FF6
06C56:  MOVLW  0C
06C58:  MOVWF  FF7
06C5A:  MOVLW  00
06C5C:  MOVWF  FF8
06C5E:  CLRF   1B
06C60:  BTFSC  FF2.7
06C62:  BSF    1B.7
06C64:  BCF    FF2.7
06C66:  MOVLW  03
06C68:  MOVLB  C
06C6A:  MOVWF  x9A
06C6C:  MOVLB  0
06C6E:  CALL   05B8
06C72:  BTFSC  1B.7
06C74:  BSF    FF2.7
....................             fprintf(debugPort,"packetsNoInTheCommand= %lX \r\n",packetsNoInTheCommand); 
06C76:  MOVLW  64
06C78:  MOVWF  FF6
06C7A:  MOVLW  0C
06C7C:  MOVWF  FF7
06C7E:  MOVLW  00
06C80:  MOVWF  FF8
06C82:  CLRF   1B
06C84:  BTFSC  FF2.7
06C86:  BSF    1B.7
06C88:  BCF    FF2.7
06C8A:  MOVLW  17
06C8C:  MOVLB  C
06C8E:  MOVWF  x9A
06C90:  MOVLB  0
06C92:  CALL   05B8
06C96:  BTFSC  1B.7
06C98:  BSF    FF2.7
06C9A:  CLRF   1B
06C9C:  BTFSC  FF2.7
06C9E:  BSF    1B.7
06CA0:  BCF    FF2.7
06CA2:  MOVFF  65F,C9A
06CA6:  MOVLW  37
06CA8:  MOVLB  C
06CAA:  MOVWF  x9B
06CAC:  MOVLB  0
06CAE:  CALL   05E8
06CB2:  BTFSC  1B.7
06CB4:  BSF    FF2.7
06CB6:  MOVLW  7E
06CB8:  MOVWF  FF6
06CBA:  MOVLW  0C
06CBC:  MOVWF  FF7
06CBE:  MOVLW  00
06CC0:  MOVWF  FF8
06CC2:  CLRF   1B
06CC4:  BTFSC  FF2.7
06CC6:  BSF    1B.7
06CC8:  BCF    FF2.7
06CCA:  MOVLW  03
06CCC:  MOVLB  C
06CCE:  MOVWF  x9A
06CD0:  MOVLB  0
06CD2:  CALL   05B8
06CD6:  BTFSC  1B.7
06CD8:  BSF    FF2.7
....................        
....................             fprintf(debugPort," E0 command, send %u packets from %X%X%X%X address.\r\n",lastCommandLine[commandSizeMB-1],lastCommandLine[commandSizeMB-6],lastCommandLine[commandSizeMB-5],lastCommandLine[commandSizeMB-4],lastCommandLine[commandSizeMB-3]); 
06CDA:  MOVLW  82
06CDC:  MOVWF  FF6
06CDE:  MOVLW  0C
06CE0:  MOVWF  FF7
06CE2:  MOVLW  00
06CE4:  MOVWF  FF8
06CE6:  CLRF   1B
06CE8:  BTFSC  FF2.7
06CEA:  BSF    1B.7
06CEC:  BCF    FF2.7
06CEE:  MOVLW  12
06CF0:  MOVLB  C
06CF2:  MOVWF  x9A
06CF4:  MOVLB  0
06CF6:  CALL   05B8
06CFA:  BTFSC  1B.7
06CFC:  BSF    FF2.7
06CFE:  CLRF   1B
06D00:  BTFSC  FF2.7
06D02:  BSF    1B.7
06D04:  BCF    FF2.7
06D06:  MOVFF  631,C9A
06D0A:  MOVLW  1B
06D0C:  MOVLB  C
06D0E:  MOVWF  x9B
06D10:  MOVLB  0
06D12:  CALL   065A
06D16:  BTFSC  1B.7
06D18:  BSF    FF2.7
06D1A:  MOVLW  96
06D1C:  MOVWF  FF6
06D1E:  MOVLW  0C
06D20:  MOVWF  FF7
06D22:  MOVLW  00
06D24:  MOVWF  FF8
06D26:  CLRF   1B
06D28:  BTFSC  FF2.7
06D2A:  BSF    1B.7
06D2C:  BCF    FF2.7
06D2E:  MOVLW  0E
06D30:  MOVLB  C
06D32:  MOVWF  x9A
06D34:  MOVLB  0
06D36:  CALL   05B8
06D3A:  BTFSC  1B.7
06D3C:  BSF    FF2.7
06D3E:  CLRF   1B
06D40:  BTFSC  FF2.7
06D42:  BSF    1B.7
06D44:  BCF    FF2.7
06D46:  MOVFF  62C,C9A
06D4A:  MOVLW  37
06D4C:  MOVLB  C
06D4E:  MOVWF  x9B
06D50:  MOVLB  0
06D52:  CALL   05E8
06D56:  BTFSC  1B.7
06D58:  BSF    FF2.7
06D5A:  CLRF   1B
06D5C:  BTFSC  FF2.7
06D5E:  BSF    1B.7
06D60:  BCF    FF2.7
06D62:  MOVFF  62D,C9A
06D66:  MOVLW  37
06D68:  MOVLB  C
06D6A:  MOVWF  x9B
06D6C:  MOVLB  0
06D6E:  CALL   05E8
06D72:  BTFSC  1B.7
06D74:  BSF    FF2.7
06D76:  CLRF   1B
06D78:  BTFSC  FF2.7
06D7A:  BSF    1B.7
06D7C:  BCF    FF2.7
06D7E:  MOVFF  62E,C9A
06D82:  MOVLW  37
06D84:  MOVLB  C
06D86:  MOVWF  x9B
06D88:  MOVLB  0
06D8A:  CALL   05E8
06D8E:  BTFSC  1B.7
06D90:  BSF    FF2.7
06D92:  CLRF   1B
06D94:  BTFSC  FF2.7
06D96:  BSF    1B.7
06D98:  BCF    FF2.7
06D9A:  MOVFF  62F,C9A
06D9E:  MOVLW  37
06DA0:  MOVLB  C
06DA2:  MOVWF  x9B
06DA4:  MOVLB  0
06DA6:  CALL   05E8
06DAA:  BTFSC  1B.7
06DAC:  BSF    FF2.7
06DAE:  MOVLW  AC
06DB0:  MOVWF  FF6
06DB2:  MOVLW  0C
06DB4:  MOVWF  FF7
06DB6:  MOVLW  00
06DB8:  MOVWF  FF8
06DBA:  CLRF   1B
06DBC:  BTFSC  FF2.7
06DBE:  BSF    1B.7
06DC0:  BCF    FF2.7
06DC2:  MOVLW  0B
06DC4:  MOVLB  C
06DC6:  MOVWF  x9A
06DC8:  MOVLB  0
06DCA:  CALL   05B8
06DCE:  BTFSC  1B.7
06DD0:  BSF    FF2.7
....................  
....................             delay_ms(700); 
06DD2:  MOVLW  04
06DD4:  MOVLB  C
06DD6:  MOVWF  x4F
06DD8:  MOVLW  AF
06DDA:  MOVWF  x86
06DDC:  MOVLB  0
06DDE:  CALL   0EE2
06DE2:  MOVLB  C
06DE4:  DECFSZ x4F,F
06DE6:  BRA    6DD8
....................             //sendACKtoMB(Command_00_ackMB); 
....................             executeE0Command(addressInTheCommand,packetsNoInTheCommand); // 
06DE8:  MOVFF  635,C52
06DEC:  MOVFF  634,C51
06DF0:  MOVFF  633,C50
06DF4:  MOVFF  632,C4F
06DF8:  CLRF   x54
06DFA:  MOVFF  65F,C53
06DFE:  MOVLB  0
06E00:  GOTO   4FBA
....................             //executeE0Command(addressInTheCommand,1); 
....................          } 
06E04:  GOTO   76A0
06E08:  MOVLB  6
....................          else if ((commandLine[5]==0xFF)||(commandLine[5]==0xEE)) 
06E0A:  INCFSZ x29,W
06E0C:  BRA    6E10
06E0E:  BRA    6E16
06E10:  MOVF   x29,W
06E12:  SUBLW  EE
06E14:  BNZ   6E26
....................          { 
....................             reset_SFward_FM_data();   
06E16:  MOVLB  0
06E18:  CALL   1A5C
....................             reset_all(); 
06E1C:  GOTO   577A
....................          } 
06E20:  GOTO   76A0
06E24:  MOVLB  6
....................          else if ( commandLine[5]==0xAA) 
06E26:  MOVF   x29,W
06E28:  SUBLW  AA
06E2A:  BNZ   6E38
....................          { 
....................             show_FM_data(); 
06E2C:  MOVLB  0
06E2E:  CALL   1802
....................          } 
06E32:  GOTO   76A0
06E36:  MOVLB  6
....................          else if ((commandLine[5]==0xCC)||(commandLine[5]==0xA4)) 
06E38:  MOVF   x29,W
06E3A:  SUBLW  CC
06E3C:  BZ    6E46
06E3E:  MOVF   x29,W
06E40:  SUBLW  A4
06E42:  BTFSS  FD8.2
06E44:  BRA    7114
....................          { 
....................               fprintf(debugPort,"APRS_info_before the sending:\r\n"); 
06E46:  MOVLW  B8
06E48:  MOVWF  FF6
06E4A:  MOVLW  0C
06E4C:  MOVWF  FF7
06E4E:  MOVLW  00
06E50:  MOVWF  FF8
06E52:  CLRF   1B
06E54:  BTFSC  FF2.7
06E56:  BSF    1B.7
06E58:  BCF    FF2.7
06E5A:  MOVLB  0
06E5C:  CALL   0590
06E60:  BTFSC  1B.7
06E62:  BSF    FF2.7
....................               for (i=0;i<( sizeof(TLE_array_header)+sizeof(TLE_array) );i++) 
06E64:  MOVLB  4
06E66:  CLRF   x83
06E68:  CLRF   x82
06E6A:  CLRF   x81
06E6C:  CLRF   x80
06E6E:  MOVF   x83,F
06E70:  BNZ   6F34
06E72:  MOVF   x82,F
06E74:  BNZ   6F34
06E76:  MOVF   x81,F
06E78:  BNZ   6F34
06E7A:  MOVF   x80,W
06E7C:  SUBLW  26
06E7E:  BNC   6F34
....................               { 
....................               APRS_info[i]=READ_DATA_BYTE4(  (int32)(TLE_data_inFM+i)  ); 
06E80:  MOVLW  85
06E82:  ADDWF  x80,W
06E84:  MOVWF  01
06E86:  MOVLW  0B
06E88:  ADDWFC x81,W
06E8A:  MOVWF  03
06E8C:  MOVFF  01,C4F
06E90:  MOVLB  C
06E92:  MOVWF  x50
06E94:  MOVLB  4
06E96:  MOVFF  480,00
06E9A:  MOVLW  30
06E9C:  ADDWF  x81,W
06E9E:  MOVWF  01
06EA0:  MOVLW  00
06EA2:  ADDWFC x82,W
06EA4:  MOVWF  02
06EA6:  MOVLW  00
06EA8:  ADDWFC x83,W
06EAA:  MOVWF  03
06EAC:  MOVFF  FE8,C54
06EB0:  MOVFF  02,C53
06EB4:  MOVFF  01,C52
06EB8:  MOVFF  480,C51
06EBC:  MOVFF  FE8,C6D
06EC0:  MOVFF  02,C6C
06EC4:  MOVFF  01,C6B
06EC8:  MOVFF  480,C6A
06ECC:  MOVLB  0
06ECE:  CALL   0E60
06ED2:  MOVFF  C50,FEA
06ED6:  MOVFF  C4F,FE9
06EDA:  MOVFF  01,FEF
....................               fprintf(debugPort,"%X ",APRS_info[i]); 
06EDE:  MOVLW  85
06EE0:  MOVLB  4
06EE2:  ADDWF  x80,W
06EE4:  MOVWF  FE9
06EE6:  MOVLW  0B
06EE8:  ADDWFC x81,W
06EEA:  MOVWF  FEA
06EEC:  MOVFF  FEF,C9A
06EF0:  CLRF   1B
06EF2:  BTFSC  FF2.7
06EF4:  BSF    1B.7
06EF6:  BCF    FF2.7
06EF8:  MOVLW  37
06EFA:  MOVLB  C
06EFC:  MOVWF  x9B
06EFE:  MOVLB  0
06F00:  CALL   05E8
06F04:  BTFSC  1B.7
06F06:  BSF    FF2.7
06F08:  CLRF   1B
06F0A:  BTFSC  FF2.7
06F0C:  BSF    1B.7
06F0E:  BCF    FF2.7
06F10:  MOVLW  20
06F12:  MOVLB  C
06F14:  MOVWF  x9E
06F16:  MOVLB  0
06F18:  CALL   054A
06F1C:  BTFSC  1B.7
06F1E:  BSF    FF2.7
06F20:  MOVLW  01
06F22:  MOVLB  4
06F24:  ADDWF  x80,F
06F26:  BTFSC  FD8.0
06F28:  INCF   x81,F
06F2A:  BTFSC  FD8.2
06F2C:  INCF   x82,F
06F2E:  BTFSC  FD8.2
06F30:  INCF   x83,F
06F32:  BRA    6E6E
06F34:  CLRF   1B
06F36:  BTFSC  FF2.7
06F38:  BSF    1B.7
06F3A:  BCF    FF2.7
....................               } 
....................               fprintf(debugPort,"\r\n"); 
06F3C:  MOVLW  0D
06F3E:  MOVLB  C
06F40:  MOVWF  x9E
06F42:  MOVLB  0
06F44:  CALL   054A
06F48:  BTFSC  1B.7
06F4A:  BSF    FF2.7
06F4C:  CLRF   1B
06F4E:  BTFSC  FF2.7
06F50:  BSF    1B.7
06F52:  BCF    FF2.7
06F54:  MOVLW  0A
06F56:  MOVLB  C
06F58:  MOVWF  x9E
06F5A:  MOVLB  0
06F5C:  CALL   054A
06F60:  BTFSC  1B.7
06F62:  BSF    FF2.7
....................                
....................               fprintf(debugPort,"EXPEREMENT ...\r\n"); 
06F64:  MOVLW  D8
06F66:  MOVWF  FF6
06F68:  MOVLW  0C
06F6A:  MOVWF  FF7
06F6C:  MOVLW  00
06F6E:  MOVWF  FF8
06F70:  CLRF   1B
06F72:  BTFSC  FF2.7
06F74:  BSF    1B.7
06F76:  BCF    FF2.7
06F78:  CALL   0590
06F7C:  BTFSC  1B.7
06F7E:  BSF    FF2.7
....................               int8 APRS_info_str[120]; 
....................               int8 APRS_info_str_temp[3]; 
....................                
....................               sprintf(APRS_info_str,"%X",APRS_info[0]); 
06F80:  MOVLW  0B
06F82:  MOVWF  20
06F84:  MOVLW  C8
06F86:  MOVWF  1F
06F88:  MOVFF  B85,C50
06F8C:  MOVLW  37
06F8E:  MOVLB  C
06F90:  MOVWF  x51
06F92:  MOVLB  0
06F94:  CALL   5994
....................               for (i=1;i<39;i++) 
06F98:  MOVLB  4
06F9A:  CLRF   x83
06F9C:  CLRF   x82
06F9E:  CLRF   x81
06FA0:  MOVLW  01
06FA2:  MOVWF  x80
06FA4:  MOVF   x83,F
06FA6:  BNZ   7036
06FA8:  MOVF   x82,F
06FAA:  BNZ   7036
06FAC:  MOVF   x81,F
06FAE:  BNZ   7036
06FB0:  MOVF   x80,W
06FB2:  SUBLW  26
06FB4:  BNC   7036
....................               { 
....................               sprintf(APRS_info_str_temp,"%X",APRS_info[i]); 
06FB6:  MOVLW  85
06FB8:  ADDWF  x80,W
06FBA:  MOVWF  FE9
06FBC:  MOVLW  0B
06FBE:  ADDWFC x81,W
06FC0:  MOVWF  FEA
06FC2:  MOVFF  FEF,C50
06FC6:  MOVLW  0C
06FC8:  MOVWF  20
06FCA:  MOVLW  40
06FCC:  MOVWF  1F
06FCE:  MOVLW  37
06FD0:  MOVLB  C
06FD2:  MOVWF  x51
06FD4:  MOVLB  0
06FD6:  CALL   5994
....................               strcat (APRS_info_str,APRS_info_str_temp); 
06FDA:  MOVLW  0B
06FDC:  MOVLB  C
06FDE:  MOVWF  x50
06FE0:  MOVLW  C8
06FE2:  MOVWF  x4F
06FE4:  MOVLW  0C
06FE6:  MOVWF  x52
06FE8:  MOVLW  40
06FEA:  MOVWF  x51
06FEC:  MOVLB  0
06FEE:  GOTO   59DA
....................               fprintf(debugPort,"%s \r\n",APRS_info_str); 
06FF2:  MOVLW  0B
06FF4:  MOVWF  FEA
06FF6:  MOVLW  C8
06FF8:  MOVWF  FE9
06FFA:  CALL   5A4E
06FFE:  MOVLW  EC
07000:  MOVWF  FF6
07002:  MOVLW  0C
07004:  MOVWF  FF7
07006:  MOVLW  00
07008:  MOVWF  FF8
0700A:  CLRF   1B
0700C:  BTFSC  FF2.7
0700E:  BSF    1B.7
07010:  BCF    FF2.7
07012:  MOVLW  03
07014:  MOVLB  C
07016:  MOVWF  x9A
07018:  MOVLB  0
0701A:  CALL   05B8
0701E:  BTFSC  1B.7
07020:  BSF    FF2.7
07022:  MOVLW  01
07024:  MOVLB  4
07026:  ADDWF  x80,F
07028:  BTFSC  FD8.0
0702A:  INCF   x81,F
0702C:  BTFSC  FD8.2
0702E:  INCF   x82,F
07030:  BTFSC  FD8.2
07032:  INCF   x83,F
07034:  BRA    6FA4
....................               } 
....................               fprintf(debugPort,"%s \r\n",APRS_info_str); 
07036:  MOVLW  0B
07038:  MOVWF  FEA
0703A:  MOVLW  C8
0703C:  MOVWF  FE9
0703E:  MOVLB  0
07040:  CALL   5A4E
07044:  MOVLW  F2
07046:  MOVWF  FF6
07048:  MOVLW  0C
0704A:  MOVWF  FF7
0704C:  MOVLW  00
0704E:  MOVWF  FF8
07050:  CLRF   1B
07052:  BTFSC  FF2.7
07054:  BSF    1B.7
07056:  BCF    FF2.7
07058:  MOVLW  03
0705A:  MOVLB  C
0705C:  MOVWF  x9A
0705E:  MOVLB  0
07060:  CALL   05B8
07064:  BTFSC  1B.7
07066:  BSF    FF2.7
....................  
....................               fprintf(debugPort,"SENDING ...\r\n"); 
07068:  MOVLW  F6
0706A:  MOVWF  FF6
0706C:  MOVLW  0C
0706E:  MOVWF  FF7
07070:  MOVLW  00
07072:  MOVWF  FF8
07074:  CLRF   1B
07076:  BTFSC  FF2.7
07078:  BSF    1B.7
0707A:  BCF    FF2.7
0707C:  CALL   0590
07080:  BTFSC  1B.7
07082:  BSF    FF2.7
....................               if (APRS_packet_no>=99) APRS_packet_no=0; 
07084:  MOVLB  B
07086:  MOVF   x84,W
07088:  SUBLW  62
0708A:  BC    708E
0708C:  CLRF   x84
....................               send_APRS(++APRS_packet_no,APRS_info_str); delay_ms(1000); 
0708E:  INCF   x84,F
07090:  MOVFF  B84,C4F
07094:  MOVLW  0B
07096:  MOVLB  C
07098:  MOVWF  x51
0709A:  MOVLW  C8
0709C:  MOVWF  x50
0709E:  MOVLB  0
070A0:  CALL   5B64
070A4:  MOVLW  04
070A6:  MOVLB  C
070A8:  MOVWF  x4F
070AA:  MOVLW  FA
070AC:  MOVWF  x86
070AE:  MOVLB  0
070B0:  CALL   0EE2
070B4:  MOVLB  C
070B6:  DECFSZ x4F,F
070B8:  BRA    70AA
....................               send_APRS(  APRS_packet_no,APRS_info_str); delay_ms(1000); 
070BA:  MOVFF  B84,C4F
070BE:  MOVLW  0B
070C0:  MOVWF  x51
070C2:  MOVLW  C8
070C4:  MOVWF  x50
070C6:  MOVLB  0
070C8:  CALL   5B64
070CC:  MOVLW  04
070CE:  MOVLB  C
070D0:  MOVWF  x4F
070D2:  MOVLW  FA
070D4:  MOVWF  x86
070D6:  MOVLB  0
070D8:  CALL   0EE2
070DC:  MOVLB  C
070DE:  DECFSZ x4F,F
070E0:  BRA    70D2
....................               send_APRS(  APRS_packet_no,APRS_info_str);  
070E2:  MOVFF  B84,C4F
070E6:  MOVLW  0B
070E8:  MOVWF  x51
070EA:  MOVLW  C8
070EC:  MOVWF  x50
070EE:  MOVLB  0
070F0:  CALL   5B64
....................               fprintf(debugPort,"DONE SENDING \r\n"); 
070F4:  MOVLW  04
070F6:  MOVWF  FF6
070F8:  MOVLW  0D
070FA:  MOVWF  FF7
070FC:  MOVLW  00
070FE:  MOVWF  FF8
07100:  CLRF   1B
07102:  BTFSC  FF2.7
07104:  BSF    1B.7
07106:  BCF    FF2.7
07108:  CALL   0590
0710C:  BTFSC  1B.7
0710E:  BSF    FF2.7
....................          } 
07110:  BRA    76A0
07112:  MOVLB  6
....................          else if ( commandLine[5]==0xBB) 
07114:  MOVF   x29,W
07116:  SUBLW  BB
07118:  BTFSS  FD8.2
0711A:  BRA    7322
....................          { 
....................             fprintf(debugPort,"SENDING ...\r\n"); 
0711C:  MOVLW  14
0711E:  MOVWF  FF6
07120:  MOVLW  0D
07122:  MOVWF  FF7
07124:  MOVLW  00
07126:  MOVWF  FF8
07128:  CLRF   1B
0712A:  BTFSC  FF2.7
0712C:  BSF    1B.7
0712E:  BCF    FF2.7
07130:  MOVLB  0
07132:  CALL   0590
07136:  BTFSC  1B.7
07138:  BSF    FF2.7
....................             //sendingAX25(); 
....................             fprintf(debugPort,"DONE SENDING \r\n"); 
0713A:  MOVLW  22
0713C:  MOVWF  FF6
0713E:  MOVLW  0D
07140:  MOVWF  FF7
07142:  MOVLW  00
07144:  MOVWF  FF8
07146:  CLRF   1B
07148:  BTFSC  FF2.7
0714A:  BSF    1B.7
0714C:  BCF    FF2.7
0714E:  CALL   0590
07152:  BTFSC  1B.7
07154:  BSF    FF2.7
....................              
....................                           //sendingAX25(); 
....................               //send_APRS(data_to_send_APRS,sizeof(data_to_send_APRS)); 
....................               //downlink_serial(); 
....................               //send_acknowledgment_packet(); 
....................  
....................               RX_KISSframe_len=sizeof(RX_KISSframe); 
07156:  MOVLB  1
07158:  CLRF   x2C
0715A:  MOVLW  33
0715C:  MOVWF  x2B
....................               RX_packet_len = KISSframe_to_AX25packet(RX_KISSframe, RX_KISSframe_len, RX_packet); 
0715E:  MOVLW  01
07160:  MOVLB  C
07162:  MOVWF  x50
07164:  MOVLW  2D
07166:  MOVWF  x4F
07168:  MOVFF  12C,C52
0716C:  MOVFF  12B,C51
07170:  MOVLW  01
07172:  MOVWF  x54
07174:  MOVLW  62
07176:  MOVWF  x53
07178:  MOVLB  0
0717A:  GOTO   5D80
0717E:  MOVFF  02,161
07182:  MOVFF  01,160
....................                
....................               fprintf(debugPort,"Ax.25 frame as hex:\r\n "); 
07186:  MOVLW  32
07188:  MOVWF  FF6
0718A:  MOVLW  0D
0718C:  MOVWF  FF7
0718E:  MOVLW  00
07190:  MOVWF  FF8
07192:  CLRF   1B
07194:  BTFSC  FF2.7
07196:  BSF    1B.7
07198:  BCF    FF2.7
0719A:  CALL   0590
0719E:  BTFSC  1B.7
071A0:  BSF    FF2.7
....................               for (i=0;i<RX_packet_len;i++)  
071A2:  MOVLB  4
071A4:  CLRF   x83
071A6:  CLRF   x82
071A8:  CLRF   x81
071AA:  CLRF   x80
071AC:  MOVF   x83,F
071AE:  BNZ   7240
071B0:  MOVF   x82,F
071B2:  BNZ   7240
071B4:  MOVF   x81,W
071B6:  MOVLB  1
071B8:  SUBWF  x61,W
071BA:  BTFSC  FD8.0
071BC:  BRA    71C2
071BE:  MOVLB  4
071C0:  BRA    7240
071C2:  BNZ   71CE
071C4:  MOVF   x60,W
071C6:  MOVLB  4
071C8:  SUBWF  x80,W
071CA:  BC    7240
071CC:  MOVLB  1
....................               { 
....................                   putc(RX_packet[i],serial2APRS); 
071CE:  MOVLW  62
071D0:  MOVLB  4
071D2:  ADDWF  x80,W
071D4:  MOVWF  FE9
071D6:  MOVLW  01
071D8:  ADDWFC x81,W
071DA:  MOVWF  FEA
071DC:  MOVFF  FEF,C4F
071E0:  MOVLB  C
071E2:  MOVF   x4F,W
071E4:  MOVLB  0
071E6:  CALL   5A80
....................                   fprintf(debugPort,"%X ",RX_packet[i]); 
071EA:  MOVLW  62
071EC:  MOVLB  4
071EE:  ADDWF  x80,W
071F0:  MOVWF  FE9
071F2:  MOVLW  01
071F4:  ADDWFC x81,W
071F6:  MOVWF  FEA
071F8:  MOVFF  FEF,C9A
071FC:  CLRF   1B
071FE:  BTFSC  FF2.7
07200:  BSF    1B.7
07202:  BCF    FF2.7
07204:  MOVLW  37
07206:  MOVLB  C
07208:  MOVWF  x9B
0720A:  MOVLB  0
0720C:  CALL   05E8
07210:  BTFSC  1B.7
07212:  BSF    FF2.7
07214:  CLRF   1B
07216:  BTFSC  FF2.7
07218:  BSF    1B.7
0721A:  BCF    FF2.7
0721C:  MOVLW  20
0721E:  MOVLB  C
07220:  MOVWF  x9E
07222:  MOVLB  0
07224:  CALL   054A
07228:  BTFSC  1B.7
0722A:  BSF    FF2.7
0722C:  MOVLW  01
0722E:  MOVLB  4
07230:  ADDWF  x80,F
07232:  BTFSC  FD8.0
07234:  INCF   x81,F
07236:  BTFSC  FD8.2
07238:  INCF   x82,F
0723A:  BTFSC  FD8.2
0723C:  INCF   x83,F
0723E:  BRA    71AC
....................               } 
....................               putc('\r',serial2APRS); 
07240:  MOVLW  0D
07242:  MOVLB  0
07244:  CALL   5A80
....................               fprintf(debugPort,"\r\n "); 
07248:  MOVLW  4A
0724A:  MOVWF  FF6
0724C:  MOVLW  0D
0724E:  MOVWF  FF7
07250:  MOVLW  00
07252:  MOVWF  FF8
07254:  CLRF   1B
07256:  BTFSC  FF2.7
07258:  BSF    1B.7
0725A:  BCF    FF2.7
0725C:  CALL   0590
07260:  BTFSC  1B.7
07262:  BSF    FF2.7
....................                
....................               fprintf(debugPort,"Ax.25 frame as Asci:\r\n "); 
07264:  MOVLW  4E
07266:  MOVWF  FF6
07268:  MOVLW  0D
0726A:  MOVWF  FF7
0726C:  MOVLW  00
0726E:  MOVWF  FF8
07270:  CLRF   1B
07272:  BTFSC  FF2.7
07274:  BSF    1B.7
07276:  BCF    FF2.7
07278:  CALL   0590
0727C:  BTFSC  1B.7
0727E:  BSF    FF2.7
....................               for (i=0;i<RX_packet_len;i++)  
07280:  MOVLB  4
07282:  CLRF   x83
07284:  CLRF   x82
07286:  CLRF   x81
07288:  CLRF   x80
0728A:  MOVF   x83,F
0728C:  BNZ   72E4
0728E:  MOVF   x82,F
07290:  BNZ   72E4
07292:  MOVF   x81,W
07294:  MOVLB  1
07296:  SUBWF  x61,W
07298:  BTFSC  FD8.0
0729A:  BRA    72A0
0729C:  MOVLB  4
0729E:  BRA    72E4
072A0:  BNZ   72AC
072A2:  MOVF   x60,W
072A4:  MOVLB  4
072A6:  SUBWF  x80,W
072A8:  BC    72E4
072AA:  MOVLB  1
....................               { 
....................                   fprintf(debugPort,"%C",RX_packet[i]); 
072AC:  MOVLW  62
072AE:  MOVLB  4
072B0:  ADDWF  x80,W
072B2:  MOVWF  FE9
072B4:  MOVLW  01
072B6:  ADDWFC x81,W
072B8:  MOVWF  FEA
072BA:  MOVFF  FEF,C9E
072BE:  CLRF   1B
072C0:  BTFSC  FF2.7
072C2:  BSF    1B.7
072C4:  BCF    FF2.7
072C6:  MOVLB  0
072C8:  CALL   054A
072CC:  BTFSC  1B.7
072CE:  BSF    FF2.7
072D0:  MOVLW  01
072D2:  MOVLB  4
072D4:  ADDWF  x80,F
072D6:  BTFSC  FD8.0
072D8:  INCF   x81,F
072DA:  BTFSC  FD8.2
072DC:  INCF   x82,F
072DE:  BTFSC  FD8.2
072E0:  INCF   x83,F
072E2:  BRA    728A
....................               } 
....................               fprintf(debugPort,"\r\n "); 
072E4:  MOVLW  66
072E6:  MOVWF  FF6
072E8:  MOVLW  0D
072EA:  MOVWF  FF7
072EC:  MOVLW  00
072EE:  MOVWF  FF8
072F0:  CLRF   1B
072F2:  BTFSC  FF2.7
072F4:  BSF    1B.7
072F6:  BCF    FF2.7
072F8:  MOVLB  0
072FA:  CALL   0590
072FE:  BTFSC  1B.7
07300:  BSF    FF2.7
....................                
....................                
....................               int numberofreceivedpackets = 0; 
07302:  MOVLB  C
07304:  CLRF   x43
....................                if(RX_packet_len>16) 
07306:  MOVLB  1
07308:  MOVF   x61,F
0730A:  BNZ   7312
0730C:  MOVF   x60,W
0730E:  SUBLW  10
07310:  BC    731E
....................                {          
....................                   int8 parsing_result = parse_received_packet(); 
07312:  MOVLB  0
07314:  GOTO   60D8
07318:  MOVFF  01,C44
0731C:  MOVLB  1
....................                      //send_acknowledgment_packet();                      
....................          //!            if( parsing_result == 0x01 ) 
....................          //!            { 
....................          //!               //Send ACK packet if the received packet was a sensor data packet 
....................          //!               if(RX_info_field[2]==0x00)  
....................          //!               { 
....................          //!                  send_acknowledgment_packet(); 
....................          //!                  numberofreceivedpackets++; 
....................          //!                  puts(""); 
....................          //!                  printf("Number of Received Packets: %i", numberofreceivedpackets); 
....................          //!                  puts(""); 
....................          //!                  printf("AX.25 packet length (inc. CRC): %li", RX_packet_len+2); 
....................          //!                  puts(""); puts(""); puts(""); 
....................          //!               } 
....................          //!            } 
....................            
....................                }     
....................          } 
0731E:  BRA    76A4
07320:  MOVLB  6
....................          else if((commandLine[5]==0xA9)) 
07322:  MOVF   x29,W
07324:  SUBLW  A9
07326:  BTFSS  FD8.2
07328:  BRA    74B2
....................          { 
....................            
....................          unsigned int8 bytee[4]; 
.................... //!          bytee[0] = MyAdress &0x000000ff; 
.................... //!          bytee[1] = (MyAdress &0x0000ff00)>>8; 
.................... //!          bytee[2] = (MyAdress &0x00ff0000)>>16; 
.................... //!          bytee[3] = (MyAdress &0xff000000)>>24; 
.................... //!           
.................... //!          
....................            
....................            
....................           bytee[0] = READ_DATA_BYTE4(rcved_data_adrs_pointer); 
0732A:  MOVLW  05
0732C:  MOVLB  C
0732E:  MOVWF  x6D
07330:  MOVLW  FE
07332:  MOVWF  x6C
07334:  MOVLW  F0
07336:  MOVWF  x6B
07338:  CLRF   x6A
0733A:  MOVLB  0
0733C:  CALL   0E60
07340:  MOVFF  01,C45
....................           bytee[1] = READ_DATA_BYTE4(rcved_data_adrs_pointer+1); 
07344:  MOVLW  05
07346:  MOVLB  C
07348:  MOVWF  x6D
0734A:  MOVLW  FE
0734C:  MOVWF  x6C
0734E:  MOVLW  F0
07350:  MOVWF  x6B
07352:  MOVLW  01
07354:  MOVWF  x6A
07356:  MOVLB  0
07358:  CALL   0E60
0735C:  MOVFF  01,C46
....................           bytee[2] = READ_DATA_BYTE4(rcved_data_adrs_pointer+2); 
07360:  MOVLW  05
07362:  MOVLB  C
07364:  MOVWF  x6D
07366:  MOVLW  FE
07368:  MOVWF  x6C
0736A:  MOVLW  F0
0736C:  MOVWF  x6B
0736E:  MOVLW  02
07370:  MOVWF  x6A
07372:  MOVLB  0
07374:  CALL   0E60
07378:  MOVFF  01,C47
....................           bytee[3] = READ_DATA_BYTE4(rcved_data_adrs_pointer+3); 
0737C:  MOVLW  05
0737E:  MOVLB  C
07380:  MOVWF  x6D
07382:  MOVLW  FE
07384:  MOVWF  x6C
07386:  MOVLW  F0
07388:  MOVWF  x6B
0738A:  MOVLW  03
0738C:  MOVWF  x6A
0738E:  MOVLB  0
07390:  CALL   0E60
07394:  MOVFF  01,C48
....................             
....................                  
....................           delay_ms(10); 
07398:  MOVLW  0A
0739A:  MOVLB  C
0739C:  MOVWF  x86
0739E:  MOVLB  0
073A0:  CALL   0EE2
073A4:  CLRF   1B
073A6:  BTFSC  FF2.7
073A8:  BSF    1B.7
073AA:  BCF    FF2.7
....................           //fputc(byte3, serial2MB); 
....................           //delay_ms(10); 
....................           //fputc(byte2, serial2MB); 
....................           //delay_ms(10); 
....................           //fputc(byte1, serial2MB); 
....................           //delay_ms(10); 
....................           //fputc(byte0, serial2MB); 
....................           //delay_ms(10); 
....................           //fputc(data2MB,serial2MB); 
....................           
....................         //byte4 = datahex(MyAdress); 
....................         //fputc(byte4, serial2MB); 
....................          
....................          
....................         //unsigned int8 bytee[4]; 
....................    //Byte extraction 
....................    //bytee[0]  = (unsigned int8)((MyAdress>>24) & 0xFF);                          // 0x _ _ 00 00 00 
....................    //bytee[1]  = (unsigned int8)((MyAdress>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
....................    //bytee[2]  = (unsigned int8)((MyAdress>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
....................    //bytee[3]  = (unsigned int8)((MyAdress) & 0xFF);   
....................         fprintf(debugport,"\r\n"); 
073AC:  MOVLW  0D
073AE:  MOVLB  C
073B0:  MOVWF  x9E
073B2:  MOVLB  0
073B4:  CALL   054A
073B8:  BTFSC  1B.7
073BA:  BSF    FF2.7
073BC:  CLRF   1B
073BE:  BTFSC  FF2.7
073C0:  BSF    1B.7
073C2:  BCF    FF2.7
073C4:  MOVLW  0A
073C6:  MOVLB  C
073C8:  MOVWF  x9E
073CA:  MOVLB  0
073CC:  CALL   054A
073D0:  BTFSC  1B.7
073D2:  BSF    FF2.7
....................         fprintf(debugport,"\r\nprinting the adress in byte form\r\n"); 
073D4:  MOVLW  6A
073D6:  MOVWF  FF6
073D8:  MOVLW  0D
073DA:  MOVWF  FF7
073DC:  MOVLW  00
073DE:  MOVWF  FF8
073E0:  CLRF   1B
073E2:  BTFSC  FF2.7
073E4:  BSF    1B.7
073E6:  BCF    FF2.7
073E8:  CALL   0590
073EC:  BTFSC  1B.7
073EE:  BSF    FF2.7
....................         delay_ms(1000); 
073F0:  MOVLW  04
073F2:  MOVLB  C
073F4:  MOVWF  x4F
073F6:  MOVLW  FA
073F8:  MOVWF  x86
073FA:  MOVLB  0
073FC:  CALL   0EE2
07400:  MOVLB  C
07402:  DECFSZ x4F,F
07404:  BRA    73F6
....................         fputc(Command_00_ackMB,serial2MB); 
07406:  MOVLB  6
07408:  MOVF   x60,W
0740A:  MOVLB  0
0740C:  CALL   0F56
....................         for(int x =0; x<4; x++) 
07410:  MOVLB  C
07412:  CLRF   x49
07414:  MOVF   x49,W
07416:  SUBLW  03
07418:  BNC   7470
....................         { 
....................         fprintf(debugPort, "%X", bytee[x]); 
0741A:  CLRF   03
0741C:  MOVF   x49,W
0741E:  ADDLW  45
07420:  MOVWF  FE9
07422:  MOVLW  0C
07424:  ADDWFC 03,W
07426:  MOVWF  FEA
07428:  MOVFF  FEF,C9A
0742C:  CLRF   1B
0742E:  BTFSC  FF2.7
07430:  BSF    1B.7
07432:  BCF    FF2.7
07434:  MOVLW  37
07436:  MOVWF  x9B
07438:  MOVLB  0
0743A:  CALL   05E8
0743E:  BTFSC  1B.7
07440:  BSF    FF2.7
....................         delay_ms(10); 
07442:  MOVLW  0A
07444:  MOVLB  C
07446:  MOVWF  x86
07448:  MOVLB  0
0744A:  CALL   0EE2
....................         
....................         fputc(bytee[x],serial2MB); 
0744E:  CLRF   03
07450:  MOVLB  C
07452:  MOVF   x49,W
07454:  ADDLW  45
07456:  MOVWF  FE9
07458:  MOVLW  0C
0745A:  ADDWFC 03,W
0745C:  MOVWF  FEA
0745E:  MOVFF  FEF,C4F
07462:  MOVF   x4F,W
07464:  MOVLB  0
07466:  CALL   0F56
0746A:  MOVLB  C
0746C:  INCF   x49,F
0746E:  BRA    7414
....................         } 
....................          
....................         for(int y =0; y<76; y++) 
07470:  CLRF   x4A
07472:  MOVF   x4A,W
07474:  SUBLW  4B
07476:  BNC   74AE
07478:  CLRF   1B
0747A:  BTFSC  FF2.7
0747C:  BSF    1B.7
0747E:  BCF    FF2.7
....................         { 
....................         fprintf(debugPort, "%X", Command_00_ackMB); 
07480:  MOVFF  660,C9A
07484:  MOVLW  37
07486:  MOVWF  x9B
07488:  MOVLB  0
0748A:  CALL   05E8
0748E:  BTFSC  1B.7
07490:  BSF    FF2.7
....................         delay_ms(10); 
07492:  MOVLW  0A
07494:  MOVLB  C
07496:  MOVWF  x86
07498:  MOVLB  0
0749A:  CALL   0EE2
....................         
....................         fputc(Command_00_ackMB,serial2MB); 
0749E:  MOVLB  6
074A0:  MOVF   x60,W
074A2:  MOVLB  0
074A4:  CALL   0F56
074A8:  MOVLB  C
074AA:  INCF   x4A,F
074AC:  BRA    7472
....................         } 
....................          
....................           
....................          } 
074AE:  BRA    76A2
074B0:  MOVLB  6
....................           
....................          else if ((commandLine[5]==0xDD)||(commandLine[5]==0xA3)) 
074B2:  MOVF   x29,W
074B4:  SUBLW  DD
074B6:  BZ    74C0
074B8:  MOVF   x29,W
074BA:  SUBLW  A3
074BC:  BTFSS  FD8.2
074BE:  BRA    76A0
....................          { 
....................             int32 adrs_temp; 
....................              
....................             disable_interrupts(INT_RDA3); 
074C0:  BCF    F61.5
....................             sendACKtoMB(Command_DD_ackMB); 
074C2:  MOVFF  661,C4F
074C6:  MOVLB  0
074C8:  CALL   0F62
....................             fprintf(debugPort,"Received TLE data: "); 
074CC:  MOVLW  90
074CE:  MOVWF  FF6
074D0:  MOVLW  0D
074D2:  MOVWF  FF7
074D4:  MOVLW  00
074D6:  MOVWF  FF8
074D8:  CLRF   1B
074DA:  BTFSC  FF2.7
074DC:  BSF    1B.7
074DE:  BCF    FF2.7
074E0:  CALL   0590
074E4:  BTFSC  1B.7
074E6:  BSF    FF2.7
....................             for (i=0;i<TLE_size;i++) 
074E8:  MOVLB  4
074EA:  CLRF   x83
074EC:  CLRF   x82
074EE:  CLRF   x81
074F0:  CLRF   x80
074F2:  MOVF   x83,F
074F4:  BTFSS  FD8.2
074F6:  BRA    7612
074F8:  MOVF   x82,F
074FA:  BTFSS  FD8.2
074FC:  BRA    7612
074FE:  MOVF   x81,F
07500:  BTFSS  FD8.2
07502:  BRA    7612
07504:  MOVF   x80,W
07506:  SUBLW  22
07508:  BTFSS  FD8.0
0750A:  BRA    7612
....................             { 
....................                TLE_array[i]=fgetc(serial2MB);                
0750C:  MOVLW  38
0750E:  ADDWF  x80,W
07510:  MOVWF  FE9
07512:  MOVLW  06
07514:  ADDWFC x81,W
07516:  MOVWF  FEA
07518:  MOVFF  FEA,C52
0751C:  MOVFF  FE9,C51
07520:  CLRF   1B
07522:  BTFSC  FF2.7
07524:  BSF    1B.7
07526:  BCF    FF2.7
07528:  MOVLB  0
0752A:  CALL   0500
0752E:  BTFSC  1B.7
07530:  BSF    FF2.7
07532:  MOVFF  C52,FEA
07536:  MOVFF  C51,FE9
0753A:  MOVFF  01,FEF
....................                if (i%25==0) {fprintf(debugPort,"\r\n");} 
0753E:  BSF    FD8.1
07540:  MOVLW  0C
07542:  MOVWF  FEA
07544:  MOVLW  4F
07546:  MOVWF  FE9
07548:  MOVFF  483,C62
0754C:  MOVFF  482,C61
07550:  MOVFF  481,C60
07554:  MOVFF  480,C5F
07558:  MOVLB  C
0755A:  CLRF   x66
0755C:  CLRF   x65
0755E:  CLRF   x64
07560:  MOVLW  19
07562:  MOVWF  x63
07564:  MOVLB  0
07566:  CALL   176E
0756A:  MOVFF  C52,C56
0756E:  MOVFF  C51,C55
07572:  MOVFF  C50,C54
07576:  MOVFF  C4F,C53
0757A:  MOVLB  C
0757C:  MOVF   x53,F
0757E:  BNZ   75BC
07580:  MOVF   x54,F
07582:  BNZ   75BC
07584:  MOVF   x55,F
07586:  BNZ   75BC
07588:  MOVF   x56,F
0758A:  BNZ   75BC
0758C:  CLRF   1B
0758E:  BTFSC  FF2.7
07590:  BSF    1B.7
07592:  BCF    FF2.7
07594:  MOVLW  0D
07596:  MOVWF  x9E
07598:  MOVLB  0
0759A:  CALL   054A
0759E:  BTFSC  1B.7
075A0:  BSF    FF2.7
075A2:  CLRF   1B
075A4:  BTFSC  FF2.7
075A6:  BSF    1B.7
075A8:  BCF    FF2.7
075AA:  MOVLW  0A
075AC:  MOVLB  C
075AE:  MOVWF  x9E
075B0:  MOVLB  0
075B2:  CALL   054A
075B6:  BTFSC  1B.7
075B8:  BSF    FF2.7
075BA:  MOVLB  C
....................                fprintf(debugPort,"%X ",TLE_array[i]); 
075BC:  MOVLW  38
075BE:  MOVLB  4
075C0:  ADDWF  x80,W
075C2:  MOVWF  FE9
075C4:  MOVLW  06
075C6:  ADDWFC x81,W
075C8:  MOVWF  FEA
075CA:  MOVFF  FEF,C9A
075CE:  CLRF   1B
075D0:  BTFSC  FF2.7
075D2:  BSF    1B.7
075D4:  BCF    FF2.7
075D6:  MOVLW  37
075D8:  MOVLB  C
075DA:  MOVWF  x9B
075DC:  MOVLB  0
075DE:  CALL   05E8
075E2:  BTFSC  1B.7
075E4:  BSF    FF2.7
075E6:  CLRF   1B
075E8:  BTFSC  FF2.7
075EA:  BSF    1B.7
075EC:  BCF    FF2.7
075EE:  MOVLW  20
075F0:  MOVLB  C
075F2:  MOVWF  x9E
075F4:  MOVLB  0
075F6:  CALL   054A
075FA:  BTFSC  1B.7
075FC:  BSF    FF2.7
075FE:  MOVLW  01
07600:  MOVLB  4
07602:  ADDWF  x80,F
07604:  BTFSC  FD8.0
07606:  INCF   x81,F
07608:  BTFSC  FD8.2
0760A:  INCF   x82,F
0760C:  BTFSC  FD8.2
0760E:  INCF   x83,F
07610:  BRA    74F2
....................             } 
....................             SUBSECTOR_4KB_ERASE4(TLE_data_inFM); 
07612:  MOVLB  C
07614:  CLRF   x6C
07616:  CLRF   x6B
07618:  MOVLW  30
0761A:  MOVWF  x6A
0761C:  CLRF   x69
0761E:  MOVLB  0
07620:  CALL   0FF4
....................             adrs_temp=WRITE_DATA_N_BYTE4(TLE_data_inFM, sizeof(TLE_array_header),TLE_array_header); 
07624:  MOVLB  C
07626:  CLRF   x6C
07628:  CLRF   x6B
0762A:  MOVLW  30
0762C:  MOVWF  x6A
0762E:  CLRF   x69
07630:  CLRF   x70
07632:  CLRF   x6F
07634:  CLRF   x6E
07636:  MOVLW  04
07638:  MOVWF  x6D
0763A:  MOVLW  06
0763C:  MOVWF  x72
0763E:  MOVLW  5B
07640:  MOVWF  x71
07642:  MOVLB  0
07644:  CALL   1158
07648:  MOVFF  03,C4E
0764C:  MOVFF  02,C4D
07650:  MOVFF  01,C4C
07654:  MOVFF  00,C4B
....................             WRITE_DATA_N_BYTE4(adrs_temp, sizeof(TLE_array),TLE_array); 
07658:  MOVFF  C4E,C6C
0765C:  MOVFF  C4D,C6B
07660:  MOVFF  C4C,C6A
07664:  MOVFF  C4B,C69
07668:  MOVLB  C
0766A:  CLRF   x70
0766C:  CLRF   x6F
0766E:  CLRF   x6E
07670:  MOVLW  23
07672:  MOVWF  x6D
07674:  MOVLW  06
07676:  MOVWF  x72
07678:  MOVLW  38
0767A:  MOVWF  x71
0767C:  MOVLB  0
0767E:  CALL   1158
....................              
....................             //fprintf(debugPort,"\r\nTLE_size:%u .. sizeof(TLE_array): %u .. They Should be same",TLE_size,sizeof(TLE_array)); 
....................             fprintf(debugPort,"\r\n Reception of TLE is finished\r\n"); 
07682:  MOVLW  A4
07684:  MOVWF  FF6
07686:  MOVLW  0D
07688:  MOVWF  FF7
0768A:  MOVLW  00
0768C:  MOVWF  FF8
0768E:  CLRF   1B
07690:  BTFSC  FF2.7
07692:  BSF    1B.7
07694:  BCF    FF2.7
07696:  CALL   0590
0769A:  BTFSC  1B.7
0769C:  BSF    FF2.7
....................             //delay_ms(100); 
....................             enable_interrupts(INT_RDA3); 
0769E:  BSF    F61.5
076A0:  MOVLB  C
076A2:  MOVLB  1
076A4:  MOVLB  6
....................          } 
....................       } 
....................        
....................       actionMB=0; 
076A6:  BCF    1E.1
076A8:  MOVLB  B
....................    } 
076AA:  GOTO   6922
.................... //****************************************************************************** 
....................  
....................     
....................    } 
.................... } 
....................  
076AE:  SLEEP 
....................  

Configuration Fuses:
   Word  1: F7A0   STVREN NOXINST NODEBUG BROWNOUT_SW BORV18 NOPROTECT
   Word  2: FCA3   PR_PLL SOSC_DIG CLOCKOUT IESO PLL4X
   Word  3: F031   MS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FE03   T5G_IS_T5G CINA_DEFAULT NOIOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS DSWDT DSWDTOSC_INT
